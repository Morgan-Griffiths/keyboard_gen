const path = require('path')
const mongoose = require('mongoose')
const config = require('./app/config')
const Gym = require('./app/models/gym')
const GymSetup = require('./app/models/gymSetup')
const Setter = require('./app/models/setter')
const Settings = require('./app/models/settings')
const Grade = require('./app/models/grade')
const Route = require('./app/models/route')
const Location = require('./app/models/location')
const Draft = require('./app/models/draft')
const Plan = require('./app/models/plan')
const Field = require('./app/models/field')
const CustomField = require('./app/models/customField')
const Image = require('./app/models/image')
const gym = require('./app/models/gym')

async function init() {
  let db
  let mongodb = `mongodb://127.0.0.1:27017/setting`
  try {
    db = await mongoose.connect(
      mongodb,
      { useUnifiedTopology: true, useNewUrlParser: true },
      function(err) {
        if (err) {
          console.log(err)
        }
      }
    )
    // delete gym, settings,locations,customfields,undo setter roles,goals
    const gymSetup = {
      invitedSetters: [
        // {
        //   firstName: 'Morgan',
        //   lastName: 'Griffiths',
        //   email: 'C5ipo7i@yahoo.com',
        //   role: 'Setter',
        //   maxBSettingAbility: 33,
        // },
      ],
      currentStep: 4,
      setterId: '5da0d541a0641900d1c666f4',
      gym: {
        name: 'TWERP',
        address: 'TWERP',
        city: 'TWERP',
        state: 'California',
        ZIPCode: '12323',
        country: 'US',
        website: 'TWERP.com',
        key: 'TWERPTWERPTWERPCalifornia12323US',
      },
      settings: {
        boulderingEnabled: true,
        boulderingSystem: 'Vermin',
        ropedClimbingEnabled: false,
        ropedClimbingSystem: null,
        defaultBoulderingGrades: ['VB', 'V0', 'V0+', 'V1', 'V1+'],
        defaultRopedClimbingGrades: [],
        distMethod: 'Time & Grade',
        noveltyType: 'Active',
        noveltyField: 'Grade',
        noveltyWeights: [0, 0, 0, 0, 0, 0],
        terrainMask: {
          Slab: [
            'Crossing',
            'Flagging',
            'Bumping',
            'Gaston',
            'High Step',
            'Heel Hooking',
            'Toe Hooking',
            'Mantle',
            'Dyno',
            'Twisting',
            'Stemming',
            'Lock off',
            'Layback',
          ],
          Vertical: [
            'Crossing',
            'Flagging',
            'Bumping',
            'Gaston',
            'Lock off',
            'High Step',
            'Layback',
            'Heel Hooking',
            'Toe Hooking',
            'Stemming',
            'Twisting',
            'Mantle',
            'Dyno',
          ],
          Overhung: [
            'Crossing',
            'Flagging',
            'Bumping',
            'Gaston',
            'Lock off',
            'High Step',
            'Layback',
            'Heel Hooking',
            'Toe Hooking',
            'Campusing',
            'Twisting',
            'Dyno',
          ],
          Roof: [
            'Crossing',
            'Flagging',
            'Bumping',
            'Lock off',
            'High Step',
            'Layback',
            'Heel Hooking',
            'Toe Hooking',
            'Campusing',
            'Twisting',
            'Dyno',
          ],
        },
        displayedHeaders: ['Date', 'Setter', 'Grade', 'Location', 'Stripped'],
        displayedDraftHeaders: ['Date', 'Setter', 'Grade', 'Location', 'Notes'],
        gradeMask: {
          Bumping: 'V1',
          Flagging: 'V1',
          Crossing: 'V2',
          Stemming: 'V2',
          Layback: 'V2',
          'Heel Hooking': 'V2',
          Campusing: 'V3',
          Gaston: 'V3',
          Dyno: 'V3',
          'High Step': 'V4',
          Twisting: 'V4',
          'Toe Hooking': 'V4',
          'Lock off': 'V4',
          Mantle: 'V5',
        },
      },
      grades: [
        'VB',
        'V0',
        'V0+',
        'V1',
        'V1+',
        'V2',
        'V2+',
        'V3',
        'V3+',
        'V4',
        'V4+',
        'V5',
        'V5+',
        'V6',
        'V6+',
        'V7',
        'V7+',
        'V8',
        'V8+',
        'V9',
        'V9+',
        'V10',
        'V10+',
        'V11',
        'V11+',
        'V12',
        'V12+',
        'V13',
        'V13+',
        'V14',
        'V14+',
        'V15',
        'V15+',
        'V16',
      ],
      locations: [
        {
          image: null,
          name: 'happy',
          routeLimit: '12',
          discipline: 'Bouldering',
          terrainType: ['slab'],
          setDate: null,
        },
      ],
    }
    await GymSetup.insertMany(gymSetup)
  } catch (error) {
    console.log(error)
  } finally {
    mongoose.connection.close()
  }
}

// let gymId = '61cd47d31663e04bc379b7f4'
init()
module.exports = {
  testEnvironment: 'node'
};
const Account = require('../models/account')
const {
  PUBLIC_MUTATION_ENDPOINTS,
  API_ENDPOINTS,
} = require('../whitelisted_routes')
const PATH_CHECK = new Set(PUBLIC_MUTATION_ENDPOINTS)
const API_CHECK = new Set(API_ENDPOINTS)

const redirectByBilling = async (req, res, next) => {
  if (
    req.gym &&
    req.method !== 'GET' &&
    !PATH_CHECK.has(req.path) &&
    !API_CHECK.has(req.baseUrl)
  ) {
    account = await Account.findOne({ gymId: req.gym._id })
    if (
      (account.subscription_status !== 'active') ==
      (account.subscription_status !== 'trialing' ||
        (account.subscription_status === 'trialing' &&
          account.trial_end < Math.floor(+new Date() / 1000)))
    ) {
      if (
        !req.path.match(
          'products|account|create-checkout-session|create-customer-portal-session|create-customer'
        )
      ) {
        return res.status(402).send({
          message: 'Subscription has lapsed.',
          path: `/billing`,
        })
      }
    }
  }
  next()
}

module.exports = redirectByBilling
const UserSession = require('../libs/UserSession')
const url = require('url')

const session = async ({ user, gym, xhr, headers }, res, next) => {
  if (user && gym) {
    const userSession = new UserSession(res, user, gym)
    userSession.activate(user.useRememberMe)
  }
  if (user && !gym) {
    if (xhr) {
      const { pathname: path } = url.parse(headers.referer)
      if (path === '/' || path === '/create-gym') {
        return next()
      }
      return res.json({ needGym: true })
    }
    return res.redirect('/')
  }
  if (!user) {
    if (xhr) {
      const { pathname: path } = url.parse(headers.referer)
      if (path === '/signup') {
        return next()
      }
      return res
        .status(401)
        .send({ message: 'This is not an authorized user', path: '/signup' })
    }
    return res.redirect('/signup')
  }
  next()
}

module.exports = session
const url = require('url')

const xhrAuthenticate = async (
  { user, gym, xhr, headers, method },
  res,
  next
) => {
  const { pathname: path, query } = url.parse(headers.referer, true)
  if (path === '/create-gym' || path === '/signup') {
    return next()
  }
  if (!user) {
    return res.status(400).send('No user information.')
  }
  if (!gym) {
    if (!xhr && method !== 'GET') {
      return res.status(400).send('Does not support xhr requests.')
    }
    if (path === '/create-gym' || path === '/signup' || path === '/') {
      return next()
    }
  }
  if (user.superUser) {
    return next()
  }
  if (!user.email) {
    if (path === '/signup') {
      return next()
    }
    return res.status(401).send({
      message: 'This user is missing info.',
      path: `/signup`,
    })
  }
  if (
    user.gyms[gym._id] === 'Setter' ||
    user.gyms[gym._id] === 'Guest Setter'
  ) {
    if (
      (path !== '/setters-home' && path !== '/') ||
      (path === '/setters-home' && query.setter != user._id)
    ) {
      return res.status(401).send({
        message: 'This user is not authorized to visit this page.',
        path: `/setters-home?setter=${user._id}`,
      })
    }
  }
  next()
}

module.exports = xhrAuthenticate
const jwt = require('jsonwebtoken')
const Setter = require('../models/setter')
const Gym = require('../models/gym')
const config = require('../config')

const authenticate = async (req, res, next) => {
  if (!req.cookies['routemuse_session']) {
    if (req.xhr) {
      return next()
    }
    return res.redirect('/login')
  }
  const userCookie = jwt.verify(
    req.cookies['routemuse_session'],
    config.jwtSecret
  )
  const setter = await Setter.findById(userCookie.userId)
  if (!setter) {
    return res.redirect('/login')
  }
  req.user = setter
  const gym = await Gym.findById(userCookie.gymId)
  if (!gym) {
    if (req.xhr) {
      return next()
    }
    if (req.path !== '/') {
      return res.redirect('/')
    }
  }
  req.gym = gym
  if (!setter.email) {
    if (req.xhr) {
      return next()
    }
    return res.redirect('/signup')
  }
  next()
}

module.exports = authenticate
const redirectByRole = (req, res, next) => {
  const { user, gym, xhr } = req
  if (
    user &&
    !xhr &&
    user.gyms[gym._id].role !== 'Head Setter' &&
    !user.superUser
  ) {
    if (req.path !== '/setters-home' && req.path !== '/') {
      return res.redirect(`/setters-home?setter=${user._id}`)
    }
    if (req.path === '/setters-home' && req.query.setter != user._id) {
      return res.redirect(`/setters-home?setter=${user._id}`)
    }
  }
  next()
}

module.exports = redirectByRole
const express = require('express')
const path = require('path')
const app = express()
var cors = require('cors')
const bodyParser = require('body-parser')
const cookieParser = require('cookie-parser')
const config = require('./config')
const routes = require('./routes')

const { publicFolderPath } = config

app.use(cors())
app.use('/api/billing/webhook', bodyParser.raw({ type: '*/*' }))
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: true }))
app.use(cookieParser())
app.set('view engine', 'pug')
app.set('views', path.join(__dirname, '/views'))

app.use(
  '/css',
  express.static(`${publicFolderPath}/css`, { fallthrough: false })
)
app.use('/js', express.static(`${publicFolderPath}/js`, { fallthrough: false }))
app.use(
  '/fonts',
  express.static(`${publicFolderPath}/fonts`, { fallthrough: false })
)

app.use(routes)

module.exports = app
const mongoose = require('mongoose')
const Schema = mongoose.Schema

const schemaDoc = {
  gymId: {
    type: String,
    required: true,
  },
  image: {
    type: Schema.Types.ObjectId,
    ref: 'Image',
    autopopulate: true,
    required: false,
  },
  discipline: {
    type: String,
  },
  location: {
    type: String,
    required: true,
    select: true,
  },
  grade: {
    type: String,
    required: true,
    select: true,
  },
  setter: {
    type: String,
    required: true,
    select: true,
  },
  length: {
    type: String,
    required: true,
    select: true,
  },
  startLocation: {
    type: String,
    select: true,
  },
  finishLocation: {
    type: String,
    select: true,
  },
  techniques: {
    type: [String],
  },
  heightFriendly: {
    type: String,
    required: true,
    select: true,
  },
  holdType: {
    type: String,
    required: true,
    select: true,
  },
  intraDifficulty: {
    type: Number,
    required: true,
    select: true,
  },
  risk: {
    type: Number,
    min: 1,
    max: 5,
    required: true,
    select: true,
  },
  intensity: {
    type: Number,
    min: 1,
    max: 5,
    required: true,
    select: true,
  },
  complexity: {
    type: Number,
    min: 1,
    max: 5,
    required: true,
    select: true,
  },
  notes: {
    type: String,
  },
  setScrewed: {
    type: Boolean,
    default: false,
  },
  stripped: {
    type: Boolean,
    default: false,
  },
  date: {
    type: Date,
  },
  planId: String,
  time: {
    type: Object,
    default: {
      skeleton: 0,
      'setter forerun': 0,
      'group forerun': 0,
      finished: 0,
      stage: 'finished',
    },
  },
  emotion: {
    type: String,
  },
}
let routeSchema = new Schema(schemaDoc)

routeSchema.plugin(require('mongoose-autopopulate'))

if (mongoose.modelNames().includes('Route')) {
  mongoose.deleteModel('Route')
}

// Export the model
module.exports = mongoose.model('Route', routeSchema)
module.exports.schemaDoc = schemaDoc
const mongoose = require('mongoose')
const Schema = mongoose.Schema

let sessionSchema = new Schema({
  gymId: {
    type: String,
    required: true,
  },
  sessionId: {
    type: String,
    required: true,
  },
  priceId: {
    type: String,
    required: true,
  },
  productId: {
    type: String,
    required: true,
  },
  expireAt: {
    type: Date,
    expires: 600,
  },
})

sessionSchema.statics.createSession = function(
  sessionId,
  gymId,
  priceId,
  productId
) {
  return this.create({ sessionId, gymId, priceId, productId })
}

sessionSchema.statics.findSessionById = function(sessionId) {
  return this.findOne({ sessionId })
}

sessionSchema.plugin(require('mongoose-autopopulate'))
module.exports = mongoose.model('Session', sessionSchema)
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

let planSchema = new Schema({
  gymId: {
    type: String,
    required: true
  },
  name: {
    type: String
  },
  discipline: {
    type: String
  },
  locations: {
    type: []
  },
  setters: {
    type: []
  },
  suggestions: [],
  reassignments: Number,
  distributed: Boolean,
  complete: Boolean,
  date: Date
});

module.exports = mongoose.model('Plan', planSchema);
const mongoose = require('mongoose')
const Schema = mongoose.Schema

let notAUserSchema = new Schema({
  firstName: {
    type: String,
    required: true,
  },
  lastName: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
  },
  code: {
    type: Number,
    unique: true,
    required: true,
  },
  created: {
    type: Date,
    required: true,
  },
})

module.exports = mongoose.model('NotAUser', notAUserSchema)
const mongoose = require('mongoose')
const Schema = mongoose.Schema

let gymSchema = new Schema({
  name: {
    type: String,
    required: true,
  },
  address: {
    type: String,
    required: true,
  },
  city: {
    type: String,
    required: true,
  },
  state: {
    type: String,
  },
  ZIPCode: {
    type: String,
  },
  country: {
    type: String,
    required: true,
  },
  website: {
    type: String,
  },
  logo: {
    type: Schema.Types.ObjectId,
    ref: 'Image',
    autopopulate: true,
    required: false,
  },
  key: {
    type: String,
    required: true,
  },
})

gymSchema.statics.findGymByKey = function(key) {
  return this.findOne({ key })
}

gymSchema.plugin(require('mongoose-autopopulate'))
module.exports = mongoose.model('Gym', gymSchema)
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

let fieldSchema = new Schema({
  name: {
    type: String,
    unique: true,
    required: true
  },
  label: {
    type: String,
    required: true
  },
  values: [],
  type: {
    type: String,
    lowercase: true,
    trim: true,
    default: 'select'
  },
  enabled: Boolean
});
if (mongoose.modelNames().includes('Field')) {
  mongoose.deleteModel('Field');
}
// Export the model
module.exports = mongoose.model('Field', fieldSchema);
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

let goalSchema = new Schema({
  gymId: {
    type: String,
    required: true
  },
  name: {
    type: String,
    required: true,
    default: 'My Goals'
  },
  date: {
    type: Date,
    required: true,
    default: new Date()
  },
  active: {
    type: Boolean,
    required: true,
    default: false
  },
  totalGymRoutes: {
    type: Number,
    required: false
  },
  routesPerWeek: {
    type: Number,
    required: true
  },
  maximumRouteAge: {
    type: Number,
    required: true
  },
  techniques: {
    type: Array,
    required: true
  },
  grade: {
    type: Array,
    required: true
  },
  length: {
    type: Array,
    required: true
  },
  risk: {
    type: Array,
    required: true
  },
  intensity: {
    type: Array,
    required: true
  },
  complexity: {
    type: Array,
    required: true
  },
  heightFriendly: {
    type: Array,
    required: true
  },
  holdType: {
    type: Array,
    required: true
  }
});

// Export the model
module.exports = mongoose.model('Goal', goalSchema);
const mongoose = require('mongoose')
const Schema = mongoose.Schema

let accountSchema = new Schema({
  gymId: {
    type: String,
    required: true,
  },
  customerId: {
    type: String,
  },
  trial_start: {
    type: Number,
  },
  trial_end: {
    type: Number,
  },
  invoice: {
    type: String,
    enum: [
      'created',
      'finalized',
      'finalization_failed',
      'paid',
      'payment_failed',
      'payment_action_required',
      'upcoming',
      'initialized',
    ],
    default: 'initialized',
  },
  subscription: {
    type: String,
  },
  subscription_status: {
    type: String,
    enum: ['trialing', 'active', 'past_due', 'canceled', 'unpaid'],
    default: 'trialing',
  },
  productId: {
    type: String,
  },
  priceId: {
    type: String,
  },
  billing_period_start: {
    type: Number,
  },
  billing_period_end: {
    type: Number,
  },
})

accountSchema.statics.updatePrice = function(gymId, priceId) {
  return this.updateOne({ gymId }, { $set: { priceId } })
}

accountSchema.statics.updateProduct = function(gymId, productId) {
  return this.updateOne({ gymId }, { $set: { productId } })
}

accountSchema.statics.updateCustomer = function(gymId, customerId) {
  return this.updateOne({ gymId }, { $set: { customerId } })
}

accountSchema.statics.findSubscription = function(gymId) {
  return this.findOne({ gymId })
}

accountSchema.statics.findAccountByCustomer = function(customerId) {
  return this.findOne({ customerId })
}

accountSchema.statics.updateSubscriptionStatus = function(gymId, value) {
  return this.updateOne({ gymId }, { $set: { subscription_status: value } })
}
accountSchema.statics.updateSubscription = function(gymId, value) {
  return this.updateOne({ gymId }, { $set: { subscription: value } })
}

accountSchema.statics.updateInvoice = function(gymId, value) {
  return this.updateOne({ gymId }, { $set: { invoice: value } })
}

accountSchema.statics.updateBillingPeriod = function(gymId, startts, endts) {
  return this.updateOne(
    { gymId },
    { $set: { billing_period_start: startts, billing_period_end: endts } }
  )
}
accountSchema.plugin(require('mongoose-autopopulate'))
module.exports = mongoose.model('Account', accountSchema)
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

let gradeSchema = new Schema({
  name: {
    type: String,
    required: true
  },
  discipline: {
    type: String,
    required: true
  },
  values: Array,
  description: {
    type: String
  }
});

if (mongoose.modelNames().includes('Grade')) {
  mongoose.deleteModel('Grade');
}

module.exports = mongoose.model('Grade', gradeSchema);
const mongoose = require('mongoose')
const Schema = mongoose.Schema

let setterSchema = new Schema({
  gyms: {
    type: Object,
  },
  firstName: {
    type: String,
  },
  lastName: {
    type: String,
  },
  email: {
    type: String,
    required: true,
    index: { unique: true },
  },
  superUser: {
    type: Boolean,
    required: true,
  },
  active: {
    type: Boolean,
    required: true,
  },
  avatar: {
    type: Schema.Types.ObjectId,
    ref: 'Image',
    autopopulate: true,
    required: false,
  },
  useRememberMe: {
    type: Boolean,
    default: false,
  },
})
if (mongoose.modelNames().includes('Setter')) {
  mongoose.deleteModel('Setter')
}

setterSchema.plugin(require('mongoose-autopopulate'))

module.exports = mongoose.model('Setter', setterSchema)
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

let customFieldSchema = new Schema({
  gymId: {
    type: String,
    required: true
  },
  name: {
    type: String,
    required: true
  },
  label: {
    type: String,
    required: true
  },
  values: [],
  type: {
    type: String,
    lowercase: true,
    trim: true,
    default: 'select'
  },
  enabled: Boolean
});
if (mongoose.modelNames().includes('CustomField')) {
  mongoose.deleteModel('CustomField');
}

module.exports = mongoose.model('CustomField', customFieldSchema);
const mongoose = require('mongoose');
const Schema = mongoose.Schema;
const { schemaDoc } = require('./route');

const draftSchemaDoc = Object.keys(schemaDoc).reduce((carry, key) => {
  const schemaDefinition = schemaDoc[key];
  schemaDefinition.required = false;
  carry[key] = schemaDefinition;
  return carry;
}, {});

let draftSchema = new Schema(draftSchemaDoc);

draftSchema.plugin(require('mongoose-autopopulate'));

if (mongoose.modelNames().includes('Draft')) {
  mongoose.deleteModel('Draft');
}
// Export the model
module.exports = mongoose.model('Draft', draftSchema);
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const imageSchema = new Schema({
  key: {
    type: String,
    required: true
  },
  url: {
    type: String,
    required: true
  },
  date: {
    type: Date,
    required: true
  }
});
if (mongoose.modelNames().includes('Image')) {
  mongoose.deleteModel('Image');
}
module.exports = mongoose.model('Image', imageSchema);
const mongoose = require('mongoose')
const Schema = mongoose.Schema

let gymSetupSchema = new Schema({
  setterId: {
    type: String,
    required: true,
  },
  currentStep: {
    type: Number,
    required: true,
  },
  gym: {
    type: Object,
  },
  settings: {
    type: Object,
  },
  grades: {
    type: Object,
  },
  locations: {
    type: Object,
  },
})

module.exports = mongoose.model('GymSetup', gymSetupSchema)
const mongoose = require('mongoose')
const Schema = mongoose.Schema

let locationSchema = new Schema({
  gymId: {
    type: String,
    required: true,
  },
  image: {
    type: Schema.Types.ObjectId,
    ref: 'Image',
    autopopulate: true,
    required: false,
  },
  name: {
    type: String,
    required: true,
  },
  routeLimit: {
    type: Number,
    required: true,
  },
  discipline: {
    type: String,
  },
  terrainType: {
    type: [String],
    required: true,
  },
  setDate: {
    type: Date,
  },
})

locationSchema.plugin(require('mongoose-autopopulate'))
module.exports = mongoose.model('Location', locationSchema)
const mongoose = require('mongoose')
const Schema = mongoose.Schema

let targetSchema = new Schema({
  gymId: {
    type: String,
    required: true,
  },
  targets: {
    type: Object,
    required: true,
  },
  routeId: {
    type: String,
    required: true,
  },
  setterId: {
    type: String,
    required: true,
  },
})

// Export the model
module.exports = mongoose.model('Target', targetSchema)
const mongoose = require('mongoose')
const Schema = mongoose.Schema

let settingsSchema = new Schema({
  gymId: {
    type: String,
    required: true,
  },
  boulderingEnabled: {
    type: Boolean,
    required: true,
  },
  boulderingSystem: {
    type: String,
    required: true,
  },
  ropedClimbingEnabled: {
    type: Boolean,
    required: true,
  },
  ropedClimbingSystem: {
    type: String,
  },
  defaultBoulderingGrades: {
    type: Array,
    required: true,
  },
  defaultRopedClimbingGrades: {
    type: Array,
  },
  distMethod: {
    type: String,
    require: true,
  },
  noveltyType: {
    type: String,
  },
  noveltyField: {
    type: String,
  },
  noveltyWeights: {
    type: [Number],
  },
  gradeMask: {
    type: Object,
  },
  terrainMask: {
    type: Object,
  },
  displayedHeaders: {
    type: Array,
  },
  displayedDraftHeaders: {
    type: Array,
  },
})

settingsSchema.plugin(require('mongoose-autopopulate'))
if (mongoose.modelNames().includes('Settings')) {
  mongoose.deleteModel('Settings')
}
module.exports = mongoose.model('Settings', settingsSchema)
const path = require('path')

module.exports = {
  domainName: `${process.env.DOMAIN_NAME || 'localhost'}`,
  mode: `${process.env.NODE_ENV || 'development'}`,
  staticPath: `${process.env.STATIC_PATH || ''}`,
  publicFolderPath: `${process.env.STATIC_PATH ||
    path.join(__dirname, '/../public')}`,
  websiteTitle: `${process.env.WEBSITE_TITLE || 'RouteMuse'}`,
  port: process.env.SERVER_PORT || 8080,
  defaultProtocol: process.env.NODE_ENV ? 'https' : 'http',
  jwtSecret: `${process.env.JWT_SECRET || 'ROUTEMUSE_APP'}`,
  db: `mongodb://${process.env.MONGODB_HOST || 'localhost'}:27017/setting`,
  testDB: 'mongodb://localhost:27017/setting-test',
  suggestion_engine_host: `${process.env.SUGGESTION_ENGINE_HOST ||
    '172.16.0.5'}`,
  suggestion_engine_port: `${process.env.SUGGESTION_ENGINE_PORT || 5000}`,
  awsRegion: `${process.env.AWS_REGION || 'us-west-2'}`,
  awsBucket: `${process.env.AWS_BUCKET || 'routemusecats'}`,
}
const jwt = require('jsonwebtoken')
const config = require('../config')

class UserSession {
  static DEFAULT_SESSION_EXPIRE_IN_MILLISECOND = 86400000
  static REMEMBER_ME_SESSION_EXPIRE_IN_MILLISECOND = 31536000000

  constructor(response, user, gym) {
    this.response = response
    this.user = user
    this.gym = gym
  }

  activate(rememberMe = false) {
    const { user, gym, response } = this
    const maxAge = rememberMe
      ? UserSession.REMEMBER_ME_SESSION_EXPIRE_IN_MILLISECOND
      : UserSession.DEFAULT_SESSION_EXPIRE_IN_MILLISECOND
    let userSession
    if (gym) {
      userSession = jwt.sign(
        { userId: user._id, userRole: user.gyms[gym._id].role, gymId: gym._id },
        config.jwtSecret,
        {
          expiresIn: maxAge,
        }
      )
    } else {
      userSession = jwt.sign(
        { userId: user._id, userRole: null },
        config.jwtSecret,
        {
          expiresIn: maxAge,
        }
      )
    }
    response.cookie('routemuse_session', userSession, { maxAge })
  }
}

module.exports = UserSession
const PUBLIC_MUTATION_ENDPOINTS = ['/set']
const API_ENDPOINTS = ['/api/gym', '/api/gymSetup']
const PUBLIC_QUERY_ENDPOINTS = []

module.exports = {
  PUBLIC_MUTATION_ENDPOINTS,
  PUBLIC_QUERY_ENDPOINTS,
  API_ENDPOINTS,
}
const dayjs = require('dayjs')
const Route = require('../models/route')
const Draft = require('../models/draft')
const { QueryCursor } = require('mongoose')

const bulkInsert = async (body, gymId, model) => {
  body.forEach(route => {
    route.gymId = gymId
  })
  return await model.insertMany(body)
}

class DraftController {
  create(req, res, next) {
    req.body.gymId = req.gym._id
    const draft = new Draft({
      ...req.body,
      date: dayjs(req.body.date.trim()),
    })
    draft.save(function(err, document) {
      if (err) return next(err)
      res.send({ message: 'Draft saved', id: document._id })
    })
  }

  insertMany(req, res, next) {
    bulkInsert(req.body, req.gym._id, Draft)
      .then(drafts => {
        res.send(drafts)
      })
      .catch(next)
  }

  details(req, res, next) {
    Draft.findById(req.params.id, function(err, draft) {
      if (err) return next(err)
      res.send(draft)
    })
  }

  update(req, res, next) {
    Draft.findOneAndUpdate({ _id: req.params.id }, { $set: req.body }, function(
      err,
      draft
    ) {
      if (err) return next(err)
      res.send({ message: 'Draft updated' })
    })
  }

  delete(req, res, next) {
    Draft.findOneAndDelete({ _id: req.params.id }, function(err) {
      if (err) return next(err)
      res.send({ message: 'Draft deleted' })
    })
  }

  all(req, res, next) {
    let { query } = req
    query.gymId = req.gym._id
    Draft.find(query, function(err, drafts) {
      if (err) return next(err)
      res.send(drafts)
    })
  }

  deleteMany(req, res, next) {
    const { planId, ids } = req.body
    if (planId) {
      Draft.deleteMany({ planId }, err => {
        if (err) return next(err)
        res.send('Drafts deleted')
      })
    } else {
      Draft.deleteMany({ _id: { $in: ids } }, err => {
        if (err) return next(err)
        res.send({ message: 'Drafts deleted' })
      })
    }
  }
}

class RouteController {
  create(req, res, next) {
    req.body.gymId = req.gym._id
    req.body.date = dayjs(req.body.date.trim())
    const route = new Route({
      ...req.body,
    })
    route.save(function(err) {
      if (err) return next(err)
      res.send({ message: 'Route created' })
    })
  }

  insertMany(req, res, next) {
    bulkInsert(req.body, req.gym._id, Route)
      .then(routes => {
        res.send(routes)
      })
      .catch(next)
  }

  details(req, res, next) {
    Route.findById(req.params.id, function(err, route) {
      if (err) return next(err)
      res.send(route)
    })
  }

  update(req, res, next) {
    Route.findOneAndUpdate({ _id: req.params.id }, { $set: req.body }, function(
      err,
      route
    ) {
      if (err) return next(err)
      res.send({ message: 'Route updated' })
    })
  }

  updateMany(req, res, next) {
    const { body = { ids: [], fields: {} } } = req
    const { ids } = body
    const { fields } = body
    Route.updateMany({ _id: { $in: ids } }, { $set: fields }, err => {
      if (err) return next(err)
      res.send({ message: 'Routes updated' })
    })
  }

  delete(req, res, next) {
    Route.findOneAndDelete({ _id: req.params.id }, function(err) {
      if (err) return next(err)
      res.send({ message: 'Route deleted' })
    })
  }

  all(req, res, next) {
    let { query } = req
    let keys = Object.keys(query)
    for (let key of keys) {
      if (key.includes('(s)')) {
        let prop = key.replace('(s)', '')
        query[prop] = { $in: query[key].split(',') }
        delete query[key]
      }
      if (key.includes('!')) {
        let prop = key.replace('!', '')
        query[prop] = { $ne: query[key] }
        delete query[key]
      }
    }
    query.gymId = req.gym._id
    Route.find(query, function(err, routes) {
      if (err) return next(err)
      res.send(routes)
    })
  }

  deleteMany = (req, res, next) => {
    const { body = { ids: [] } } = req
    const { ids } = body
    Route.deleteMany({ _id: { $in: ids } }, err => {
      if (err) return next(err)
      res.send({ message: 'Routes deleted' })
    })
  }
}

module.exports = {
  DraftController,
  RouteController,
}
const Plan = require('../models/plan')
const config = require('../config')
const axios = require('axios')
const {
  Error: { ValidationError },
} = require('mongoose')
const options = { runValidators: true, new: true }

class PlanController {
  create(req, res) {
    req.body.gymId = req.gym._id
    let plan = new Plan({
      ...req.body,
    })

    plan.save(function(err, plan) {
      if (err) {
        res.status(500)
        if (err instanceof ValidationError) {
          res.status(400)
        }
        return res.json({ message: err.message })
      }
      res.send({ plan, message: 'Plan created' })
    })
  }

  details(req, res) {
    Plan.findOne({ _id: req.params.id }, function(err, plan) {
      if (err) {
        res.status(500)
        if (err instanceof ValidationError) {
          res.status(400)
        }
        return res.json({ message: err.message })
      }
      res.send(plan)
    })
  }

  update(req, res) {
    Plan.findOneAndUpdate(
      { _id: req.params.id },
      { $set: req.body },
      options,
      function(err, plan) {
        if (err) {
          res.status(500)
          if (err instanceof ValidationError) {
            res.status(400)
          }
          return res.json({ message: err.message })
        }
        res.send(plan)
      }
    )
  }

  delete(req, res, next) {
    Plan.findOneAndDelete({ _id: req.params.id }, function(err) {
      if (err) return next(err)
      res.send({ message: 'Plan deleted' })
    })
  }

  all(req, res, next) {
    let { query } = req
    query.gymId = req.gym._id
    Plan.find(query, function(err, plan) {
      if (err) return next(err)
      res.send(plan)
    })
  }

  suggestion(req, res) {
    axios
      .post(
        `http://${config.suggestion_engine_host}:${config.suggestion_engine_port}/api/plan?id=${req.query.id}`
      )
      .then(result => {
        res.send(result)
      })
      .catch(err => {
        res.send(err)
      })
  }
}

module.exports = PlanController
const Gym = require('../models/gym')
const Setter = require('../models/setter')
const UserSession = require('../libs/UserSession')
const { setup } = require('../../setup')
const options = { new: true }

class GymController {
  create(req, res, next) {
    let gym = new Gym({
      ...req.body.gym,
    })
    gym.save(async function(err, gym) {
      if (err) return next(err)
      res.send({ gym, message: 'Gym created' })
    })
  }
  details(req, res, next) {
    Gym.findOne({ _id: req.params.id }, function(err, gym) {
      if (err) return next(err)
      res.send(gym)
    })
  }
  update(req, res) {
    Gym.findOneAndUpdate(
      { _id: req.params.id },
      { $set: req.body },
      options,
      function(err, gym) {
        if (err) return next(err)
        res.send(gym)
      }
    )
  }
  delete(req, res, next) {
    Gym.findOneAndDelete({ _id: req.params.id }, function(err) {
      if (err) return next(err)
      res.send({ message: 'Gym deleted' })
    })
  }
  currentGym(req, res, next) {
    Gym.findOne({ _id: req.gym._id }, function(err, gym) {
      if (err) return next(err)
      res.send(gym)
    })
  }
  set(req, res) {
    const { user } = req
    const { gym } = req.body
    const userSession = new UserSession(res, user, gym)
    userSession.activate(user.useRememberMe)
    res.send({ message: 'Gym selected' })
  }
  all(req, res, next) {
    if (!req.user.gyms) {
      return res.send([])
    }
    const ids = Object.keys(req.user.gyms)
    Gym.find({ _id: { $in: ids } }, function(err, gyms) {
      if (err) return next(err)
      res.send(gyms)
    })
  }
}

module.exports = GymController
const Field = require('../models/field');

class FieldController {
  details(req, res, next) {
    Field.findOne({ name: req.params.name }, function(
      err,
      field
    ) {
      if (err) return next(err);
      res.send(field);
    });
  }
  
  all(req, res, next) {
    let { query } = req;
    if (query.names) {
      query.name = { $in: req.query.names.split(',') };
      delete query.names;
    }
    Field.find(query, (err, result) => {
      if (err) return next(err);
      res.send(result);
    });
  }
}

module.exports = FieldController;
const Goal = require('../models/goal')

class GoalController {
  create(req, res, next) {
    req.body.gymId = req.gym._id
    const goal = new Goal({
      ...req.body,
    })
    goal.save(function(err, goal) {
      if (err) return next(err)
      res.send({ goal, message: 'Goal saved' })
    })
  }

  details(req, res, next) {
    Goal.findOne({ _id: req.params.id }, function(err, goal) {
      if (err) return next(err)
      res.send({ goal })
    })
  }

  update(req, res, next) {
    Goal.findOneAndUpdate({ _id: req.params.id }, { $set: req.body }, function(
      err
    ) {
      if (err) return next(err)
      res.send({ message: 'Goals updated' })
    })
  }

  delete(req, res, next) {
    Goal.findOneAndDelete({ _id: req.params.id }, function(err, goal) {
      if (err) return next(err)
      res.send({ message: 'Goals deleted' })
    })
  }
  all(req, res, next) {
    let { query } = req
    query.gymId = req.gym._id
    Goal.find(query, function(err, result) {
      if (err) return next(err)
      res.send(result)
    })
  }
}

module.exports = GoalController
const Account = require('../models/account')

class AccountController {
  create(req, res, next) {
    const account = new Account({
      ...req.body,
    })
    account.save(function(err, account) {
      if (err) return next(err)
      res.send({ account, message: 'Account saved' })
    })
  }

  details(req, res, next) {
    Account.findOne({ _id: req.params.id }, function(err, account) {
      if (err) return next(err)
      res.send({ account })
    })
  }

  // update(req, res, next) {
  //   Account.findOneAndUpdate(
  //     { gymId: req.gym._id },
  //     { $set: req.body },
  //     function(err) {
  //       if (err) return next(err)
  //       res.send({ message: 'Account updated' })
  //     }
  //   )
  // }

  // delete(req, res, next) {
  //   Account.findOneAndDelete({ _id: req.params.id }, function(err, account) {
  //     if (err) return next(err)
  //     res.send({ message: 'Account deleted' })
  //   })
  // }

  all(req, res, next) {
    let { query } = req
    query.gymId = req.gym._id
    Account.find(query, function(err, result) {
      if (err) return next(err)
      res.send(result)
    })
  }
}

module.exports = AccountController
const Grade = require('../models/grade')

class GradeController {
  details(req, res, next) {
    Grade.findOne({ name: req.params.name }, function(err, grade) {
      if (err) return next(err)
      res.send(grade)
    })
  }

  all(req, res, next) {
    Grade.find(req.query, function(err, grades) {
      if (err) return next(err)
      res.send(grades)
    })
  }
}

module.exports = GradeController
const Setter = require('../models/setter')
const Image = require('../models/image')
const jwt = require('jsonwebtoken')
const mongoose = require('mongoose')
const config = require('../config')
const AWS = require('aws-sdk')

let host
if (config.mode === 'production') {
  AWS.config.credentials = new AWS.ECSCredentials({
    httpOptions: { timeout: 5000 },
    maxRetries: 10,
    retryDelayOptions: { base: 200 },
  })
  host = `${config.defaultProtocol}://${config.domainName}`
} else {
  const localCredentials = new AWS.Credentials(
    process.env.AWS_KEY,
    process.env.AWS_SECRET
  )
  AWS.config.credentials = localCredentials
  host = `${config.defaultProtocol}://${config.domainName}:${config.port}`
}
AWS.config.update({ region: config.awsRegion })

const s3 = new AWS.S3()

const bulkDelete = async (ids = []) => {
  const setters = await Setter.find({ _id: { $in: ids } })
  const { imageIds, imageKeys } = setters.reduce(
    (carry, setter) => {
      if (!(setter.avatar == undefined || setter.avatar == null)) {
        carry.imageIds.push(setter.avatar._id)
        carry.imageKeys.push({ Key: setter.avatar.key })
      }
      return carry
    },
    { imageIds: [], imageKeys: [] }
  )
  if (imageIds.length > 0) {
    let params = {
      Bucket: config.awsBucket,
      Delete: {
        Objects: imageKeys,
        Quiet: false,
      },
    }
    return Promise.all([
      Image.deleteMany({ _id: { $in: imageIds } }),
      Setter.deleteMany({ _id: { $in: ids } }),
      s3.deleteObjects(params, (err, data) => {
        if (err) return err
        return data
      }),
    ])
  } else {
    Setter.deleteMany({ _id: { $in: ids } }, err => {
      if (err) return next(err)
    })
  }
}

const sendInvite = async (setter, gym) => {
  const token = jwt.sign(
    { userId: setter._id, gymId: gym._id },
    config.jwtSecret,
    {
      expiresIn: '72h',
    }
  )
  params = {
    Destination: {
      ToAddresses: [`${setter.email}`],
    },
    Message: {
      Body: {
        Html: {
          Charset: 'UTF8',
          Data: `
                <p>Hi,</p>
                <p>
                  Your gym, ${gym.name}, has added you as a setter. 
                  Please click this <a href="${host}/token/${token}">link</a> to login to Routemuse!
                </p>
                <p>
                  Climb on!
                </p>`,
        },
        Text: {
          Charset: 'UTF8',
          Data: 'TEXT_FORMAT_BODY',
        },
      },
      Subject: {
        Charset: 'UTF8',
        Data: 'Routemuse Login Link',
      },
    },
    Source: 'RouteMuse App<noreply@routemuse.com>',
  }

  let sendPromise = new AWS.SES({ apiVersion: '2010-12-01' })
    .sendEmail(params)
    .promise()

  return sendPromise
    .then(function() {
      return { message: 'Sent the invitation.' }
    })
    .catch(function(err) {
      return { message: 'Failed to send link, please contact support.', err }
    })
}

const inviteAndSave = async (invites, gym) => {
  for (const invite of invites) {
    let setter = await Setter.findOne({ email: invite.email })

    let gymAttrs = {
      role: `${invite.role || 'Setter'}`,
      maxBSettingAbility: invite.maxBSettingAbility,
      totalRoutes: 0,
      assignments: 0,
      ricBias: '',
    }
    if (!setter) {
      setter = new Setter({
        firstName: invite.firstName,
        lastName: invite.lastName,
        gyms: { [gym._id]: gymAttrs },
        email: invite.email,
        superUser: false,
        active: true,
      })
      let result = await setter.save()
      await sendInvite(result, gym)
    } else {
      Setter.findOneAndUpdate(
        { _id: setter.id },
        { $set: { gyms: { [gym._id]: gymAttrs } } },
        {
          runValidators: true,
        },
        async function(err, setter) {
          if (err) {
            return res.status(400).json({ error: err.message })
          }
          await sendInvite(setter, gym)
        }
      )
    }
  }
  return
}

class SetterController {
  create(req, res, next) {
    if (req.gym) req.body.gyms = { [req.gym._id]: req.body.role }
    delete req.body.role
    let setter = new Setter({
      ...req.body,
    })
    setter.save(function(err) {
      if (err) return next(err)
      res.send({
        setter,
        message: 'Setter created',
      })
    })
  }

  invite(req, res, next) {
    const { body, gym } = req
    return inviteAndSave(body, gym)
      .then(() => res.send('Invitations have been sent.'))
      .catch(next)
  }

  details(req, res, next) {
    let query = Object.entries(req.params).reduce((carry, key, value) => {
      idkey = '_id' ? key === 'id' : key
      carry[idkey] = value
      return carry
    }, {})
    Setter.findOne(query, function(err, setter) {
      if (err) return next(err)
      let setterObj = setter.toObject()
      setterObj.role = setter.gyms[req.gymId] ? req.gymId : null
      res.send(setterObj)
    })
  }

  update(req, res) {
    let { body, gym, user } = req
    if (body.role) {
      body.gyms = user.gyms
      body.gyms[gym._id] = body.role
      delete body.role
    }
    Setter.findOneAndUpdate(
      { _id: req.params.id },
      { $set: body },
      {
        runValidators: true,
      },
      function(err, setter) {
        if (err) {
          return res.status(400).json({ error: err.message })
        }
        let message
        if (req.user.email === setter.email) {
          message = 'Your profile has been updated.'
        } else {
          message = `${setter.firstName}'s profile has been updated`
        }
        res.send({ message })
      }
    )
  }

  delete(req, res, next) {
    Setter.findOneAndDelete({ _id: req.params.id }, function(err) {
      if (err) return next(err)
      res.send({ message: 'Setter deleted' })
    })
  }

  deleteMany(req, res, next) {
    const { body = { ids: [] } } = req
    const { ids } = body
    return bulkDelete(ids)
      .then(() =>
        res.send({
          message: `${ids.length > 1 ? 'Setters' : 'Setter'} deleted`,
        })
      )
      .catch(next)
  }

  all(req, res, next) {
    let { query } = req
    query['gyms.' + req.gym._id] = { $exists: true }
    Setter.find(query, function(err, setters) {
      if (err) return next(err)
      const thisGymsSetters = setters.reduce((carry, setter) => {
        if (setter.gyms[req.gym._id]) {
          let setterObj = setter.toObject()
          setterObj.role = setter.gyms[req.gym._id].role
          carry.push(setterObj)
        }
        return carry
      }, [])
      res.send(thisGymsSetters)
    })
  }
}

module.exports = SetterController
const CustomField = require('../models/customField')

class CustomFieldController {
  create(req, res, next) {
    if (req.gym) {
      req.body.gymId = req.gym._id
    }
    let customField = new CustomField({
      ...req.body,
    })

    customField.save(function(err) {
      if (err) return next(err)
      res.send({ message: 'Custom field created' })
    })
  }

  details(req, res, next) {
    CustomField.findOne({ gymId: req.gym._id, name: req.params.name }, function(
      err,
      field
    ) {
      if (err) return next(err)
      res.send(field)
    })
  }

  update(req, res, next) {
    CustomField.findOneAndUpdate(
      { gymId: req.gym._id, name: req.params.name },
      { $set: req.body },
      function(err, customField) {
        if (err) return next(err)
        res.send({ message: `${customField.label} field updated` })
      }
    )
  }

  delete(req, res, next) {
    CustomField.findOneAndDelete(
      { gymId: req.gym._id, name: req.params.name },
      function(err) {
        if (err) return next(err)
        res.send({ message: 'Custom field deleted' })
      }
    )
  }

  all(req, res, next) {
    let { query } = req
    query.gymId = req.gym._id
    CustomField.find(query, (err, result) => {
      if (err) return next(err)
      res.send(result)
    })
  }
}

module.exports = CustomFieldController
const config = require('../config.js')
const Image = require('../models/image')
const AWS = require('aws-sdk')
const Promise = require('bluebird')

if (config.mode === 'production') {
  AWS.config.credentials = new AWS.ECSCredentials({
    httpOptions: { timeout: 5000 },
    maxRetries: 10,
    retryDelayOptions: { base: 200 },
  })
} else {
  const localCredentials = new AWS.Credentials(
    process.env.AWS_KEY,
    process.env.AWS_SECRET
  )
  AWS.config.credentials = localCredentials
}
AWS.config.update({ region: config.awsRegion })

const s3 = new AWS.S3()

class ImageController {
  upload(req, res, next) {
    const { file } = req
    const { key, location, originalname } = file
    if (location) {
      const image = new Image({
        gymId: req.gym._id,
        key,
        url: location,
        date: new Date(),
      })
      image.save((err, image) => {
        if (err) return next(err)
        res.send(image)
      })
    } else {
      res.status(400).send(`Filename: ${originalname}`)
    }
  }

  delete(req, res, next) {
    const {
      params: { id: _id },
    } = req
    Image.findOne({ _id })
      .then(image => {
        const params = {
          Bucket: config.awsBucket,
          Key: image.key,
        }
        return Promise.all([
          s3.deleteObject(params, (err, data) => {
            if (err) next(err)
            return data
          }),
          image.deleteOne(),
        ])
      })
      .then(() => {
        res.send({ message: `Deleted image ${_id}` })
      })
      .catch(err => {
        next(err)
      })
  }
}

module.exports = ImageController
const GymSetup = require('../models/gymSetup')
const options = { new: true }

class GymSetupController {
  create(req, res, next) {
    let setup = new GymSetup({
      ...req.body,
    })
    setup.save(async function(err, setup) {
      if (err) return next(err)
      res.send(setup)
    })
  }
  details(req, res, next) {
    GymSetup.findOne({ _id: req.params.id }, function(err, setup) {
      if (err) return next(err)
      res.send(setup)
    })
  }
  update(req, res) {
    GymSetup.findOneAndUpdate(
      { _id: req.params.id },
      { $set: req.body },
      options,
      function(err, setup) {
        if (err) return next(err)
        res.send(setup)
      }
    )
  }
  delete(req, res, next) {
    GymSetup.findOneAndDelete({ _id: req.params.id }, function(err) {
      if (err) return next(err)
      res.send({ message: 'Setup deleted' })
    })
  }
  all(req, res, next) {
    GymSetup.find({ setterId: req.user._id }, function(err, setup) {
      if (err) return next(err)
      res.send(setup)
    })
  }
}

module.exports = GymSetupController
const Location = require('../models/location')
const Route = require('../models/route')
const {
  Error: { ValidationError },
} = require('mongoose')
const options = { runValidators: true, new: true }

const bulkInsert = async (body, gymId, model) => {
  body.forEach(route => {
    route.gymId = gymId
  })
  return await model.insertMany(body)
}

const locationsByDate = async gymId => {
  const locations = await Location.find({ gymId })
  const routes = await Route.find({ gymId, stripped: false })
  const queries = locations.reduce((carry, location) => {
    let dates = routes.reduce((carry, route) => {
      if (route.location === location.name) {
        if (route.date !== undefined && !isNaN(route.date.getTime())) {
          carry.push(route.date)
        }
      }
      return carry
    }, [])
    if (dates.length > 0) {
      carry.push({ _id: location._id, date: new Date(Math.min(...dates)) })
    }
    return carry
  }, [])
  for (query of queries) {
    await Location.findOneAndUpdate(
      { _id: [query._id] },
      { $set: { setDate: query.date } }
    )
  }
}

class LocationController {
  create(req, res) {
    req.body.gymId = req.gym._id
    let location = new Location({
      ...req.body,
    })
    location.save(function(err, location) {
      if (err) {
        res.status(500)
        if (err instanceof ValidationError) {
          res.status(400)
        }
        return res.json({ message: err.message })
      }
      res.send(location)
    })
  }

  insertMany(req, res, next) {
    bulkInsert(req.body, req.gym._id, Location)
      .then(location => {
        res.send(location)
      })
      .catch(next)
  }

  details(req, res, next) {
    Location.findOne({ _id: req.params.id }, function(err, location) {
      if (err) return next(err)
      res.send(location)
    })
  }

  update(req, res) {
    Location.findOneAndUpdate(
      { _id: req.params.id },
      { $set: req.body },
      options,
      function(err, location) {
        if (err) {
          res.status(500)
          if (err instanceof ValidationError) {
            res.status(400)
          }
          return res.json({ message: err.message })
        }
        res.send(location)
      }
    )
  }

  delete(req, res, next) {
    Location.findOneAndDelete({ _id: req.params.id }, function(err, location) {
      if (err) return next(err)
      res.send(location)
    })
  }

  all(req, res, next) {
    let { query } = req
    if (query.names) {
      query = {
        name: { $in: req.query.names.split(',') },
      }
    }
    query.gymId = req.gym._id
    Location.find(query, function(err, locations) {
      if (err) return next(err)
      res.send(locations)
    })
  }

  setDates(req, res, next) {
    return locationsByDate(req.gym._id)
      .then(() => {
        Location.find({ gymId: req.gym._id }, function(err, location) {
          res.send(location)
        }).sort({ setDate: 1 })
      })
      .catch(next)
  }
}

module.exports = LocationController
const Target = require('../models/target')

class TargetController {
  create(req, res, next) {
    req.body.gymId = req.gym._id
    const target = new Target({
      ...req.body,
    })
    target.save(function(err, target) {
      if (err) return next(err)
      res.send({ target, message: 'Target saved' })
    })
  }

  details(req, res, next) {
    if (req.params.hasOwnProperty('id')) {
      Target.findOne({ _id: req.params.id }, function(err, target) {
        if (err) return next(err)
        res.send({ target })
      })
    } else {
      Target.findOne(
        {
          gymId: req.gym._id,
          routeId: req.params.routeId,
          setterId: req.params.setterId,
        },
        function(err, target) {
          if (err) return next(err)
          res.send({ target })
        }
      )
    }
  }

  update(req, res, next) {
    Target.findOneAndUpdate(
      { _id: req.params.id },
      { $set: req.body },
      function(err) {
        if (err) return next(err)
        res.send({ message: 'Targets updated' })
      }
    )
  }

  delete(req, res, next) {
    Target.findOneAndDelete({ _id: req.params.id }, function(err, target) {
      if (err) return next(err)
      res.send({ message: 'Targets deleted' })
    })
  }
  all(req, res, next) {
    let { query } = req
    query.gymId = req.gym._id
    Target.find(query, function(err, result) {
      if (err) return next(err)
      res.send(result)
    })
  }
}

module.exports = TargetController
const Settings = require('../models/settings')

class SettingsController {
  create(req, res, next) {
    if (req.gym) {
      req.body.gymId = req.gym._id
    }

    let settings = new Settings({
      ...req.body,
    })

    settings.save(function(err) {
      if (err) return next(err)
      res.send({ settings, message: 'Settings saved' })
    })
  }

  update(req, res, next) {
    Settings.findOneAndUpdate(
      { _id: req.params.id },
      { $set: req.body },
      function(err, settings) {
        if (err) return next(err)
        res.send({ settings, message: 'Settings updated' })
      }
    )
  }

  delete(req, res, next) {
    Settings.findOneAndDelete({ _id: req.params.id }, function(err) {
      if (err) return next(err)
      res.send({ message: 'Settings deleted' })
    })
  }

  get(req, res, next) {
    let { query } = req
    query.gymId = req.gym._id
    Settings.findOne(query, function(err, settings) {
      if (err) return next(err)
      res.send(settings)
    })
  }
}

module.exports = SettingsController
const express = require('express')
const router = express.Router()
const Route = require('../controllers/route')

const routeController = new Route.RouteController()
const draftController = new Route.DraftController()

// Drafts

router.post('/draft/create', draftController.create)

router.post('/drafts/bulk/create', draftController.insertMany)

router.get('/draft/:id', draftController.details)

router.put('/draft/:id', draftController.update)

router.delete('/draft/:id', draftController.delete)

router.get('/drafts', draftController.all)

router.delete('/drafts/bulk/delete', draftController.deleteMany)

// Routes

router.post('/create', routeController.create)

router.post('/bulk/create', routeController.insertMany)

router.get('/:id', routeController.details)

router.get('/', routeController.all)

router.put('/:id', routeController.update)

router.put('/bulk/edit', routeController.updateMany)

router.delete('/:id', routeController.delete)

router.delete('/bulk/delete', routeController.deleteMany)

module.exports = router
const router = require('express').Router()

router.get('/', async (req, res, next) => {
  let currentUser = req.user.toObject()
  res.send({ currentUser })
})

module.exports = router
const express = require('express')
const router = express.Router()
const Plan = require('../controllers/plan')

const planController = new Plan()

router.post('/create', planController.create)

router.post('/suggestion', planController.suggestion)

router.get('/', planController.all)

router.get('/:id', planController.details)

router.put('/:id', planController.update)

router.delete('/:id', planController.delete)

module.exports = router
const express = require('express');
const router = express.Router();
const CustomGrade = require('../controllers/customGrade');

const customGradeController = new CustomGrade();

router.post('/create', customGradeController.create);

router.get('/:discipline', customGradeController.details);

router.put('/:discipline', customGradeController.update);

router.delete('/', customGradeController.delete);

module.exports = router;const express = require('express')
const router = express.Router()
const Gym = require('../controllers/gym')

const gymController = new Gym()

router.post('/create', gymController.create)

router.post('/set', gymController.set)

router.get('/current', gymController.currentGym)

router.get('/', gymController.all)

router.get('/:id', gymController.details)

router.put('/:id', gymController.update)

router.delete('/:id', gymController.delete)

module.exports = router
const express = require('express');
const router = express.Router();
const Field = require('../controllers/field');

const fieldController = new Field();

router.get('/:name', fieldController.details);

router.get('/', fieldController.all);

module.exports = router;
const path = require('path')
const router = require('express').Router()
const config = require('../config')
const authenticate = require('../middleware/authenticate')
const xhrAuthenticate = require('../middleware/xhrAuthenticate')
const redirectByRole = require('../middleware/redirectByRole')
const redirectByBilling = require('../middleware/redirectByBilling')
const session = require('../middleware/session')

const gyms = require('./gym')
const gymSetup = require('./gymSetup')
const routes = require('./route')
const fields = require('./field')
const customFields = require('./customField')
const setters = require('./setter')
const grades = require('./grade')
const goals = require('./goal')
const targets = require('./target')
const settings = require('./settings')
const images = require('./image')
const plans = require('./plan')
const locations = require('./location')
const currentUser = require('./currentUser')
const token = require('./token')
const billing = require('./billing')
const account = require('./account')
const confirm = require('./confirm')
const baseMiddlewares = [
  authenticate,
  session,
  redirectByRole,
  redirectByBilling,
]
const xhrBaseMiddlewares = [...baseMiddlewares, xhrAuthenticate]

router.use('/api/account', account)
router.use('/api/confirm', confirm)
router.use('/api/billing', billing)
router.use('/token', token)

router.get('(/login|/create-gym|/|/signup)', function(_, res) {
  res.render('index', {
    title: config.websiteTitle,
    staticPath: config.staticPath,
  })
})
router.get('/health', function(_, res) {
  res.status(200).end()
})

router.use('/api/gym', xhrBaseMiddlewares, gyms)
router.use('/api/gymSetup', xhrBaseMiddlewares, gymSetup)
router.use('/api/routes', xhrBaseMiddlewares, routes)
router.use('/api/fields', xhrBaseMiddlewares, fields)
router.use('/api/customFields', xhrBaseMiddlewares, customFields)
router.use('/api/setters', xhrBaseMiddlewares, setters)
router.use('/api/grades', xhrBaseMiddlewares, grades)
router.use('/api/targets', xhrBaseMiddlewares, targets)
router.use('/api/goals', xhrBaseMiddlewares, goals)
router.use('/api/settings', xhrBaseMiddlewares, settings)
router.use('/api/images', xhrBaseMiddlewares, images)
router.use('/api/locations', xhrBaseMiddlewares, locations)
router.use('/api/plans', xhrBaseMiddlewares, plans)
router.use('/api/currentUser', xhrBaseMiddlewares, currentUser)
router.get('/*', baseMiddlewares, function(_, res) {
  res.render('index', {
    title: config.websiteTitle,
    staticPath: config.staticPath,
  })
})

module.exports = router
const router = require('express').Router()
const jwt = require('jsonwebtoken')
const config = require('../config')
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY)
const Account = require('../models/account')
const Session = require('../models/session')
const Gym = require('../models/gym')
let host
if (config.mode === 'production') {
  host = `${config.defaultProtocol}://${config.domainName}`
} else {
  host = `${config.defaultProtocol}://${config.domainName}:${config.port}`
}

router.get('/account', async (req, res) => {
  let userSession = jwt.verify(
    req.cookies['routemuse_session'],
    config.jwtSecret
  )
  const account = await Account.findSubscription(userSession.gymId)
  return res.json({ data: account })
})

router.get('/prices', async (_, res) => {
  const prices = await stripe.prices.list({
    limit: 3,
  })
  return res.json({ data: prices.data })
})

router.get('/products', async (_, res) => {
  const products = await stripe.products.list({
    limit: 3,
  })
  return res.json({ data: products.data })
})

router.post('/create-customer', async (req, res) => {
  const customer = await stripe.customers.create({
    ...req.body,
  })
  return res.json({ customer })
})

router.post('/create-trial-session', async (req, res) => {
  const subscription = await stripe.subscriptions.create({
    customer: req.body.customerId,
    items: [
      {
        price: req.body.priceId,
      },
    ],
    billing_cycle_anchor: req.body.trial_end,
  })
  return res.json({ subscription })
})

router.get('/create-customer-portal-session', async (req, res) => {
  let userSession = jwt.verify(
    req.cookies['routemuse_session'],
    config.jwtSecret
  )
  let account = await Account.findSubscription(userSession.gymId)
  const session = await stripe.billingPortal.sessions.create({
    customer: `${account.customerId}`,
    return_url: `${host}/billing`,
  })
  return res.json({ url: session.url })
})

router.post('/create-checkout-session', async (req, res) => {
  const { priceId, productId } = req.body
  const session = await stripe.checkout.sessions.create({
    mode: 'subscription',
    line_items: [
      {
        price: priceId,
        // For metered billing, do not pass quantity
        quantity: 1,
      },
    ],
    success_url: `${host}/subscription-success`,
    cancel_url: `${host}/subscription-canceled`,
  })
  let userSession = jwt.verify(
    req.cookies['routemuse_session'],
    config.jwtSecret
  )
  Session.createSession(session.id, userSession.gymId, priceId, productId)
  return res.json({ url: session.url })
})
router.post('/webhook', async (req, res) => {
  let data
  var gymId
  var session
  let eventType
  let startdate
  let enddate
  let account
  // Check if webhook signing is configured.
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET
  if (webhookSecret) {
    // Retrieve the event by verifying the signature using the raw body and secret.
    let event
    let signature = req.headers['stripe-signature']

    try {
      event = stripe.webhooks.constructEvent(req.body, signature, webhookSecret)
    } catch (err) {
      console.log(`⚠️  Webhook signature verification failed.`)
      return res.sendStatus(400)
    }
    // Extract the object from the event.
    data = event.data
    eventType = event.type
  } else {
    // Webhook signing is recommended, but if the secret is not configured in `config.js`,
    // retrieve the event data directly from the request body.
    data = req.body.data
    eventType = req.body.type
  }
  switch (data.object.object) {
    case 'subscription':
      account = await Account.findAccountByCustomer(data.object.customer)
      gymId = account.gymId
      break
    case 'invoice':
      account = await Account.findAccountByCustomer(data.object.customer)
      gymId = account.gymId
      break
    case 'checkout.session':
      session = await Session.findSessionById(data.object.id)
      gymId = session.gymId
      break
    default:
      break
  }
  switch (eventType) {
    case 'checkout.session.completed':
      // Payment is successful and the subscription is created.
      // You should provision the subscription and save the customer ID to your database.
      await Account.updateSubscriptionStatus(gymId, 'active')
      await Account.updateSubscription(gymId, data.object.subscription)
      await Account.updateCustomer(gymId, data.object.customer)
      await Account.updatePrice(gymId, session.priceId)
      await Account.updateProduct(gymId, session.productId)
      break
    case 'invoice.paid':
      // Continue to provision the subscription as payments continue to be made.
      // Store the status in your database and check when a user accesses your service.
      // This approach helps you avoid hitting rate limits.
      await Account.updateInvoice(gymId, 'paid')
      break
    case 'invoice.payment_failed':
      // The payment failed or the customer does not have a valid payment method.
      // The subscription becomes past_due. Notify your customer and send them to the
      // customer portal to update their payment information.
      await Account.updateInvoice(gymId, 'payment_failed')
      break
    case 'customer.subscription.created':
      startdate = data.object.current_period_start
      enddate = data.object.current_period_end
      await Account.updateBillingPeriod(gymId, startdate, enddate)
      await Account.updateSubscription(gymId, data.object.id)
      break
    case 'customer.subscription.updated':
      // update billing dates
      startdate = data.object.current_period_start
      enddate = data.object.current_period_end
      let status = data.object.cancel_at_period_end ? 'canceled' : 'active'
      await Account.updateSubscriptionStatus(gymId, status)
      await Account.updateSubscription(gymId, data.object.id)
      await Account.updateCustomer(gymId, data.object.customer)
      await Account.updatePrice(gymId, account.priceId)
      await Account.updateProduct(gymId, account.productId)
      await Account.updateBillingPeriod(gymId, startdate, enddate)
      break
    case 'customer.subscription.deleted':
      await Account.updateSubscriptionStatus(gymId, 'canceled')
      break
    case 'customer.subscription.trial_will_end':
      break
    // trail period is coming to an end, notify customer and verify billing information.
    case 'customer.subscription.canceled':
      await Account.updateSubscriptionStatus(gymId, 'canceled')
      break
    // trail period is coming to an end, notify customer and verify billing information.
    case 'customer.subscription.past_due':
      await Account.updateSubscriptionStatus(gymId, 'past_due')
      break
    // trail period is coming to an end, notify customer and verify billing information.
    case 'customer.subscription.unpaid':
      await Account.updateSubscriptionStatus(gymId, 'unpaid')
      break
    // revoke access
    default:
      // Unhandled event type
      console.log(`Unhandled event ${eventType}`)
  }

  res.sendStatus(200)
})

module.exports = router
const router = require('express').Router()
const Setter = require('../models/setter')
const Gym = require('../models/gym')
const config = require('../config')
const jwt = require('jsonwebtoken')
const UserSession = require('../libs/UserSession')

router.get('/:token', async (req, res) => {
  let decoded
  try {
    decoded = jwt.verify(req.params.token, config.jwtSecret)
    if (!decoded.userId) {
      throw new Error('Invalid jwt token')
    }
  } catch (e) {
    return res.status(400).json({ error: e.message })
  }

  const setter = await Setter.findById(decoded.userId)
  if (!setter) {
    return res.status(400).json({ error: "Can't find this user." })
  }

  // handle invite token
  if (decoded.gymId) {
    const gym = await Gym.findById(decoded.gymId)
    const userSession = new UserSession(res, setter, gym)
    userSession.activate(false)
    if (!gym) {
      return res.status(400).json({ error: "Can't find this gym." })
    }
    if (!setter.email) {
      return res.redirect('/signup')
    } else {
      if (
        setter.gyms[gym._id] === 'Owner' ||
        setter.gyms[gym._id] === 'Head Setter' ||
        setter.superUser
      ) {
        return res.redirect('/')
      }
      return res.redirect(`/setters-home?setter=${setter._id}`)
    }
  }
  setter.useRememberMe = decoded.rememberMe
  await setter.save()
  if (setter.gyms) {
    const gymIds = Object.keys(setter.gyms)
    if (gymIds.length > 1) {
      const gyms = await Gym.find({
        _id: { $in: gymIds },
      })
      // handle users with more that one gym or no gym
      if (gyms.length > 1) {
        const userSession = new UserSession(res, setter)
        userSession.activate(decoded.rememberMe)
        return res.redirect('/')
      }
      // handle users with single gym
      const gym = await Gym.findById(gymIds[0])
      const userSession = new UserSession(res, setter, gym)
      userSession.activate(decoded.rememberMe)
    }
  }
  const userSession = new UserSession(res, setter)
  userSession.activate(decoded.rememberMe)
  return res.redirect('/')
})

module.exports = router
const express = require('express');
const router = express.Router();
const Goal = require('../controllers/goal');

const goalController = new Goal();

router.post('/create', goalController.create);

router.get('/:id', goalController.details);

router.get('/', goalController.all);

router.put('/:id', goalController.update);

router.delete('/:id', goalController.delete);

module.exports = router;
const express = require('express')
const router = express.Router()
const Account = require('../controllers/account')

const accountController = new Account()

router.post('/create', accountController.create)

// router.get('/gymId', accountController.byGym)

router.get('/:id', accountController.details)

router.get('/', accountController.all)

// router.put('/:id', accountController.update)

// router.delete('/:id', accountController.delete)

module.exports = router
const express = require('express');
const router = express.Router();
const Grade = require('../controllers/grade');

const gradeController = new Grade();

router.get('/:name', gradeController.details);

router.get('/', gradeController.all);

module.exports = router;
const router = require('express').Router()
const Setter = require('../models/setter')
const NotAUser = require('../models/notAUser')
const jwt = require('jsonwebtoken')
const config = require('../config')
var AWS = require('aws-sdk')

if (config.mode === 'production') {
  AWS.config.credentials = new AWS.ECSCredentials({
    httpOptions: { timeout: 5000 },
    maxRetries: 10,
    retryDelayOptions: { base: 200 },
  })
} else {
  const localCredentials = new AWS.Credentials(
    process.env.AWS_KEY,
    process.env.AWS_SECRET
  )
  AWS.config.credentials = localCredentials
}
AWS.config.update({ region: config.awsRegion })

const setCode = async () => {
  const code = Math.floor(100000 + Math.random() * 900000)
  const codeExists = await NotAUser.find({ code })
  if (codeExists.length === 0) {
    return code
  }
  setCode()
}

router.get('/email', async ({ query }, res) => {
  const setter = await Setter.findOne({
    email: { $regex: query.email, $options: 'i' },
  })
  if (setter) {
    return res.json({ found: true })
  }
  return res.json({ found: false })
})

router.post('/', async ({ body }, res) => {
  const { email, firstName, lastName, exists, rememberMe } = body
  let host
  if (config.mode === 'production') {
    host = `${config.defaultProtocol}://${config.domainName}`
  } else {
    host = `${config.defaultProtocol}://${config.domainName}:${config.port}`
  }
  let params = {}
  if (exists) {
    const setter = await Setter.findOne({
      email: { $regex: email, $options: 'i' },
    })
    if (!setter) {
      return res.status(400).json({ error: "Can't find the user." })
    }
    const token = jwt.sign(
      { userId: setter._id, rememberMe },
      config.jwtSecret,
      {
        expiresIn: '12h',
      }
    )
    params = {
      Destination: {
        ToAddresses: [`${setter.email}`],
      },
      Message: {
        Body: {
          Html: {
            Charset: 'UTF8',
            Data: `
                  <p>Hi ${setter.firstName} ${setter.lastName},</p>
                  <p>
                    Please click this <a href="${host}/token/${token}">link</a> to login to Routemuse.
                  </p>
                  <p>
                    Climb on!
                  </p>`,
          },
          Text: {
            Charset: 'UTF8',
            Data: 'TEXT_FORMAT_BODY',
          },
        },
        Subject: {
          Charset: 'UTF8',
          Data: 'Routemuse Login Link',
        },
      },
      Source: 'RouteMuse App<noreply@routemuse.com>',
    }
  } else {
    const code = await setCode()
    await NotAUser.deleteMany({ email })
    const notAUser = new NotAUser({
      firstName,
      lastName,
      email: email,
      code: code.toString(),
      created: new Date(),
    })
    await notAUser.save()
    params = {
      Destination: {
        ToAddresses: [`${email}`],
      },
      Message: {
        Body: {
          Html: {
            Charset: 'UTF8',
            Data: `
                  <p>Confirm Your Email Address</p>
                  <p>
                  Thank you for signing up for RouteMuse. We’re happy you’re here!
                  </p>
                  <p>
                  Enter the following code in the window where you began creating your new RouteMuse account:.
                  </p>
                  <h1>${code}</h1>
                  <p>
                  This email contains private information for your RouteMuse account — please don’t forward it.<br>Questions about setting up RouteMuse? Email us at feedback@routemuse.com.
                  </p>`,
          },
          Text: {
            Charset: 'UTF8',
            Data: 'TEXT_FORMAT_BODY',
          },
        },
        Subject: {
          Charset: 'UTF8',
          Data: `RouteMuse Confirmation Code: ${code}`,
        },
      },
      Source: 'RouteMuse App<noreply@routemuse.com>',
    }
  }
  var sendPromise = new AWS.SES({ apiVersion: '2010-12-01' })
    .sendEmail(params)
    .promise()

  // Handle promise's fulfilled/rejected states
  sendPromise
    .then(function() {
      return res.status(200).json({ message: 'Sent the login link.' })
    })
    .catch(function(err) {
      console.error(err, err.stack)
      return res
        .status(503)
        .json({ message: 'Failed to send link, please contact support.' })
    })
})

router.post('/code', async ({ body }, res) => {
  const { code, email } = body
  const notAUser = await NotAUser.find({ code, email })
  if (notAUser.length > 0) {
    return res.json({ confirmed: true })
  }
  return res.json({ confirmed: false })
})

module.exports = router
const express = require('express')
const router = express.Router()
const Setter = require('../controllers/setter')

const setterController = new Setter()

router.post('/create', setterController.create)

router.post('/invite', setterController.invite)

router.get('/:id', setterController.details)

router.get('/', setterController.all)

router.put('/:id', setterController.update)

router.delete('/:id', setterController.delete)

router.delete('/bulk/delete', setterController.deleteMany)

module.exports = router
const express = require('express');
const router = express.Router();
const CustomField = require('../controllers/customField');

const customFieldController = new CustomField();

router.post('/create', customFieldController.create);

router.get('/:name', customFieldController.details);

router.get('/', customFieldController.all);

router.put('/:name', customFieldController.update);

router.delete('/:name', customFieldController.delete);

module.exports = router;const express = require('express')
const router = express.Router()
const Image = require('../controllers/image')
const AWS = require('aws-sdk')
const multer = require('multer')
const multerS3 = require('multer-s3')
const config = require('../config')

const imageController = new Image()

if (config.mode === 'production') {
  AWS.config.credentials = new AWS.ECSCredentials({
    httpOptions: { timeout: 5000 },
    maxRetries: 10,
    retryDelayOptions: { base: 200 },
  })
} else {
  require('dotenv').config()
  const localCredentials = new AWS.Credentials(
    process.env.AWS_KEY,
    process.env.AWS_SECRET
  )
  AWS.config.credentials = localCredentials
}
AWS.config.update({ region: config.awsRegion })

const s3 = new AWS.S3()

const storage = multerS3({
  acl: 'public-read',
  s3,
  bucket: config.awsBucket,
  key: function(req, file, cb) {
    cb(null, `public/images/${Date.now()}-${file.originalname}`)
  },
})

const upload = multer({ storage: storage })

router.post('/upload', upload.single('gallery'), imageController.upload)

router.delete('/:id', imageController.delete)

module.exports = router
const express = require('express')
const router = express.Router()
const GymSetup = require('../controllers/gymSetup')

const gymSetupController = new GymSetup()

router.post('/create', gymSetupController.create)

router.get('/', gymSetupController.all)

router.get('/:id', gymSetupController.details)

router.put('/:id', gymSetupController.update)

router.delete('/:id', gymSetupController.delete)

module.exports = router
const express = require('express')
const router = express.Router()
const Location = require('../controllers/location')

const locationController = new Location()

router.post('/create', locationController.create)

router.post('/bulkInsert', locationController.insertMany)

router.get('/set-dates', locationController.setDates)

router.get('/:id', locationController.details)

router.get('/', locationController.all)

router.put('/:id', locationController.update)

router.delete('/:id', locationController.delete)

module.exports = router
const express = require('express')
const router = express.Router()
const Target = require('../controllers/target')

const targetController = new Target()

router.post('/create', targetController.create)

router.get('/:id', targetController.details)

router.get('/', targetController.all)

router.put('/:id', targetController.update)

router.delete('/:id', targetController.delete)

module.exports = router
const express = require('express');
const router = express.Router();
const Settings = require('../controllers/settings');

const settingsController  = new Settings();

router.post('/create', settingsController.create);

router.get('/', settingsController.get);

router.put('/:id', settingsController.update);

router.delete('/:id', settingsController.delete);

module.exports = router;class LocalStorage {
  constructor(path) {
    this.path = path;
  }
  destination(req, file, cb) {
    cb;
  }
}

module.exports = LocalStorage;module.exports = {
  moduleFileExtensions: ['js', 'json', 'vue'],
  transform: {
    '^.+\\.js$': 'babel-jest',
    '.*\\.(vue)$': 'vue-jest'
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1'
  }
};
module.exports = {
  presets: ['@vue/app', '@babel/preset-env'],
  plugins: [['@babel/transform-runtime']]
};
const TARGET = process.env.npm_lifecycle_event

module.exports = {
  filenameHashing: false,
  chainWebpack: config => {
    if (process.env.NODE_ENV == 'production') {
      config.plugins.delete('html')
      config.plugins.delete('preload')
      config.plugins.delete('prefetch')
    }
  },
  productionSourceMap: true,
  outputDir: TARGET === 'publish' ? '../publish' : '../public',
  publicPath:
    TARGET === 'publish'
      ? 'https://s3-us-west-2.amazonaws.com/routemuse.com/public/'
      : '/',
  devServer: {
    proxy: {
      '^/(api|fonts)': {
        target: 'http://localhost:8080',
      },
    },
  },
}
module.exports = {
  root: true,
  env: {
    node: true
  },
  extends: ['plugin:vue/essential', '@vue/prettier'],
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'off',
    'no-unused-vars': process.env.NODE_ENV === 'production' ? 'warn' : 'off'
  },
  parserOptions: {
    parser: 'babel-eslint'
  }
};
import Vue from 'vue'
const longpress = Vue.directive('longpress', {
  bind: function(el, binding, vNode) {
    // Make sure expression provided is a function
    // if (typeof binding.value !== 'function') {
    //   // Fetch name of component
    //   const compName = vNode.context.name
    //   // pass warning to console
    //   let warn = `[longpress:] provided expression '${binding.expression}' is not a function, but has to be`
    //   if (compName) {
    //     warn += `Found in component '${compName}' `
    //   }

    //   console.warn(warn)
    // }

    // Define variable
    let pressTimer = null
    let duration = 1000

    // Define funtion handlers
    // Create timeout ( run function after 1s )
    let start = e => {
      if (e.type === 'click' && e.button !== 0) {
        return
      }
      if (pressTimer === null) {
        pressTimer = setTimeout(() => {
          // Run function
          handler()
        }, duration)
      }
    }

    // Cancel Timeout
    let cancel = e => {
      // Check if timer has a value or not
      if (pressTimer !== null) {
        clearTimeout(pressTimer)
        pressTimer = null
      }
    }
    // Run Function
    const handler = e => {
      binding.value(e)
    }
    // Add Event listeners
    el.addEventListener('mousedown', start)
    el.addEventListener('touchstart', start)
    // Cancel timeouts if this events happen
    el.addEventListener('click', cancel)
    el.addEventListener('mouseout', cancel)
    el.addEventListener('touchend', cancel)
    el.addEventListener('touchcancel', cancel)
  },
})

export { longpress }
import getOrientedImage from 'exif-orientation-image'

export const imageOrientationMixin = {
  methods: {
    inputFilter(file, prop, callback) {
      const reader = new FileReader()
      getOrientedImage(file, (err, canvas) => {
        if (!err) {
          canvas.toBlob(
            blob => {
              reader.readAsDataURL(blob)
              reader.onload = e => {
                this.previewImage = e.target.result
                this.convertBackToFile(e.target.result, file, prop, callback)
              }
            },
            file.type,
            1
          )
        }
      })
    },
    convertBackToFile(dataUrl, image, prop, callback) {
      fetch(dataUrl)
        .then(res => {
          return res.arrayBuffer()
        })
        .then(buf => {
          let file = new File([buf], image.name, { type: image.type })
          callback({ key: prop, value: file })
        })
    },
  },
}
import { techniqueOrdering, genericMask } from '../store/variables'
import {
  convertDBgoals,
  convertLocalGoals,
} from '../store/modules/D3/goalUtils'

export const mapTechniques = grades => {
  let mask = {}
  // Project elevation distribution onto the grade line
  let ratio = Math.min(grades.length / 9, 2)
  techniqueOrdering.forEach(technique => {
    let techPlace = Math.round(genericMask[technique] * ratio) - 1
    mask[technique] = grades[techPlace]
  })
  return mask
}

const func_setup = numGrades => {
  let a = 6.1
  let c = Math.min(3.5 + numGrades / 8.57, 7)
  let b = Math.min(0.5 * numGrades + 0.5, 5.5)
  return x => {
    return a * Math.exp(-Math.pow(x - b, 2) / Math.pow(2 * c, 2))
  }
}

export const returnDefaultGoals = (grades, numRoutes, gymId) => {
  // Necessary to convert grade values into db format
  var newGrades = []
  const scaling_gaussian = func_setup(grades.length)
  grades.forEach((grade, index) => {
    let value = (numRoutes / scaling_gaussian(index)).toFixed(3)
    newGrades.push({ key: grade, value })
  })
  // convert to local goals
  newGrades.forEach(
    grade => (grade.value = (numRoutes / grade.value).toFixed(3))
  )
  var total = newGrades.reduce((carry, grade) => {
    carry += Number(grade.value)
    return carry
  }, 0)
  let scalingFactor = total / numRoutes
  // scale down
  newGrades.forEach(
    grade => (grade.value = (grade.value / scalingFactor).toFixed(3))
  )
  // convert to dbgoals
  newGrades.forEach(
    grade => (grade.value = (numRoutes / grade.value).toFixed(3))
  )
  let goal = {
    gymId,
    name: 'Default',
    date: new Date(),
    techniques: [
      { key: 'Crossing', value: '10.512' },
      { key: 'Flagging', value: '15.428' },
      { key: 'Bumping', value: '13.407' },
      { key: 'Gaston', value: '14.971' },
      { key: 'Lock off', value: '13.840' },
      { key: 'High Step', value: '14.971' },
      { key: 'Layback', value: '10.324' },
      { key: 'Heel Hooking', value: '10.316' },
      { key: 'Toe Hooking', value: '14.971' },
      { key: 'Campusing', value: '22.851' },
      { key: 'Stemming', value: '12.930' },
      { key: 'Twisting', value: '14.971' },
      { key: 'Mantle', value: '14.971' },
      { key: 'Dyno', value: '22.564' },
    ],
    grade: newGrades,
    length: [
      { key: 'Short', value: '3.687' },
      { key: 'Medium', value: '1.934' },
      { key: 'Long', value: '4.722' },
    ],
    risk: [
      { key: 1, value: '13.242' },
      { key: 2, value: '3.769' },
      { key: 3, value: '2.841' },
      { key: 4, value: '4.314' },
      { key: 5, value: '13.268' },
    ],
    intensity: [
      { key: 1, value: '8.428' },
      { key: 2, value: '4.098' },
      { key: 3, value: '2.701' },
      { key: 4, value: '6.431' },
      { key: 5, value: '8.965' },
    ],
    complexity: [
      { key: 1, value: '19.915' },
      { key: 2, value: '6.537' },
      { key: 3, value: '2.615' },
      { key: 4, value: '3.746' },
      { key: 5, value: '6.778' },
    ],
    heightFriendly: [
      { key: 'Average', value: '1.614' },
      { key: 'Short', value: '4.555' },
      { key: 'Tall', value: '6.211' },
    ],
    holdType: [
      { key: 'Crimp', value: '5.000' },
      { key: 'Pocket', value: '5.000' },
      { key: 'Jug', value: '5.000' },
      { key: 'Pinch', value: '5.000' },
      { key: 'Sloper', value: '5.000' },
    ],
    active: true,
    totalGymRoutes: numRoutes,
    routesPerWeek: 0,
    maximumRouteAge: 90,
  }
  return goal
}
export const capitalizeMixin = {
  filters: {
    capitalize: function(value) {
      if (!value) return ''
      const array = value.split(' ')
      let newArray = []
      for (let i = 0; i < array.length; i++) {
        newArray.push(array[i].charAt(0).toUpperCase() + array[i].substr(1))
      }
      return newArray.join(' ')
    },
  },
}
import dayjs from 'dayjs'

export const dateMixin = {
  filters: {
    date: function(value) {
      {
        if (!value) return null
        return dayjs(value).format('MM/DD/YYYY')
      }
    },
  },
  methods: {
    formatDate(date) {
      if (!date) return null
      return dayjs(date).format('MM/DD/YYYY')
    },
    monthToString(num) {
      let months = {
        0: 'Jan',
        1: 'Feb',
        2: 'Mar',
        3: 'Apr',
        4: 'May',
        5: 'Jun',
        6: 'Jul',
        7: 'Aug',
        8: 'Sep',
        9: 'Oct',
        10: 'Nov',
        11: 'Dec',
      }
      return months[num]
    },
    addMonths(date, months) {
      var d = date.getDate()
      date.setMonth(date.getMonth() + +months)
      if (date.getDate() != d) {
        date.setDate(0)
      }
      return date
    },
  },
}
export const dearrayizeMixin = {
  filters: {
    dearrayize: function(array) {
      if (!array) {
        return ''
      } else {
        const string = array
          .reduce((carry, value) => {
            carry.push(value.charAt(0).toUpperCase() + value.slice(1))
            return carry
          }, [])
          .join(', ')
        return string
      }
    },
  },
  methods: {
    dearrayize: function(array) {
      if (!array) {
        return ''
      } else {
        const string = array
          .reduce((carry, value) => {
            carry.push(value.charAt(0).toUpperCase() + value.slice(1))
            return carry
          }, [])
          .join(', ')
        return string
      }
    },
  },
}
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
import Vuetify from 'vuetify'
import VeeValidate from 'vee-validate'
import VueResize from 'vue-resize'

if (process.env.NODE_ENV !== 'production') {
  require('material-design-icons-iconfont/dist/material-design-icons.css')
}
import 'vue-resize/dist/vue-resize.css'
import 'vuetify/dist/vuetify.min.css'

Vue.use(Vuetify)
Vue.use(VeeValidate)
Vue.use(VueResize)

Vue.config.productionTip = false
Vue.config.devtools = true
var vm = new Vue({
  router,
  store,
  render: h => h(App),
}).$mount('#app')

export { vm }
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router)

const router = new Router({
  mode: 'history',
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) {
      return savedPosition
    }
    if (to.hash) {
      return { selector: to.hash }
    }
    return { x: 0, y: 0 }
  },
  routes: [
    {
      path: '*',
      component: () =>
        import(/* webpackChunkName: "root" */ './views/Root.vue'),
      children: [
        {
          path: '/create-gym',
          name: 'CreateGym',
          meta: { hideNavigation: true },
          component: () =>
            import(
              /* webpackChunkName: "CreateGym" */ './views/login/CreateGym.vue'
            ),
        },
        {
          path: '/login',
          name: 'Login',
          meta: { hideNavigation: true },
          component: () =>
            import(/* webpackChunkName: "login" */ './views/login/Login.vue'),
        },
        {
          path: '/signup',
          name: 'SetterSignUp',
          meta: { hideNavigation: true },
          component: () =>
            import(
              /* webpackChunkName: "setterSignUp" */ './views/login/SetterSignUp.vue'
            ),
        },
        {
          path: '/plan-set',
          name: 'PlanSet',
          component: () =>
            import(/* webpackChunkName: "planSet" */ './views/PlanSet.vue'),
        },
        {
          path: '/add-route',
          name: 'AddRoute',
          // route level code-splitting
          // this generates a separate chunk (about.[hash].js) for this route
          // which is lazy-loaded when the route is visited.
          component: () =>
            import(/* webpackChunkName: "addRoute" */ './views/AddRoute.vue'),
        },
        {
          path: '/drafts',
          name: 'Drafts',
          component: () =>
            import(/* webpackChunkName: "drafts" */ './views/Drafts.vue'),
        },
        {
          path: '/all-routes',
          name: 'AllRoutes',
          component: () =>
            import(/* webpackChunkName: "allRoutes" */ './views/AllRoutes.vue'),
        },
        {
          path: '/locations',
          name: 'Locations',
          component: () =>
            import(/* webpackChunkName: "locations" */ './views/Locations.vue'),
        },
        {
          path: '/setters',
          name: 'Setters',
          props: route => ({ setterEmail: route.query.setterEmail }),
          component: () =>
            import(/* webpackChunkName: "setters" */ './views/Setters.vue'),
        },
        {
          path: '/goals',
          name: 'Goals',
          component: () =>
            import(/* webpackChunkName: "goals" */ './views/Goals.vue'),
        },
        {
          path: '/settings',
          name: 'Settings',
          component: () =>
            import(/* webpackChunkName: "settings" */ './views/Settings.vue'),
        },
        {
          path: '/billing',
          name: 'Billing',
          component: () =>
            import(/* webpackChunkName: "billing" */ './views/Billing.vue'),
        },
        {
          path: '/setters-home',
          name: 'SettersHome',
          meta: { hideNavigation: true },
          component: () =>
            import(
              /* webpackChunkName: "settersHome" */ './views/SettersHome.vue'
            ),
        },
        {
          path: '/data-analysis',
          name: 'DataAnalysis',
          component: () =>
            import(
              /* webpackChunkName: "dataAnalysis" */ './views/DataAnalysis.vue'
            ),
        },
        {
          path: '/dashboard',
          name: 'Home',
          component: () =>
            import(/* webpackChunkName: "home" */ './views/Home.vue'),
        },
        {
          path: '/subscription-success',
          name: 'SubscriptionSuccess',
          component: () =>
            import(
              /* webpackChunkName: "subscriptionSuccess" */ './views/SubscriptionSuccess.vue'
            ),
        },
        {
          path: '/subscription-canceled',
          name: 'SubscriptionCanceled',
          component: () =>
            import(
              /* webpackChunkName: "subscriptionCanceled" */ './views/SubscriptionCanceled.vue'
            ),
        },
        {
          path: '/',
          name: 'Landing',
          meta: { hideNavigation: true },
          component: () =>
            import(/* webpackChunkName: "landing" */ './views/Landing.vue'),
        },
      ],
    },
  ],
})

export default router
export default {
  getMessage() {
    return 'This is a duplicate of an existing goal name'
  },
  validate(newName, { oldName, allNames }) {
    if (newName !== oldName) {
      if (allNames.includes(newName.toLowerCase())) {
        return false
      }
      return true
    }
    return true
  },
}
import { mount, createLocalVue } from '@vue/test-utils'
import flushPromises from 'flush-promises'
import Vue from 'vue'
import Vuex from 'vuex'
import Vuetify from 'vuetify'
import VeeValidate from 'vee-validate'
import LoginView from '@/views/login/Login.vue'

const localVue = createLocalVue()

Vue.use(Vuetify)
localVue.use(Vuex)
localVue.use(VeeValidate)

describe('Login Test', () => {
  let store, state, actions
  beforeEach(async () => {
    state = {
      isEmailSent: false,
      sending: false,
      error: '',
    }
    actions = {
      sendLink: jest.fn(),
      resetError: jest.fn(),
    }
    store = new Vuex.Store({
      modules: {
        login: {
          state,
          actions,
          namespaced: true,
        },
      },
    })
  })
  it('renders the login page and ui components', () => {
    const wrapper = mount(LoginView, { store, localVue })
    let textInput = wrapper.find("input[name='email']")
    let button = wrapper.find('button')
    expect(wrapper.exists()).toBe(true)
    expect(wrapper.find('.company-headline').exists()).toBe(true)
    expect(wrapper.find('.company-headline').text()).toEqual('ROUTEMUSE')
    expect(textInput.exists()).toBe(true)
    expect(button.exists()).toBe(true)
  })
  it('triggers error when user inputs empty value and submits', async () => {
    const wrapper = mount(LoginView, { store, localVue })
    let emailField = wrapper.find('.v-text-field')
    let textInput = wrapper.find("input[name='email']")
    let submit = wrapper.find('button')
    textInput.setValue('')
    submit.trigger('click')
    await flushPromises()
    expect(emailField.classes().includes('error--text')).toBe(true)
  })
  it('triggers error when user inputs non-email', async () => {
    const wrapper = mount(LoginView, { store, localVue })
    let emailField = wrapper.find('.v-text-field')
    let textInput = wrapper.find("input[name='email']")
    textInput.setValue('test@')
    await flushPromises()
    expect(emailField.classes().includes('error--text')).toBe(true)
  })
  it('does not trigger error when entered text is email', async () => {
    const wrapper = mount(LoginView, { store, localVue })
    let emailField = wrapper.find('.v-text-field')
    let textInput = wrapper.find("input[name='email']")
    let submit = wrapper.find('button')
    textInput.setValue('test@gmail.com')
    submit.trigger('click')
    await flushPromises()
    expect(emailField.classes().includes('error--text')).toBe(false)
  })
  it('forgets me', () => {
    const wrapper = mount(LoginView, { store, localVue })
    let checkbox = wrapper.find("input[type='checkbox']")
    checkbox.trigger('click')
    expect(checkbox.element.checked).toBeFalsy()
  })
})
const emptyGym = {
  name: null,
  address: null,
  city: null,
  state: null,
  ZIPCode: null,
  country: 'US',
  website: null,
  key: null,
  logo: null,
}

const emptyAccount = {
  gymId: null,
  customerId: null,
  trial_start: null,
  trial_end: null,
  invoice: null,
  payment_intent: null,
  subscription: null,
  subscription_status: null,
  productId: null,
  priceId: null,
  billing_period_start: null,
  billing_period_end: null,
}

const emptyTarget = {
  gymId: null,
  routeId: null,
  setterId: null,
  targets: {},
}

const emptySetter = {
  firstName: null,
  lastName: null,
  email: null,
  role: null,
  active: true,
  avatar: null,
  superUser: false,
  gyms: {},
}

const emptyLocation = {
  image: null,
  name: null,
  routeLimit: null,
  discipline: 'Bouldering',
  terrainType: [],
  setDate: null,
}

const emptyRoute = {
  gymId: null,
  image: null,
  discipline: 'Bouldering',
  location: null,
  length: null,
  grade: null,
  setter: null,
  startLocation: null,
  finishLocation: null,
  techniques: [],
  heightFriendly: null,
  intraDifficulty: null,
  risk: null,
  intensity: null,
  complexity: null,
  setScrewed: false,
  stripped: false,
  date: new Date().toISOString(),
  notes: null,
  emotion: null,
  holdType: null,
  time: {
    skeleton: 0,
    'setter forerun': 0,
    'group forerun': 0,
    finished: 0,
    stage: 'skeleton',
  },
}

const emptySettings = {
  boulderingEnabled: true,
  boulderingSystem: 'Vermin',
  ropedClimbingEnabled: false,
  ropedClimbingSystem: null,
  defaultBoulderingGrades: [],
  defaultRopedClimbingGrades: [],
  distMethod: 'Time & Grade',
  noveltyType: 'Active',
  noveltyField: 'Grade',
  noveltyWeights: [0, 0, 0, 0, 0, 0],
  gradeMask: {},
  terrainMask: {
    Slab: [],
    Vertical: [],
    Overhung: [],
    Roof: [],
  },
  displayedHeaders: ['Date', 'Setter', 'Grade', 'Location', 'Stripped'],
  displayedDraftHeaders: ['Date', 'Setter', 'Grade', 'Location', 'Notes'],
}

const emptyGymSetup = {
  setterId: null,
  currentStep: 0,
  gym: null,
  settings: null,
  grades: null,
  locations: null,
  invitedSetters: null,
}

const terrainMask = {
  Slab: [
    'Crossing',
    'Flagging',
    'Bumping',
    'Gaston',
    'High Step',
    'Heel Hooking',
    'Toe Hooking',
    'Mantle',
    'Dyno',
    'Twisting',
    'Stemming',
    'Lock off',
    'Layback',
  ],
  Vertical: [
    'Crossing',
    'Flagging',
    'Bumping',
    'Gaston',
    'Lock off',
    'High Step',
    'Layback',
    'Heel Hooking',
    'Toe Hooking',
    'Stemming',
    'Twisting',
    'Mantle',
    'Dyno',
  ],
  Overhung: [
    'Crossing',
    'Flagging',
    'Bumping',
    'Gaston',
    'Lock off',
    'High Step',
    'Layback',
    'Heel Hooking',
    'Toe Hooking',
    'Campusing',
    'Twisting',
    'Dyno',
  ],
  Roof: [
    'Crossing',
    'Flagging',
    'Bumping',
    'Lock off',
    'High Step',
    'Layback',
    'Heel Hooking',
    'Toe Hooking',
    'Campusing',
    'Twisting',
    'Dyno',
  ],
}

const techniqueOrdering = [
  'Bumping',
  'Flagging',
  'Crossing',
  'Stemming',
  'Layback',
  'Heel Hooking',
  'Campusing',
  'Gaston',
  'Dyno',
  'High Step',
  'Twisting',
  'Toe Hooking',
  'Lock off',
  'Mantle',
]

const goalTemplate = {
  gymId: null,
  date: new Date(),
  active: true,
  totalGymRoutes: 0,
  routesPerWeek: 0,
  maximumRouteAge: 0,
  techniques: [],
  grade: [],
  length: [],
  risk: [],
  intensity: [],
  complexity: [],
  heightFriendly: [],
  holdType: [],
}

const globalStringFields = [
  'grade',
  'techniques',
  'risk',
  'intensity',
  'complexity',
  'heightFriendly',
  'length',
  'holdType',
]

const globalDefaultFields = {
  techniques: [],
  grade: [],
  length: [],
  risk: [],
  intensity: [],
  complexity: [],
  heightFriendly: [],
  holdType: [],
}
const globalNullFields = {
  techniques: null,
  grade: null,
  length: null,
  risk: null,
  intensity: null,
  complexity: null,
  heightFriendly: null,
  holdType: null,
}

const USStates = [
  'Alaska',
  'Alabama',
  'Arkansas',
  'American Samoa',
  'Arizona',
  'California',
  'Colorado',
  'Connecticut',
  'District of Columbia',
  'Delaware',
  'Florida',
  'Georgia',
  'Guam',
  'Hawaii',
  'Iowa',
  'Idaho',
  'Illinois',
  'Indiana',
  'Kansas',
  'Kentucky',
  'Louisiana',
  'Massachusetts',
  'Maryland',
  'Maine',
  'Michigan',
  'Minnesota',
  'Missouri',
  'Mississippi',
  'Montana',
  'North Carolina',
  ' North Dakota',
  'Nebraska',
  'New Hampshire',
  'New Jersey',
  'New Mexico',
  'Nevada',
  'New York',
  'Ohio',
  'Oklahoma',
  'Oregon',
  'Pennsylvania',
  'Puerto Rico',
  'Rhode Island',
  'South Carolina',
  'South Dakota',
  'Tennessee',
  'Texas',
  'Utah',
  'Virginia',
  'Virgin Islands',
  'Vermont',
  'Washington',
  'Wisconsin',
  'West Virginia',
  'Wyoming',
]

const placeHolderImage =
  'https://s3-us-west-2.amazonaws.com/routemuse.com/public/images/placeholder-location.jpg'

const companyLogo =
  'https://s3-us-west-2.amazonaws.com/www.routemuse.com/images/logo_heavy.png'

const terrainTypes = ['slab', 'vertical', 'overhung', 'roof']

const weightFields = [
  'Length',
  'Techniques',
  'Height Friendly',
  'Risk',
  'Intensity',
  'Complexity',
]

const roles = ['Head Setter', 'Setter', 'Guest Setter']

const genericMask = {
  Flagging: 2,
  Bumping: 2,
  Crossing: 3,
  Layback: 3,
  'Heel Hooking': 3,
  Stemming: 3,
  Gaston: 4,
  Campusing: 4,
  Dyno: 4,
  Twisting: 5,
  'Lock off': 5,
  'High Step': 5,
  'Toe Hooking': 5,
  Mantle: 6,
}

export {
  emptyGym,
  emptyGymSetup,
  emptyAccount,
  emptyTarget,
  emptyLocation,
  emptySetter,
  emptyRoute,
  emptySettings,
  goalTemplate,
  globalStringFields,
  globalDefaultFields,
  globalNullFields,
  USStates,
  placeHolderImage,
  companyLogo,
  terrainTypes,
  techniqueOrdering,
  genericMask,
  terrainMask,
  weightFields,
  roles,
}
const Literal = {
  CUSTOM: 'Custom',
  STRING: 'string',
  NAME: 'name',
  EMPTY_DB: 'emptyDb',
  DB_GOALS: 'dbgoals',
  ACTIVE: 'active',
  ID: '_id',
  IMAGE: 'image',
  ROUTES_PER_WEEK: 'routesPerWeek',
  TOTAL_GYM_ROUTES: 'totalGymRoutes',
  MAXIMUM_ROUTE_AGE: 'maximumRouteAge',
  DATE: 'date',
}

const Roles = {
  HEAD_SETTER: 'Head Setter',
  GUEST_SETTER: 'Guest Setter',
  SETTER: 'Setter',
  OWNER: 'Owner',
}

const SubscriptionStatus = {
  ACTIVE: 'active',
  TRIALING: 'trialing',
  PAST_DUE: 'past_due',
  CANCELED: 'canceled',
  UNPAID: 'unpaid',
}

export { Literal, Roles, SubscriptionStatus }
import Vue from 'vue'
import Vuex from 'vuex'
import addRoute from './modules/addRoute'
import drafts from './modules/drafts'
import allRoutes from './modules/allRoutes'
import setters from './modules/setters'
import fields from './modules/fields'
import dashboard from './modules/dashboard'
import dataAnalysis from './modules/dataAnalysis'
import goals from './modules/goals'
import settings from './modules/settings'
import customScale from './modules/customScale'
import grades from './modules/grades'
import targets from './modules/targets'
import messages from './modules/messages'
import locations from './modules/locations'
import planSet from './modules/planSet'
import setterData from './modules/setterData'
import login from './modules/login'
import mainToolbar from './modules/mainToolbar'
import createGym from './modules/createGym'
import gyms from './modules/gyms'
import users from './modules/users'
import setterSignUp from './modules/setterSignUp'
import billing from './modules/billing'

Vue.use(Vuex)

export default new Vuex.Store({
  modules: {
    addRoute,
    drafts,
    allRoutes,
    setters,
    fields,
    dashboard,
    dataAnalysis,
    goals,
    settings,
    customScale,
    grades,
    targets,
    messages,
    locations,
    planSet,
    setterData,
    login,
    mainToolbar,
    createGym,
    gyms,
    users,
    setterSignUp,
    billing,
  },
  strict: true,
})
import axios from 'axios'

axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest'

axios.interceptors.response.use(
  response => {
    if (response.data.needGym) {
      window.location = '/'
    }
    if (response.data.needSetup) {
      window.location = '/create-gym'
    }
    return response
  },
  error => {
    if (
      window.location.pathname !== '/login' &&
      window.location.pathname !== '/create-gym' &&
      error.response.status === 401
    ) {
      window.location = error.response.data.path
    } else if (error.response.status === 402) {
      // payment required
      window.location = error.response.data.path
    }
    return Promise.reject(error)
  }
)

export default axios
import axios from '../api'

const emptyPlan = {
  name: 'Untitled Plan',
  discipline: 'Bouldering',
  locations: [],
  routes: [],
  setters: [],
  suggestions: [],
  reassignments: 0,
  distributed: false,
  complete: false,
  date: new Date(),
}

const emptyPlans = [
  {
    name: 'New Plan',
  },
]

const state = {
  plan: {
    ...emptyPlan,
  },
  activePlans: [...emptyPlans],
  completePlans: [],
  locations: [],
  routes: [],
  setters: [],
  lastSetData: {},
  currentSuggestion: {},
  review: [],
  readyToComplete: false,
  uploading: false,
}

const autoStripOldRoutes = async id => {
  const { data: plan } = await axios.get(`/api/plans/${id}`)
  const locations = plan.locations.map(location => location.name)
  const { data: routesToBeStripped } = await axios(
    `/api/routes?location(s)=${locations}&planId!=${id}&stripped=false`
  )
  const ids = routesToBeStripped.map(route => route._id)
  const obj = { ids, fields: { stripped: true } }
  return await axios.put('/api/routes/bulk/edit', obj)
}

const actions = {
  async getAll({ commit, dispatch }) {
    await dispatch('setters/getAllSetters', {}, { root: true })
    await dispatch('getPlans')
    const { data: locations } = await axios.get('/api/locations/set-dates')
    const { data: routes } = await axios.get('/api/routes?stripped=false')
    const { data: setters } = await axios.get('/api/setters?active=true')
    commit('setLocations', locations)
    commit('setRoutes', routes)
    commit('setSetters', setters)
  },
  async getPlan({ commit, dispatch }, id) {
    try {
      if (id) {
        const { data: plan } = await axios.get(`/api/plans/${id}`)
        commit('setPlan', plan)
        if (plan.distributed) {
          dispatch('getReview')
        }
        dispatch('getLastSetData')
      } else {
        const plan = { ...emptyPlan }
        commit('setPlan', plan)
      }
    } catch (e) {
      return e.message
    }
  },
  async getPlans({ commit }) {
    const { data: plans } = await axios.get('/api/plans')
    const activePlans = plans.filter(plan => !plan.complete)
    const completePlans = plans.filter(plan => plan.complete)
    commit('setActivePlans', activePlans)
    commit('setCompletePlans', completePlans)
  },
  async getLastSetData({ commit }) {
    const { routes } = state
    const { setters, locations } = state.plan
    const data = setters.reduce((carry, setter) => {
      carry[setter._id] = locations.reduce((carry, location) => {
        carry[location.name] = routes
          .filter(
            route =>
              route.location === location.name && route.setter === setter.email
          )
          .map(route => route.grade)
        return carry
      }, {})
      return carry
    }, {})
    commit('setLastSetData', data)
  },
  async refreshLocationData({ commit, dispatch }) {
    const {
      plan: { locations },
    } = state
    let locationNames = locations
      .map(location => {
        return location.name
      })
      .join(',')
    const { data: refreshedLocations } = await axios.get(
      `/api/locations?names=${locationNames}`
    )
    commit('updatePlanProp', { key: 'locations', value: refreshedLocations })
    await dispatch('updatePlan')
  },
  async getReview({ commit, dispatch }) {
    const { plan } = state
    const { data: drafts } = await axios.get(
      `/api/routes/drafts?planId=${plan._id}`
    )
    const { data: routes } = await axios.get(`/api/routes?planId=${plan._id}`)
    const review = drafts.concat(routes)
    commit('setReview', review)
    if (drafts.length === 0) {
      dispatch('setReadyToComplete', true)
    }
  },
  setReadyToComplete({ commit }, bool) {
    commit('setReadyToComplete', bool)
  },
  updatePlan({ commit, dispatch }) {
    const { plan } = state
    if (plan._id) {
      axios
        .put(`/api/plans/${plan._id}`, plan)
        .then(() => {
          dispatch('messages/setMessage', 'Plan Updated', { root: true })
        })
        .catch(error => {
          return error.message
        })
    } else {
      axios
        .post('/api/plans/create', plan)
        .then(({ data: { plan, message } }) => {
          commit('updatePlanProp', { key: '_id', value: plan._id })
          dispatch('messages/setMessage', message, { root: true })
        })
        .catch(error => {
          return error.message
        })
    }
  },
  updatePlanProp({ commit }, payload) {
    commit('updatePlanProp', payload)
  },
  async addSuggestions({ dispatch }) {
    await axios
      .post(`/api/plans/suggestion?id=${state.plan._id}`)
      .then(async () => {
        dispatch('getPlan', state.plan._id)
      })
      .catch(error => {
        return error.message
      })
  },
  updateSuggestions({ commit }, payload) {
    commit('updateSuggestions', payload)
  },
  deleteSuggestions({ commit }, indexes) {
    commit('deleteSuggestions', indexes)
  },
  async createDrafts({ commit, dispatch }) {
    const { plan, review } = state
    if (review.length > 0) {
      await dispatch('deleteDrafts', plan._id)
    }
    await axios
      .post('/api/routes/drafts/bulk/create', plan.suggestions)
      .then(({ data: drafts }) => {
        commit('setReview', drafts)
      })
      .catch(error => {
        return error.message
      })
  },
  async getCurrentSuggestion({ commit }, suggestion) {
    if (suggestion.time.stage === 'finished') {
      let routes = await axios.get(`/api/routes/${suggestion._id}`)
      return commit('getCurrentSuggestion', routes.data)
    } else {
      let drafts = await axios.get(`/api/routes/draft/${suggestion._id}`)
      return commit('getCurrentSuggestion', drafts.data)
    }
  },
  async deletePlan({ dispatch }, id) {
    await axios.delete(`/api/plans/${id}`).catch(error => {
      return error.message
    })
    await dispatch('deleteDrafts', id)
    dispatch('getPlans')
  },
  async deleteDrafts(_, planId) {
    await axios
      .delete('/api/routes/drafts/bulk/delete', { data: { planId } })
      .catch(error => {
        return error.message
      })
  },
  async updateLocationImage({ commit, dispatch }, obj) {
    const { data: location } = await axios.get(`/api/locations/${obj.id}`)
    const formData = new FormData()
    formData.append('gallery', obj.value)
    const { data } = await axios.post('/api/images/upload', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    })
    location.image = data
    await axios.put(`/api/locations/${location._id}`, location)
    const { data: locations } = await axios.get('/api/locations/set-dates')
    commit('setLocations', locations)
    await dispatch('refreshLocationData')
    await dispatch('toggleUploading')
  },
  async checkPlanCompletion(_, id) {
    try {
      const { data: drafts } = await axios.get(
        `/api/routes/drafts?planId=${id}`
      )
      if (drafts.length === 0) {
        await autoStripOldRoutes(id)
        // await axios.put(`/api/plans/${id}`, { complete: true })
      }
    } catch (e) {
      return e.message
    }
  },
  async forceRouteCreation({ dispatch }) {
    const { review } = state
    const body = review.reduce((carry, suggestion) => {
      if (!suggestion.setScrewed) {
        let route = { ...suggestion }
        delete route.time
        carry.push(route)
      }
      return carry
    }, [])
    await axios.post('/api/routes/bulk/create', body)
    await autoStripOldRoutes(state.plan._id)
    await dispatch('deleteDrafts', state.plan._id)
    await dispatch('updatePlanProp', { key: 'complete', value: true })
    await dispatch('updatePlan')
    await dispatch('getPlan', state.plan._id)
  },
  toggleUploading({ commit }) {
    commit('toggleUploading')
  },
}

const mutations = {
  setPlan(state, plan) {
    state.plan = plan
  },
  setActivePlans(state, plans) {
    if (plans.length > 0) {
      plans.unshift(state.activePlans[0])
      state.activePlans = plans
    } else {
      state.activePlans = [...emptyPlans]
    }
  },
  setCompletePlans(state, plans) {
    state.completePlans = plans.reduce((carry, plan) => {
      let imageTaken = false
      plan.locations = plan.locations.map(location => {
        if (location.image && location.image.date > plan.date) {
          imageTaken = true
        }
        return location.name
      })
      plan.imageTaken = imageTaken
      plan.setters = plan.setters.map(setter => setter.email)
      carry.push(plan)
      return carry
    }, [])
  },
  setLastSetData(state, data) {
    state.lastSetData = data
  },
  setLocations(state, locations) {
    state.locations = locations
  },
  orderLocations(state, locations) {
    state.orderedLocations = locations
  },
  setRoutes(state, routes) {
    state.routes = routes
  },
  setSetters(state, setters) {
    state.setters = setters
  },
  updatePlanProp(state, { key, value }) {
    state.plan[key] = value
  },
  updateSuggestions(state, { indexes, setter }) {
    indexes.sort((a, b) => {
      return b - a
    })
    for (let i = 0; i < indexes.length; i++) {
      let newIndex = state.plan.suggestions.length - i - 1
      state.plan.suggestions[indexes[i]].setter = setter
      state.plan.suggestions.splice(
        newIndex,
        0,
        state.plan.suggestions.splice(indexes[i], 1)[0]
      )
    }
  },
  deleteSuggestions(state, indexes) {
    indexes.sort((a, b) => {
      return b - a
    })
    for (let i = 0; i < indexes.length; i++) {
      state.plan.suggestions.splice(indexes[i], 1)
    }
  },
  setReview(state, routes) {
    state.review = routes
  },
  setReadyToComplete(state, bool) {
    state.readyToComplete = bool
  },
  getCurrentSuggestion(state, suggestion) {
    state.currentSuggestion = suggestion
  },
  toggleUploading(state) {
    state.uploading = !state.uploading
  },
}

export default {
  namespaced: true,
  state,
  actions,
  mutations,
}
import axios from '../api'

const state = {
  currentUser: {},
}

const getters = {}

const actions = {
  async getCurrentUser({ commit }) {
    try {
      const {
        data: { currentUser },
      } = await axios.get('/api/currentUser')
      commit('setCurrentUser', currentUser)
    } catch (e) {
      return e.message
    }
  },
}

const mutations = {
  setCurrentUser(state, user) {
    state.currentUser = user
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import { convertLocalGoals, convertDBgoals, deepcopy } from './D3/goalUtils'
import { goalTemplate } from '../variables'
import { Literal } from '../tokens'
import { globalStringFields, globalNullFields } from '../variables'

const newGoals = {
  name: '',
  ...deepcopy(goalTemplate),
}

const state = {
  allGoals: [],
  activeRoutes: [],
  totalActiveRoutes: 0,
  totalDesiredRoutes: 0,
  defaultFields: { ...deepcopy(globalNullFields) },
  goals: { name: '', ...deepcopy(goalTemplate), _id: null },
  dbgoals: { name: '', ...deepcopy(goalTemplate), _id: null },
  emptyDb: { name: '', ...deepcopy(goalTemplate) },
}

const actions = {
  async createGoal({ commit, dispatch }, goalData) {
    try {
      const {
        data: { goal, message },
      } = await axios.post('/api/goals/create', goalData)
      commit('copyDBtoLocal', { goal })
      dispatch('messages/setMessage', message, { root: true })
    } catch (e) {
      return e.message
    }
  },
  async getGoal({ commit, dispatch }, id) {
    const { data: dbdata } = await axios.get('/api/goals/' + id)
    commit('initializeGoals', dbdata.goal)
    dispatch('saveDBGoals')
    dispatch('messages/setMessage', 'Goal Loaded', { root: true })
  },
  async generateNewGoals({ commit }) {
    commit('instantiateEmptyGoals')
    commit('initializeGoals', state.emptyDb)
  },
  storeOldGoals({ commit, dispatch }) {
    commit('updateGoals', {
      goal: Literal.ACTIVE,
      value: false,
      name: Literal.DB_GOALS,
    })
    dispatch('saveDBGoals')
  },
  async loadAllGoals({ commit }) {
    const { data: dbdata } = await axios.get('/api/goals')
    commit('loadAllGoals', dbdata)
  },
  async goalStartup({ commit, dispatch }) {
    const { data: routes } = await axios.get('api/routes?stripped=false')
    const { data: locations } = await axios.get('api/locations')
    const { data: dbdata } = await axios.get('/api/goals')
    const { data: globalFields } = await axios.get(
      `/api/fields?names=${globalStringFields}`
    )
    const { data: grades } = await axios.get('/api/customFields/grade')
    grades.name = 'grade'
    const fields = globalFields.concat(grades)
    commit('loadActiveRoutes', {
      routes,
    })
    commit('loadDesiredRoutes', locations)
    commit('loadAllGoals', dbdata)
    fields.forEach(field =>
      commit('updateFields', { name: field.name, value: field.values })
    )
    var goalData
    for (const idx in dbdata) {
      if (dbdata[idx].active == true) {
        goalData = dbdata[idx]
        break
      }
    }
    if (!goalData) {
      commit('instantiateEmptyGoals')
      commit('initializeGoals', state.emptyDb)
      axios
        .post('/api/goals/create', state.emptyDb)
        .then(({ data: { goal, message } }) => {
          commit('copyDBtoLocal', { goal })
          dispatch('messages/setMessage', message, { root: true })
        })
    } else {
      commit('initializeGoals', goalData)
    }
  },
  async deleteGoal({ dispatch }, { id }) {
    try {
      const {
        data: { message },
      } = await axios.delete(`/api/goals/${id}`)
      dispatch('messages/setMessage', message, { root: true })
    } catch (e) {
      return e.message
    }
  },
  async saveNewGoals({ commit, dispatch }, name) {
    commit('updateGoals', {
      goal: Literal.NAME,
      value: name,
      name: Literal.EMPTY_DB,
    })
    try {
      const {
        data: { goal, message },
      } = await axios.post('/api/goals/create', state.emptyDb)
      commit('copyDBtoLocal', { goal })
      dispatch('messages/setMessage', message, { root: true })
    } catch (e) {
      return e.message
    }
  },
  async saveDBGoals({ dispatch }) {
    try {
      const {
        data: { message },
      } = await axios.put(`/api/goals/${state.dbgoals._id}`, state.dbgoals)
      dispatch('messages/setMessage', message, { root: true })
    } catch (e) {
      return e.message
    }
  },
  updateTotalGymRoutes({ commit }, payload) {
    commit('updateTotalGymRoutes', payload)
  },
  updateMaximumRouteAge({ commit }, payload) {
    commit('updateMaximumRouteAge', payload)
  },
  updateRoutesPerWeek({ commit }, payload) {
    commit('updateRoutesPerWeek', payload)
  },
  updateGoals({ commit }, payload) {
    commit('updateGoals', payload)
  },
  evenState({ commit }, { name }) {
    commit('evenState', name)
  },
  convertDBtoLocal({ commit }) {
    commit('convertDBtoLocal')
  },
  convertLocalToDB({ commit }) {
    commit('convertLocalToDB')
  },
  scaleGoals({ commit }) {
    commit('scaleGoals')
  },
  evenDBGoals({ commit }) {
    commit('evenDBGoals')
  },
  evenDBfield({ commit }, field) {
    commit('evenDBfield', field)
  },
  updateName({ commit, dispatch }, name) {
    commit('updateName', name)
    dispatch('saveDBGoals')
  },
}

const mutations = {
  loadAllGoals(state, goals) {
    state.allGoals = goals
  },
  updateName(state, name) {
    state.dbgoals.name = name
    state.goals.name = name
  },
  loadDesiredRoutes(state, locations) {
    const totalDesiredRoutes = locations.reduce((carry, item) => {
      carry += item.routeLimit
      return carry
    }, 0)
    state.totalDesiredRoutes = totalDesiredRoutes
  },
  instantiateEmptyGoals(state) {
    state.emptyDb = Object.keys(newGoals).reduce((carry, key) => {
      if (state.defaultFields[key]) {
        carry[key] = state.defaultFields[key].map(value => {
          return {
            key: value,
            value: state.defaultFields[key].length,
          }
        }, [])
      } else {
        carry[key] = newGoals[key]
      }
      return carry
    }, {})
    state.emptyDb.totalGymRoutes = state.totalDesiredRoutes
  },
  initializeGoals(state, payload) {
    state.dbgoals = deepcopy(payload)
    state.dbgoals.totalGymRoutes = state.totalDesiredRoutes
    state.dbgoals.active = true
    state.goals = convertDBgoals(state.dbgoals)
  },
  updateGoals(state, { goal, value, name }) {
    state[name][goal] = value
  },
  updateFields(state, payload) {
    state.defaultFields[payload.name] = payload.value
  },
  evenState(state, name) {
    for (const [key, value] of Object.entries(state.defaultFields)) {
      for (var i = 0; i < value.length; i++) {
        state[name][key][i].value = value.length
      }
    }
  },
  evenDBfield(state, field) {
    var length = state.defaultFields[field].length
    for (const obj of state.dbgoals[field]) {
      obj.value = length
    }
  },
  loadActiveRoutes(state, { routes }) {
    state.activeRoutes = routes
    state.totalActiveRoutes = routes.length
  },
  updateTotalGymRoutes(state, payload) {
    if (typeof payload === Literal.STRING) {
      payload = parseFloat(payload)
    }
    state.dbgoals.totalGymRoutes = payload
    state.goals.totalGymRoutes = payload
  },
  updateMaximumRouteAge(state, payload) {
    if (typeof payload === Literal.STRING) {
      payload = parseFloat(payload)
    }
    state.dbgoals.maximumRouteAge = payload
    state.goals.maximumRouteAge = payload
  },
  updateRoutesPerWeek(state, payload) {
    if (typeof payload === Literal.STRING) {
      payload = parseFloat(payload)
    }
    state.dbgoals.routesPerWeek = payload
    state.goals.routesPerWeek = payload
  },
  convertLocalToDB(state) {
    state.dbgoals = convertLocalGoals(state.goals)
  },
  convertDBtoLocal(state) {
    state.goals = convertDBgoals(state.dbgoals)
  },
  copyDBtoLocal(state, { goal }) {
    state.dbgoals = deepcopy(goal)
    state.goals = convertDBgoals(state.dbgoals)
  },
}

export default {
  namespaced: true,
  state,
  actions,
  mutations,
}
import axios from '../api'
import { emptySetter } from '../variables'

const state = {
  email: '',
  firstName: '',
  lastName: '',
  profile: {
    ...emptySetter,
  },
}
const getters = {}
const actions = {
  async getProfile({ commit }) {
    try {
      const { data } = await axios('/api/currentUser')
      commit('setProfile', data.currentUser)
    } catch (e) {
      return e.message
    }
  },
  setProfile({ commit }, payload) {
    commit('setProfile', payload)
  },
  async checkEmail({ commit }, email) {
    let res = await axios.get(`/api/setters?email=${email}`)
    return res
  },
  async findSetter({ commit }) {
    const { email } = state
    try {
      let res = await axios.get(`/api/confirm/email?email=${email}`)

      return res
    } catch (e) {
      return e.response
    }
  },
  async sendLogin({ commit }) {
    const { email } = state
    commit('toggleSending')
    try {
      return await axios.post('/api/confirm', {
        email,
        exists: true,
        rememberMe: false,
      })
    } catch (e) {
      return e.response
    } finally {
      commit('toggleSending')
    }
  },
  sendCode({ commit }) {
    const { email, firstName, lastName } = state
    axios
      .post('/api/confirm', { email, firstName, lastName, exists: false })
      .catch(error => {
        if (error.response.data.error) {
          commit('setError', error.response.data.error)
        } else {
          commit('setError', error.response.data.message)
        }
      })
  },
  async confirmCode({ commit }, code) {
    const { email } = state
    try {
      return await axios.post('/api/confirm/code', { code, email })
    } catch (e) {
      commit('setError', e.response.data.error)
    }
  },
  setField({ commit }, payload) {
    commit('setField', payload)
  },
  resetField({ commit }, field) {
    commit('reseField', field)
  },
  setError({ commit }, message) {
    commit('setError', message)
  },
  resetError({ commit }) {
    commit('resetError')
  },
  updateCurrentProfileProp({ commit }, payload) {
    commit('updateCurrentProfileProp', payload)
  },
  async saveSetter() {
    const { profile } = state

    try {
      let res = await axios.post(`/api/setters/create`, profile)

      return res
    } catch (e) {
      return e.message
    }
  },
}

const mutations = {
  setProfile(state, currentUser) {
    state.profile = Object.keys(emptySetter).reduce((carry, key) => {
      if (currentUser[key]) {
        carry[key] = currentUser[key]
      } else {
        carry[key] = emptySetter[key]
      }
      return carry
    }, {})
    state.profile._id = currentUser._id
  },
  updateCurrentProfileProp(state, { key, value }) {
    state.profile[key] = value
  },
  setField(state, { key, value }) {
    state[key] = value
  },
  resetProfile(state) {
    state.profile = { ...emptySetter }
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import { Literal } from '../tokens'

const state = {
  names: [],
  descriptions: {},
  customValues: [],
  activeValues: [],
}

const getters = {}

const actions = {
  async setField({ dispatch }, name) {
    try {
      let data
      if (name === Literal.CUSTOM) {
        data = await axios.get('/api/customFields/grade')
      } else {
        data = await axios.get(`/api/grades/${name}`)
      }
      const { data: grade } = data
      let obj = { name: 'grade', change: { values: grade.values } }
      dispatch('fields/updateCustomField', obj, { root: true })
    } catch (e) {
      return e.response
    }
  },
  async getActiveValues({ commit }) {
    try {
      const { data: grades } = await axios.get('/api/customFields/grade')
      commit('setState', { key: 'activeValues', value: grades.values })
    } catch (e) {
      return e.response
    }
  },
  async saveActiveGradeScale({ dispatch }) {
    let obj = { name: 'grade', change: { values: state.activeValues } }
    dispatch('fields/updateCustomField', obj, { root: true })
  },
  async getDefaultGrades({ commit }) {
    try {
      const { data: globalGrades } = await axios.get(
        '/api/grades?discipline=Bouldering'
      )
      const grades = globalGrades.reduce(
        (carry, grade) => {
          carry.names.push(grade.name)
          carry.descriptions[grade.name] = grade.description
          return carry
        },
        { names: [], descriptions: {} }
      )
      const { names, values, descriptions } = grades
      commit('setState', { key: 'names', value: names })
      commit('setState', { key: 'descriptions', value: descriptions })
    } catch (e) {
      return e.response
    }
  },
  getDescriptions({ commit }, grades) {
    const descriptions = grades.reduce((carry, grade) => {
      carry[grade.name] = grade.description
      return carry
    }, {})
    commit('setDescriptions', descriptions)
  },
  async chooseDefaultGradeScale({ commit }, { boulderingSystem }) {
    const { data: grades } = await axios.get(`/api/grades/${boulderingSystem}`)
    commit('setActiveValues', grades.values)
  },
}

const mutations = {
  setState(state, payload) {
    const { key, value } = payload
    state[key] = value
  },
  setActiveValues(state, values) {
    state.activeValues = values
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import { draw } from './D3/draw'
import { removeGraph, removeTicks } from './D3/chartUtils'
import { getD3data } from './D3/dataManipulation'
import { globalStringFields, globalNullFields } from '../variables'
import { deepcopy } from '../modules/D3/goalUtils'
import Vue from 'vue'

const state = {
  dashboards: [
    {
      data: [],
      title: 'Active Routes by Color',
      dataType: 'color',
      chartType: 'bar',
      width: 800,
      height: 500,
      id: 'c0',
    },
    {
      data: [],
      title: 'Active Routes by Techniques',
      dataType: 'techniques',
      chartType: 'pie',
      width: 800,
      height: 500,
      id: 'c1',
    },
    {
      data: [],
      title: 'Average Inter Color Difficulty',
      dataType: 'color',
      chartType: 'bar',
      width: 800,
      height: 500,
      id: 'c3',
    },
    {
      data: [],
      title: 'Active Routes by Color and Setter',
      dataType: 'color',
      chartType: 'groupBar',
      width: 800,
      height: 500,
      id: 'c4',
    },
  ],
  goals: {},
  defaultFields: { ...deepcopy(globalNullFields) },
  activeRoutes: [],
  historicalRoutes: [],
  allSetters: [],
  activeSetters: [],
  inactiveSetters: [],
  setterNames: [],
  chartDescriptions: [
    'Bar chart showing average intra grade difficulty',
    'Pie chart showing the methods that the current active routes teach, and their frequency',
    'Bar chart showing route grade frequency in the gym',
    'A Series of individual bar charts, showing the number of routes created by grade by each selected setter.',
    'A Line graph plotting time against route creation. Each dot is an instance of route creation. The line shows the trend over time',
  ],
  chartChoices: [
    'Average Inter Color Difficulty',
    'Active Routes by Techniques',
    'Active Routes by Color',
    'Active Routes by Color and Setter',
    'Routes over Time',
  ],
}

const getters = {
  returnParameters: state => title => {
    let params
    switch (title) {
      case state.chartChoices[0]:
        params = {
          outputDimension: 1,
          nodes: {
            parent: 'grade',
            target: 'intraDifficulty',
          },
          dataType: 'average',
          targetType: 'number',
        }
        break
      case state.chartChoices[1]:
        params = {
          outputDimension: 1,
          nodes: {
            parent: 'grade',
            target: 'techniques',
            leaf: 'key',
          },
          dataType: 'count',
          targetType: 'array',
        }
        break
      case state.chartChoices[2]:
        params = {
          outputDimension: 1,
          nodes: {
            parent: 'grade',
          },
          dataType: 'count',
          targetType: 'number',
        }
        break
      case state.chartChoices[3]:
        params = {
          outputDimension: 2,
          nodes: {
            parent: 'setter',
            target: 'grade',
          },
          dataType: 'count',
          targetType: 'number',
          setters: 'Rubin',
        }
        break
      case state.chartChoices[4]:
        params = {
          outputDimension: 1,
          nodes: {
            parent: 'date',
            target: 'grade',
          },
          dataType: 'count',
          targetType: 'date',
        }
        break
      case state.chartChoices[5]:
        params = {
          outputDimension: 2,
          nodes: {
            parent: 'grade',
            target: 'techniques',
          },
          dataType: 'count',
          targetType: 'array',
        }
        break
      default:
        return `${title} is not supported yet.`
    }
    return params
  },
}

const actions = {
  getActiveRoutes({ commit }) {
    axios.get('api/routes?stripped=false').then(({ data: routes }) => {
      commit('loadActiveRoutes', {
        routes,
      })
    })
  },
  getHistoricalRoutes({ commit }) {
    axios.get('api/routes?stripped=true').then(({ data: routes }) => {
      commit('loadHistoricalRoutes', {
        routes,
      })
    })
  },
  getAllSetters({ commit }) {
    axios.get('/api/setters?').then(({ data: data }) =>
      commit('loadAllSetters', {
        data,
      })
    )
  },
  async loadFields({ commit }) {
    const { data: globalFields } = await axios.get(
      `/api/fields?names=${globalStringFields}`
    )
    const { data: grades } = await axios.get('/api/customFields/grade')
    const fields = globalFields.concat(grades)
    fields.forEach(field =>
      commit('updateFields', { name: field.name, value: field.values })
    )
  },
  async loadGoals({ commit }) {
    const data = await axios.get('/api/goals')
    commit('loadGoals', data)
  },
  populateData({ commit }, params) {
    commit('populateData', params)
  },
  clearChart({ commit }, payload) {
    commit('clearChart', payload)
  },
  deleteChart({ commit }, payload) {
    commit('deleteChart', payload)
  },
  swapChartUp({ commit }, payload) {
    commit('swapChartUp', payload)
  },
  swapChartDown({ commit }, payload) {
    commit('swapChartDown', payload)
  },
  setChartType({ commit }, payload) {
    commit('setChartType', payload)
  },
  drawCharts({ commit }, payload) {
    commit('drawCharts', payload)
  },
  drawChart({ commit, dispatch }, payload) {
    dispatch('clearChart', payload).then(() => {
      commit('drawChart', payload)
    })
  },
  updateWidth({ commit }, payload) {
    commit('updateWidth', payload)
  },
  createChart({ commit }, payload) {
    commit('createChart', payload)
  },
  updateDashboard({ commit }, payload) {
    commit('updateDashboard', payload)
  },
}

const mutations = {
  loadGoals(state, payload) {
    state.goals = payload
  },
  updateFields(state, payload) {
    state.defaultFields[payload.name] = payload.value
  },
  populateData(state, params) {
    var data = getD3data(state.activeRoutes, params.params)
    Vue.set(state.dashboards[Number(params.dashboardKey)], 'data', data)
  },
  loadActiveRoutes(state, { routes }) {
    state.activeRoutes = routes
  },
  loadHistoricalRoutes(state, { routes }) {
    state.historicalRoutes = routes
  },
  loadAllSetters(state, { data }) {
    state.allSetters = data
    state.activeSetters = state.allSetters.reduce((carry, setter) => {
      if (setter.active == true) {
        carry.push(setter)
      }
      return carry
    }, [])
    state.inactiveSetters = state.allSetters.reduce((carry, setter) => {
      if (setter.active == false) {
        carry.push(setter)
      }
      return carry
    }, [])
    state.setterNames = state.activeSetters.reduce((carry, setter) => {
      carry.push(setter.email)
      return carry
    }, [])
  },
  updateWidth(state, { width, index }) {
    state.dashboards[index].width = width
  },
  updateDashboard(state, { params, index }) {
    state.dashboards[index].title = params.choice
    state.dashboards[index].chartType = params.chartType
    state.dashboards[index].dataType = params.dataType
  },
  clearChart(state, { index }) {
    const { dashboards } = state
    var { chartType, id } = dashboards[index]
    if (chartType == 'pie') {
      removeTicks(`${id}`)
    } else if (chartType == 'bar' || chartType == 'groupBar') {
      removeGraph(`${id}`)
    } else {
      removeGraph(`${id}`)
    }
  },
  drawChart(state, { index }) {
    const { dashboards } = state
    draw(dashboards[index])
  },
  deleteChart(state, { index }) {
    state.dashboards.splice(index, 1)
  },
  swapChartUp(state, { start, end }) {
    const { dashboards } = state
    let first = dashboards[start]
    dashboards.splice(start, 1)
    dashboards.splice(end, 0, first)
  },
  swapChartDown(state, { start, end }) {
    const { dashboards } = state
    let first = dashboards[start]
    dashboards.splice(start, 1)
    dashboards.splice(end, 0, first)
  },
  setChartType(state, { index, chartType }) {
    state.dashboards[index].chartType = chartType
  },
  createChart(state, chart) {
    state.dashboards.push(chart)
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'

const state = {
  customScale: [],
}

const getters = {}

const actions = {
  async getCustomScale({ commit }) {
    try {
      const { data: customGrade } = await axios.get('/api/customFields/grade')
      commit('setCustomScale', customGrade.values)
    } catch (e) {
      return e.response
    }
  },
  editCustomGrade({ commit, dispatch }, payload) {
    payload.action = 'edit'
    commit('editCustomGrade', payload)
    dispatch('saveCustomScale')
    dispatch('updateSettingsValues', payload)
  },
  addCustomGrade({ commit, dispatch }, value) {
    commit('addCustomGrade', value)
    dispatch('saveCustomScale')
  },
  async saveCustomScale({ dispatch }) {
    const { customScale } = state
    let obj = { values: customScale }
    try {
      await axios.put('/api/customFields/grade', obj)
      await dispatch(
        'fields/updateCustomField',
        { name: 'grade', change: obj },
        { root: true }
      )
    } catch (e) {
      return e.response
    }
  },
  removeCustomGrade({ commit, dispatch }, payload) {
    payload.action = 'remove'
    commit('removeCustomGrade', payload.index)
    dispatch('saveCustomScale')
    dispatch('updateSettingsValues', payload)
  },
  reorderCustomGrades({ commit, dispatch }, customScale) {
    commit('reorderCustomGrades', customScale)
    dispatch('saveCustomScale')
  },
  updateSettingsValues({ dispatch, rootState }, payload) {
    const {
      settings: {
        settings: { defaultBoulderingGrades, gradeMask },
      },
    } = rootState
    const { action } = payload
    let newArray = []
    let newObj = {}
    let returnMessage = ''
    if (action === 'edit') {
      const { oldValue, value } = payload
      if (defaultBoulderingGrades.indexOf(oldValue) > -1) {
        const index = defaultBoulderingGrades.indexOf(oldValue)
        newArray = [...defaultBoulderingGrades]
        newArray[index] = value
      }
      if (Object.values(gradeMask).indexOf(oldValue) > -1) {
        newObj = Object.keys(gradeMask).reduce((carry, key) => {
          if (gradeMask[key] === oldValue) {
            carry[key] = value
          } else {
            carry[key] = gradeMask[key]
          }
          return carry
        }, {})
      }
      returnMessage = `${oldValue} changed to ${value}`
    }
    if (action === 'remove') {
      const { index, value } = payload
      newArray = [...defaultBoulderingGrades]
      const arrIndex = defaultBoulderingGrades.indexOf(value)
      if (arrIndex > -1) {
        newArray.splice(arrIndex, 1)
      }
      if (Object.values(gradeMask).indexOf(value) > -1) {
        newObj = Object.keys(gradeMask).reduce((carry, key) => {
          if (gradeMask[key] === value) {
            carry[key] = state.customScale[index]
          } else {
            carry[key] = gradeMask[key]
          }
          return carry
        }, {})
      }
      returnMessage = `${value} deleted`
    }
    if (newArray.length > 0) {
      dispatch(
        'settings/updateSetting',
        {
          change: {
            key: 'defaultBoulderingGrades',
            value: newArray,
          },
          returnMessage,
        },
        { root: true }
      )
    }
    if (Object.keys(newObj).length > 0) {
      dispatch(
        'settings/updateSetting',
        {
          change: {
            key: 'gradeMask',
            value: newObj,
          },
          returnMessage,
        },
        { root: true }
      )
    }
  },
}

const mutations = {
  setCustomScale(state, customScale) {
    state.customScale = customScale
  },
  addCustomGrade(state, value) {
    state.customScale.unshift(value)
  },
  editCustomGrade(state, payload) {
    const { index, value } = payload
    state.customScale[index] = value
  },
  removeCustomGrade(state, index) {
    state.customScale.splice(index, 1)
  },
  reorderCustomGrades(state, customScale) {
    state.customScale = customScale
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
const timeObj = {
  skeleton: 0,
  'setter forerun': 0,
  'group forerun': 0,
  finished: 0,
  stage: 'skeleton',
}

const unwrapTime = object => {
  var sum = 0
  for (const [key, value] of Object.entries(object)) {
    if (key != 'stage' && key != 'Stage') {
      sum += value
    }
  }
  return sum
}

const getLocalTime = () => {
  return JSON.parse(localStorage.timeData)
}
const saveLocalTime = obj => {
  const parsed = JSON.stringify(obj)
  localStorage.timeData = parsed
}

const copytime = object => {
  var copy = {
    skeleton: 0,
    'setter forerun': 0,
    'group forerun': 0,
    finished: 0,
    stage: object.stage,
  }
  return copy
}

export { timeObj, unwrapTime, copytime, getLocalTime, saveLocalTime }
import axios from '../api'
import { emptySetter, terrainTypes, roles } from '../variables'

const state = {
  headers: [
    { text: 'First Name', value: 'firstName' },
    { text: 'Last Name', value: 'lastName' },
    { text: 'Role', value: 'role' },
    { text: 'Active', value: 'active' },
  ],
  roles,
  newSetter: {
    ...emptySetter,
  },
  setters: [],
  activeSetters: [],
  setterHashmap: {},
  activeSetterHashmap: {},
}

const getters = {}

const actions = {
  async getAllSetters({ commit }) {
    try {
      const { data: setters } = await axios.get('api/setters')
      commit('setSetters', setters)
      commit('setSetterHashmap', setters)
      let active_setters = setters.filter(setter => setter.active == true)
      commit('setActiveSetters', active_setters)
      commit('setActiveSetterHashmap', active_setters)
    } catch (e) {
      return e
    }
  },
  async getActiveSetters({ commit }) {
    try {
      const { data: setters } = axios.get('/api/setters?active=true')
      commit('setActiveSetters', setters)
      commit('setActiveSetterHashmap', setters)
    } catch (e) {
      return e
    }
  },
  updateNewSetterProp({ commit }, payload) {
    commit('updateNewSetterProp', payload)
  },
  async inviteSetter({ _ }, payload) {
    let wrapper = [payload]
    try {
      return await axios.post('/api/setters/invite', wrapper)
    } catch (e) {
      return e.message
    }
  },
  async saveNewSetter({ dispatch }) {
    const { newSetter } = state
    const { avatar } = newSetter
    if (avatar) {
      await dispatch('uploadAvatar', avatar)
    }
    await axios
      .post('/api/setters/create', newSetter)
      .then(({ data: data }) => {
        const { message } = data
        dispatch('messages/setMessage', message, { root: true })
        dispatch('getAllSetters')
      })
      .catch(error => {
        return error.message
      })
  },
  async uploadAvatar({ commit }, avatar) {
    try {
      const formData = new FormData()
      formData.append('gallery', avatar)
      const { data } = await axios.post('/api/images/upload', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      })
      commit('updateNewSetterProp', { key: 'avatar', value: data })
      return data
    } catch (e) {
      return e
    }
  },
  async deleteAvatar(_, imageId) {
    return axios.delete(`/api/images/${imageId}`)
  },
  async deleteSetter({ dispatch }, setter) {
    try {
      const { _id, avatar, email } = setter
      if (avatar) {
        await dispatch('deleteAvatar', avatar._id)
      }
      await axios.delete(`/api/setters/${_id}`)
      await dispatch('messages/setMessage', `${email} deleted.`, {
        root: true,
      })
      await dispatch('getAllSetters')
    } catch (e) {
      return e
    }
  },
  bulkDelete({ dispatch }, obj) {
    return axios
      .delete('/api/setters/bulk/delete', { data: obj })
      .then(({ data: { message } }) => {
        dispatch('getAllSetters')
        return message
      })
      .catch(error => {
        return error.message
      })
  },
  resetForm({ commit }) {
    commit('resetForm')
  },
}

const mutations = {
  setSetters(state, setters) {
    state.setters = setters
  },
  setSetterHashmap(state, setters) {
    state.setterHashmap = setters.reduce((carry, setter) => {
      carry[setter._id] = `${setter.firstName} ${setter.lastName}`
      return carry
    }, {})
  },
  setActiveSetters(state, setters) {
    state.activeSetters = setters
  },
  setActiveSetterHashmap(state, setters) {
    state.activeSetterHashmap = setters.reduce((carry, setter) => {
      carry[setter._id] = `${setter.firstName} ${setter.lastName}`
      return carry
    }, {})
  },
  updateNewSetterProp(state, { key, value }) {
    state.newSetter[key] = value
  },
  resetForm(state) {
    state.newSetter = { ...emptySetter }
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import { emptyGym } from '../variables'

const state = {
  gym: { ...emptyGym },
  gyms: [],
}

const getters = {}
const actions = {
  async uploadLogo({ dispatch }, payload) {
    const { value } = payload
    try {
      if (state.gym.logo) {
        if (state.gym.logo._id) {
          await dispatch('deleteLogo', state.gym.logo._id)
        }
      }
      const formData = new FormData()
      formData.append('gallery', value)
      const { data } = await axios.post('/api/images/upload', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      })
      dispatch('updateGym', { key: 'logo', value: data })
      return data
    } catch (e) {
      return e
    }
  },
  async deleteLogo(_, imageId) {
    return axios.delete(`/api/images/${imageId}`)
  },
  async getCurrentGym({ commit }) {
    try {
      const { data: gym } = await axios.get(`/api/gym/current`)
      commit('setGym', gym)
    } catch (e) {
      return e.message
    }
  },
  async getGyms({ commit }) {
    try {
      const { data: gyms } = await axios.get(`/api/gym/`)
      commit('setGyms', gyms)
    } catch (e) {
      return e
    }
  },
  async clearGym({ _ }) {
    try {
      await axios.post('/api/gym/set', { gym: null })
    } catch (e) {
      return e
    }
  },
  async setGym({ _ }, payload) {
    const { gym } = payload
    try {
      await axios.post('/api/gym/set', { gym })
    } catch (e) {
      return e
    }
  },
  async selectGym({ _ }, payload) {
    try {
      const { gym, user } = payload
      await axios.post('/api/gym/set', { gym })
      if (
        user.gyms[gym._id].role == 'Head Setter' ||
        user.gyms[gym._id].role == 'Owner'
      ) {
        window.location = '/dashboard'
      } else {
        window.location = `/setters-home?setter=${user._id}`
      }
      return _
    } catch (e) {
      return e
    }
  },
  async updateGym({ commit }, { key, value }) {
    try {
      await commit('updateGym', { key, value })
      let newKey =
        state.gym.name +
        state.gym.address +
        state.gym.city +
        state.gym.state +
        state.gym.ZIPCode +
        state.gym.country
      await axios.put(`/api/gym/${state.gym._id}`, {
        [key]: value,
        key: newKey,
      })
      return { message: 'Gym updated' }
    } catch (e) {
      return e
    }
  },
}
const mutations = {
  updateGym(state, { key, value }) {
    state.gym[key] = value
  },
  setGym(state, gym) {
    state.gym = gym
  },
  setGyms(state, gyms) {
    state.gyms = gyms
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'

const state = {}

const getters = {}
const actions = {
  async updateUser({ _ }, payload) {
    try {
      let gyms, gymUpdate
      const { currentUser, role, gymId, activeGradeValues } = payload

      let update = {
        [gymId]: {
          role,
          maxBSettingAbility: activeGradeValues.length - 1,
          totalRoutes: 0,
          assignments: 0,
          ricBias: '',
        },
      }

      if (currentUser.gyms) {
        gyms = currentUser.gyms
        gymUpdate = {
          ...gyms,
          ...update,
        }
      } else {
        gymUpdate = {
          ...update,
        }
      }

      const res = await axios.put(`/api/setters/${currentUser._id}`, {
        gyms: gymUpdate,
      })

      return { message: `${currentUser.firstName} updated gym` }
    } catch (e) {
      return e
    }
  },
  async getCurrentUser({ commit }) {
    try {
      const { data } = await axios.get('/api/currentUser')

      commit('setCurrentUser', data.currentUser)
    } catch (e) {
      return e
    }
  },
}

const mutations = {
  setCurrentUser(state, user) {
    state.currentUser = user
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'

const headerOrder = {
  Date: 0,
  Location: 1,
  Setter: 2,
  Grade: 3,
  Techniques: 4,
  Risk: 5,
  Intensity: 6,
  Complexity: 7,
  Intradifficulty: 8,
  'Height Friendly': 9,
  'Start Location': 10,
  'Finish Location': 11,
  HoldType: 12,
  Length: 13,
  Emotion: 14,
  Time: 15,
  'Set Screwed': 16,
  Stripped: 17,
  Notes: 18,
}

const state = {
  headers: [],
  values: {},
}

const getters = {}

const actions = {
  async getAllFields({ commit }) {
    try {
      const { data: globalFields } = await axios.get('/api/fields')
      const { data: customFields } = await axios.get('/api/customFields')
      const fields = globalFields.concat(customFields)
      const { headers, values } = fields.reduce(
        (carry, field) => {
          if (field.values.length > 0) {
            carry.values[field.name] = field.values
          }
          carry.headers.push({
            text: field.label,
            value: field.name,
            type: field.type,
          })
          return carry
        },
        {
          headers: [],
          values: {},
        }
      )
      commit('setHeaders', headers)
      commit('setFields', values)
    } catch (e) {
      return e.response
    }
  },
  updateCustomField({ dispatch }, payload) {
    const { name, change } = payload
    return axios
      .put(`/api/customFields/${name}`, change)
      .then(() => {
        dispatch('getAllFields')
      })
      .catch(error => {
        return error.message
      })
  },
}

const mutations = {
  setHeaders(state, headers) {
    headers.sort((a, b) => headerOrder[a.text] - headerOrder[b.text])
    state.headers = headers
  },
  setFields(state, values) {
    state.values = values
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import { Literal } from '../tokens'
import { emptyTarget } from '../variables'

const state = {
  target: {
    gymId: null,
    routeId: null,
    setterId: null,
    targets: {},
  },
}

const actions = {
  async createTarget({ commit, dispatch }, new_target) {
    try {
      const {
        data: { target, message },
      } = await axios.post('/api/targets/create', new_target)
      dispatch('messages/setMessage', message, { root: true })
      commit('setTarget', target)
    } catch (e) {
      return e.message
    }
  },
  async getTargetById({ commit }, id) {
    const { data: target } = await axios.get('/api/targets/' + id)
    if (!Array.isArray(target)) {
      commit('setTarget', target.target)
    }
  },
  async getTarget({ commit }, { routeId, setterId }) {
    const { data: target } = await axios.get(
      `/api/targets?routeId=${routeId}&setterId=${setterId}`
    )
    if (target !== undefined && target.length) {
      commit('setTarget', target[0])
    }
  },
  async updateTarget({ dispatch, state }, { key, value }) {
    let old_target = { ...state.target }
    if (old_target.targets.hasOwnProperty(key)) {
      delete old_target.targets[key]
    } else {
      old_target.targets[key] = value
    }
    const { data: message } = await axios.put(
      `/api/targets/${old_target._id}`,
      old_target
    )
    dispatch('messages/setMessage', message.message, { root: true })
    dispatch('getTargetById', old_target._id)
  },
  async deleteTarget({ commit }) {
    commit('deleteTarget')
  },
}

const mutations = {
  setTarget(state, target) {
    if (target.targets === undefined) {
      target.targets = {}
    }
    state.target = target
  },
  deleteTarget(state) {
    state.target = { ...emptyTarget }
  },
}

export default {
  namespaced: true,
  state,
  actions,
  mutations,
}
import axios from '../api'
import { emptyAccount } from '../variables'

const state = {
  products: [],
  prices: [],
  account: { ...emptyAccount },
}
const getters = {}
const actions = {
  async get_session({ _ }, { priceId, productId }) {
    let res = await axios.post('/api/billing/create-checkout-session', {
      priceId,
      productId,
    })
    window.location.href = res.data.url
  },
  async get_products({ commit }) {
    let { data } = await axios.get('/api/billing/products')
    commit('save_state', { key: 'products', value: data.data })
  },
  async get_prices({ commit }) {
    let { data } = await axios.get('/api/billing/prices')
    commit('save_state', { key: 'prices', value: data.data })
  },
  async customer_portal({ _ }) {
    let res = await axios.get('/api/billing/create-customer-portal-session')
    window.location.href = res.data.url
  },
  async get_account({ commit }) {
    let { data } = await axios.get('/api/billing/account')
    commit('save_state', { key: 'account', value: data.data })
  },
}
const mutations = {
  save_state(state, { key, value }) {
    state[key] = value
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'

const state = {
  isEmailSent: false,
  sending: false,
  error: '',
}

const actions = {
  sendLink({ commit }, { email, rememberMe }) {
    commit('toggleSending')
    return axios
      .post('/api/confirm', { email, exists: true, rememberMe })
      .then(() => {
        commit('updateIsEmailSentFlag')
      })
      .catch(error => {
        if (error.response.data.error) {
          commit('setError', error.response.data.error)
        } else {
          commit('setError', error.response.data.message)
        }
      })
      .then(() => {
        commit('toggleSending')
      })
  },
  setError({ commit }, error) {
    commit('setError', error)
  },
  resetError({ commit }) {
    commit('resetError')
  },
}

const mutations = {
  updateIsEmailSentFlag(state) {
    state.isEmailSent = true
  },
  toggleSending() {
    state.sending = !state.sending
  },
  setError(state, message) {
    state.error = message
  },
  resetError(state) {
    state.error = ''
  },
}

export default {
  namespaced: true,
  state,
  actions,
  mutations,
}
import { descending } from 'd3'

const _MS_PER_DAY = 1000 * 60 * 60 * 24
const returnSortByKey = data => {
  data.sort((x, y) => {
    return descending(x.key, y.key)
  })
  return data
}

const returnSortByCustom = (data, target) => {
  if (typeof data[target] == String) {
    data.sort((x, y) => {
      return descending(x[target].toLowerCase(), y[target].toLowerCase())
    })
  } else {
    data.sort((x, y) => {
      return descending(x[target], y[target])
    })
  }
  return data
}

const dateDiffInDays = (a, b) => {
  const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate())
  const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate())

  return Math.abs(Math.floor((utc2 - utc1) / _MS_PER_DAY))
}

const returnGradeOrder = grade => {
  const gradeOrder = {
    blue: 0,
    pink: 1,
    purple: 2,
    green: 3,
    yellow: 4,
    orange: 5,
    red: 6,
    grey: 7,
    black: 8,
    white: 9,
  }
  return gradeOrder[grade]
}

const returnSortByGrade = (data, params) => {
  data = data.sort((x, y) => {
    const tempX = returnGradeOrder(x[params.key])
    const tempY = returnGradeOrder(y[params.key])
    return tempX - tempY
  })
  return data
}

const returnSortByValue = data => {
  data.sort((x, y) => {
    return descending(x.value, y.value)
  })
  return data
}

const getAverage = target => {
  var avg = target.values.reduce((total, leaf, index, array) => {
    total += array[index].value * Number(array[index].key)
    return total
  }, 0)
  return avg
}

const sumValue = target => {
  var sum = target.values.reduce((total, leaf) => {
    return total + leaf.value
  }, 0)
  return sum
}

const cleanRoutes = (routes, key) => {
  let data = routes.reduce((carry, route) => {
    if (route[key] !== undefined) {
      carry.push(route)
    }
    return carry
  }, [])
  return data
}

const sliceRoutes = (routes, location) => {
  let targetRoutes = routes.reduce((carry, route) => {
    if (route.location == location) {
      carry.push(route)
    }
    return carry
  }, [])
  return targetRoutes
}

const cleanSortDates = data => {
  data.reduce((carry, route) => {
    if (route.key !== 'undefined') {
      carry.push(route)
    }
    return carry
  }, [])
  data.sort((a, b) => {
    return new Date(a.key) - new Date(b.key)
  })
  data = convertDates(data)
  return data
}

const convertDates = data => {
  const result = data.reduce((carry, datum, index) => {
    var dateObj = new Date(datum.key)
    datum.key = dateObj
    if (index > 0) {
      if (datum.key == data[index - 1].key) {
        datum.values.reduce((carry, item) => {
          const temp = data[index - 1].values.filter(thing => {
            return thing.key === item.key
          })
          item.value += temp[0].value
          carry.push({ key: item.key, value: item.value })
          return carry
        }, [])
        carry.pop()
      }
    }
    carry.push(datum)
    return carry
  }, [])
  return result
}

export {
  returnSortByGrade,
  returnSortByCustom,
  returnSortByKey,
  returnSortByValue,
  getAverage,
  sumValue,
  dateDiffInDays,
  cleanRoutes,
  sliceRoutes,
  cleanSortDates,
  convertDates,
}
import {
  returnObjMap,
  returnOccurances,
  returnNest,
  returnOldDates,
  returnAverages,
  returnAverageAge,
  missingKeys,
  fillMissingKeys,
  convertToMinutes,
} from './dataManipulation'
import {
  sumValue,
  returnSortByGrade,
  returnSortByKey,
  returnSortByCustom,
  cleanSortDates,
  getAverage,
} from './dataUtils'

const returnFields = (routes, defaultFields) => {
  let techniques = returnTechniques(routes, defaultFields.techniques)
  let heightFriendly = returnHeight(routes, defaultFields.heightFriendly)
  let intensity = returnIntensity(routes, defaultFields.intensity)
  let complexity = returnComplexity(routes, defaultFields.complexity)
  let length = returnLength(routes, defaultFields.length)
  let risk = returnRisk(routes, defaultFields.risk)
  let grade = returnGrades(routes, defaultFields.grade)
  let holdType = returnHoldtypes(routes, defaultFields.holdType)
  var payload = {
    techniques,
    heightFriendly,
    intensity,
    complexity,
    length,
    risk,
    grade,
    holdType,
  }
  return payload
}

const returnWallStyles = (styleNames, activeRoutes) => {
  let params = {
    parent: 'location',
    target: 'style',
    leaf: 'name',
  }
  let wallStyles = returnObjMap(styleNames, activeRoutes, params)
  return returnSortByCustom(wallStyles, 'name')
}

const returnAvgWallAge = (locationNames, activeRoutes) => {
  let params = { leaf: 'name' }
  let locationObj = locationNames.map(element => {
    return { [params.leaf]: element, value: 0, count: 0, routes: [] }
  })
  return returnOldDates(locationObj, activeRoutes, params)
}

const returnAvgWallIntradifficulty = (locationNames, activeRoutes) => {
  let params = { leaf: 'name', target: 'intraDifficulty' }
  let locationObj = locationNames.map(element => {
    return { [params.leaf]: element, value: 0, count: 0, routes: [] }
  })
  return returnAverages(locationObj, activeRoutes, params)
}

const returnAvgGradeIntradifficulty = (gradeNames, activeRoutes) => {
  let params = {
    outputDimension: 1,
    nodes: {
      parent: 'grade',
      target: 'intraDifficulty',
    },
    dataType: 'average',
    targetType: 'number',
  }
  let temp = returnNest(activeRoutes, params.nodes, 2)
  let data = temp.map(grade => {
    return { key: grade.key }
  })
  temp.forEach((route, index) => {
    var sum = sumValue(route)
    var average = getAverage(route)
    data[index].value = (average / sum).toFixed(2)
  })
  return returnSortByGrade(data, { key: 'key' })
}

const returnAvgRouteAge = activeRoutes => {
  return returnAverageAge(activeRoutes)
}

const returnIntraDifficulty = (activeRoutes, defaultFields) => {
  let nodes = { parent: 'intraDifficulty' }
  let data = returnNest(activeRoutes, nodes, 1)
  data = missingKeys(data, defaultFields)
  return returnSortByCustom(data, 'key')
}

const returnLength = (activeRoutes, defaultFields) => {
  let nodes = { parent: 'length' }
  let data = returnNest(activeRoutes, nodes, 1)
  // Take into account length which is undefined REMOVE THIS WHEN POSSIBLE
  data.forEach((value, index) => {
    if (value.key == 'undefined') {
      data.splice(index, 1)
    }
  })
  data = missingKeys(data, defaultFields)
  return returnSortByCustom(data, 'key')
}
const returnComplexity = (activeRoutes, defaultFields) => {
  let nodes = {
    parent: 'complexity',
  }
  let data = returnNest(activeRoutes, nodes, 1)
  data = missingKeys(data, defaultFields)
  return returnSortByCustom(data, 'key')
}
const returnRisk = (activeRoutes, defaultFields) => {
  let nodes = { parent: 'risk' }
  let data = returnNest(activeRoutes, nodes, 1)
  data = missingKeys(data, defaultFields)
  return returnSortByCustom(data, 'key')
}
const returnIntensity = (activeRoutes, defaultFields) => {
  let nodes = { parent: 'intensity' }
  let data = returnNest(activeRoutes, nodes, 1)
  data = missingKeys(data, defaultFields)
  // convert string digits to digits
  // let newData = []
  // for (const [key, item] of Object.entries(data)) {
  //   newData.push({ key: parseInt(item.key), value: parseInt(item.value) })
  // }
  // return returnSortByCustom(newData, 'key')
  return returnSortByCustom(data, 'key')
}
const returnHeight = (activeRoutes, defaultFields) => {
  let nodes = { parent: 'heightFriendly' }
  let data = returnNest(activeRoutes, nodes, 1)
  data = missingKeys(data, defaultFields)
  return returnSortByCustom(data, 'key')
}
const returnHoldtypes = (activeRoutes, defaultFields) => {
  let nodes = { parent: 'holdType' }
  let data = returnNest(activeRoutes, nodes, 1)
  data = missingKeys(data, defaultFields)
  return returnSortByCustom(data, 'key')
}
const returnTechniques = (activeRoutes, defaultFields) => {
  let params = {
    parent: 'techniques',
    target: 'techniques',
    leaf: 'name',
  }
  let techniques = returnOccurances(activeRoutes, params)
  techniques = switchKeys(techniques, defaultFields)
  return returnSortByCustom(techniques, 'key')
}

const switchKeys = (field_type, defaultFields) => {
  field_type = field_type.reduce((carry, item) => {
    carry[item.name] = item.value
    return carry
  }, {})
  field_type = defaultFields.reduce((carry, field) => {
    const data = { key: field, value: 0 }
    if (field_type[field]) {
      data.value = field_type[field]
    }
    carry.push(data)
    return carry
  }, [])
  return field_type
}

const returnGrades = (activeRoutes, defaultFields) => {
  let nodes = { parent: 'grade' }
  let data = returnNest(activeRoutes, nodes, 1)
  data = missingKeys(data, defaultFields)
  return returnSortByGrade(data, { key: 'key' })
}

// Routes over time //

const returnAgeOvertime = (gradeNames, historicalRoutes) => {
  let nodes = { parent: 'date' }
  let data = returnNest(historicalRoutes, nodes, 1)
  // clean out undefined dates
  data = data.reduce((carry, route) => {
    if (route.key !== undefined) {
      carry.push(route)
    }
    return carry
  }, [])
  // sort by date
  data = returnSortByKey(data)
  return data
}
const returnIntradifficultyOvertime = (gradeNames, historicalRoutes) => {
  let nodes = { parent: 'date', target: 'intraDifficulty' }
  let temp = returnNest(historicalRoutes, nodes, 2)
  let data = temp.map(date => {
    return { key: date.key }
  })
  temp.forEach((route, index) => {
    var sum = sumValue(route)
    var average = getAverage(route)
    data[index].value = (average / sum).toFixed(2)
  })
  data = returnSortByGrade(data, { key: 'key' })
  // clean out undefined dates
  data = data.reduce((carry, route) => {
    if (route.key !== 'undefined') {
      carry.push(route)
    }
    return carry
  }, [])
  // sort by date
  data = returnSortByKey(data)
  return data
}
const returnStyleDiffOvertime = (gradeNames, historicalRoutes) => {
  let nodes = { parent: 'date', target: 'style' }
  let data = returnNest(historicalRoutes, nodes, 1)
  // clean out undefined dates
  data = data.reduce((carry, route) => {
    if (route.key !== 'undefined') {
      carry.push(route)
    }
    return carry
  }, [])
  // sort by date
  data = returnSortByKey(data)
  return data
}
const returnAvgRiskOvertime = (gradeNames, historicalRoutes) => {
  let nodes = { parent: 'date', target: 'risk' }
  let data = returnNest(historicalRoutes, nodes, 1)
  // clean out undefined dates
  data = data.reduce((carry, route) => {
    if (route.key !== 'undefined') {
      carry.push(route)
    }
    return carry
  }, [])
  // sort by date
  data = returnSortByKey(data)
  return data
}

const returnSettingTime = historicalRoutes => {
  let settingTime = historicalRoutes.reduce((carry, route) => {
    carry.push({
      key: route.date,
      skeleton: route.time.skeleton,
      'setter forerun': route.time['setter forerun'],
      'group forerun': route.time['group forerun'],
      finished: route.time.finished,
    })
    return carry
  }, [])
  settingTime = cleanSortDates(settingTime)
  settingTime = combineDates(settingTime)
  var final = convertToMinutes(settingTime)
  return final
}

const returnAvgTime = historicalRoutes => {
  var timeSeries = returnSettingTime(historicalRoutes)
  var keys = Object.keys(timeSeries[0]).reduce((carry, item) => {
    if (item != 'key') {
      carry.push(item)
    }
    return carry
  }, [])
  var verification = keys.reduce((carry, value) => {
    carry[value] = 0
    return carry
  }, {})
  timeSeries.forEach(element => {
    for (const [key, value] of Object.entries(element)) {
      if (key != 'key') {
        verification[key] += value
      }
    }
  })
  return verification
}

const combineDates = data => {
  const result = data.reduce((carry, datum, index) => {
    var dateObj = new Date(datum.key)
    // var newdate = dayjs(dateObj).format('YYYY-MM-DD');
    // var newdate = new Date(date)
    datum.key = dateObj
    if (index > 0) {
      if (datum.key == data[index - 1].key) {
        datum.values.reduce((carry, item) => {
          const temp = data[index - 1].values.filter(thing => {
            return thing.key === item.key
          })
          item.value += temp[0].value
          carry.push({ key: item.key, value: item.value })
          return carry
        }, [])
        carry.pop()
      }
    }
    carry.push(datum)
    return carry
  }, [])
  return result
}

const returnNumRoutes = historicalRoutes => {
  let nodes = { parent: 'date', target: 'risk' }
  var routes = returnNest(historicalRoutes, nodes, 1)
  // replace value with proper descriptor
  var result = []
  routes.forEach(item => {
    result.push({
      key: item.key,
      numRoutes: item.value,
    })
  })
  result = cleanSortDates(result)
  return result
}

const ricOverTime = (defaultFields, historicalRoutes) => {
  let ricKeys = defaultFields['risk'].reduce((carry, element) => {
    carry.push(element.key)
    return carry
  }, [])
  let riskNodes = { parent: 'date', target: 'risk' }
  var risk = returnNest(historicalRoutes, riskNodes, 2)
  risk = fillMissingKeys(risk, ricKeys)
  let intensityNodes = { parent: 'date', target: 'intensity' }
  var intensity = returnNest(historicalRoutes, intensityNodes, 2)
  intensity = fillMissingKeys(intensity, ricKeys)
  let complexityNodes = { parent: 'date', target: 'complexity' }
  var complexity = returnNest(historicalRoutes, complexityNodes, 2)
  complexity = fillMissingKeys(complexity, ricKeys)
  // get average over time
  var riskAvg = []
  risk.forEach(item => {
    let total = returnTotal(item.values)
    riskAvg.push({
      key: item.key,
      value: returnRicBias(item.values, total),
    })
  })
  var intensityAvg = []
  intensity.forEach(item => {
    let total = returnTotal(item.values)
    intensityAvg.push({
      key: item.key,
      value: returnRicBias(item.values, total),
    })
  })
  var complexityAvg = []
  complexity.forEach(item => {
    let total = returnTotal(item.values)
    complexityAvg.push({
      key: item.key,
      value: returnRicBias(item.values, total),
    })
  })
  // combine them all into one
  var final = []
  for (let index = 0; index < riskAvg.length; index++) {
    let risk = riskAvg[index].value
    let intensity = intensityAvg[index].value
    let complexity = complexityAvg[index].value
    final.push({ key: riskAvg[index].key, risk, intensity, complexity })
  }
  final = cleanSortDates(final)
  return final
}

const returnRicBias = (array, total) => {
  var avg = array.reduce((carry, item) => {
    carry += (item.value / total) * Number(item.key)
    return carry
  }, 0)
  return avg
}

const returnTotal = array => {
  var total = array.reduce((carry, item) => {
    carry += item.value
    return carry
  }, 0)
  return total
}

const returnFieldOvertime = (field, defaultFields, historicalRoutes) => {
  let fieldNames = defaultFields.reduce((carry, element) => {
    carry.push(element.key)
    return carry
  }, [])
  let nodes = { parent: 'date', target: field }
  var data = returnNest(historicalRoutes, nodes, 2)
  // create ordered object version as well
  var orderedData = []
  for (let index = 0; index < data.length; index++) {
    const element = data[index]
    // Instantiate default values
    const clone = JSON.parse(JSON.stringify(fieldNames))
    for (let index = 0; index < element.values.length; index++) {
      const item = element.values[index]
      const duplicateIndex = clone.indexOf(item.key)
      clone.splice(duplicateIndex, 1)
    }
    for (let index = 0; index < clone.length; index++) {
      const name = clone[index]
      element.values.push({ key: name, value: 0 })
    }
    // add actual values
    for (let index = 0; index < element.values.length; index++) {
      const item = element.values[index]
      let key = item.key
      let value = item.value
      element[key] = value
    }
    // Delete values
    delete element.values
    // sort data, can be custom sorted if its by grade for example
    const ordered = {}
    Object.keys(element)
      .sort()
      .forEach(function(key) {
        ordered[key] = element[key]
      })
    orderedData.push(ordered)
  }
  // data = orderedData;
  data = cleanSortDates(data)
  return data
}

export {
  returnFields,
  returnWallStyles,
  returnAvgWallAge,
  returnAvgWallIntradifficulty,
  returnAvgGradeIntradifficulty,
  returnAvgRouteAge,
  returnRisk,
  returnLength,
  returnComplexity,
  returnIntensity,
  returnHeight,
  returnTechniques,
  returnIntraDifficulty,
  returnHoldtypes,
  returnGrades,
  returnAgeOvertime,
  returnIntradifficultyOvertime,
  returnStyleDiffOvertime,
  returnAvgRiskOvertime,
  returnFieldOvertime,
  ricOverTime,
  returnNumRoutes,
  returnSettingTime,
  returnAvgTime,
}
import * as d3 from 'd3'

const drawLine = (elementId, type, data, canvasSize) => {
  const margin = { top: 20, right: 80, bottom: 30, left: 40, padding: 5 }
  var width = canvasSize.width - margin.left - margin.right,
    height = canvasSize.height - margin.top - margin.bottom
  const max = d3.max(data, d => {
    return d.value
  })
  var x = d3
    .scaleTime()
    .domain(d3.extent(data, d => new Date(d.key)))
    .nice(d3.timeWeek)
    .range([0, width - margin.right])
  var y = d3
    .scaleLinear()
    .domain([0, max])
    .nice()
    .range([height - margin.bottom, margin.top])
  var xAxis = g =>
    g
      .attr('transform', `translate(${margin.left},${height - margin.bottom})`)
      .call(
        d3
          .axisBottom(x)
          .ticks(width / 80)
          .tickSizeOuter(0)
      )
  var yAxis = g =>
    g.attr('transform', `translate(${margin.left},0)`).call(d3.axisLeft(y))
  const svg = d3
    .select(`#${elementId}`)
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
  svg
    .append('text')
    .attr(
      'transform',
      'translate(' + width / 2 + ' ,' + (height + margin.top) + ')'
    )
    .attr('font-size', '14px')
    .style('text-anchor', 'middle')
    .text('Date')
  svg
    .append('text')
    .attr('transform', 'rotate(-90)')
    .attr('y', margin.padding)
    .attr('x', -(height / 2))
    .attr('dy', '1em')
    .attr('font-size', '14px')
    .style('text-anchor', 'middle')
    .text('Number of Routes Created')

  var g = svg
    .append('g')
    .attr('transform', 'translate(' + margin.left + ',' + 0 + ')')
  svg.append('g').call(xAxis)
  svg.append('g').call(yAxis)
  const line = d3
    .line()
    .y(d => {
      return y(d.value)
    })
    .x(d => {
      return x(new Date(d.key))
    })
    .curve(d3.curveMonotoneX)
  g.append('path')
    .attr('fill', 'none')
    .attr('stroke', 'steelblue')
    .attr('stroke-width', 1.5)
    .attr('d', line(data))
  svg
    .append('g')
    .selectAll('.dot')
    .data(data)
    .enter()
    .append('circle')
    .attr('class', 'dot')
    .attr('transform', 'translate(' + margin.left + ',' + 0 + ')')
    .attr('cx', d => {
      return x(new Date(d.key))
    })
    .attr('cy', d => {
      return y(d.value)
    })
    .attr('r', 5)
    .on('mouseout', () => {})
}

const drawTimeLine = (elementId, type, data, canvasSize) => {
  const margin = { top: 20, right: 80, bottom: 30, left: 40, padding: 5 }
  var width = canvasSize.width - margin.left - margin.right,
    height = canvasSize.height - margin.top - margin.bottom
  const max = d3.max(data, d => {
    return d.value
  })
  var x = d3
    .scaleTime()
    .domain(d3.extent(data, d => new Date(d.key)))
    .nice(d3.timeWeek)
    .range([0, width - margin.right])
  var y = d3
    .scaleLinear()
    .domain([0, max])
    .nice()
    .range([height - margin.bottom, margin.top])
  var xAxis = g =>
    g
      .attr('transform', `translate(${margin.left},${height - margin.bottom})`)
      .call(
        d3
          .axisBottom(x)
          .ticks(width / 80)
          .tickSizeOuter(0)
      )
  var yAxis = g =>
    g.attr('transform', `translate(${margin.left},0)`).call(d3.axisLeft(y))
  const svg = d3
    .select(`#${elementId}`)
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
  svg
    .append('text')
    .attr(
      'transform',
      'translate(' + width / 2 + ' ,' + (height + margin.top) + ')'
    )
    .attr('font-size', '14px')
    .style('text-anchor', 'middle')
    .text('Date')
  svg
    .append('text')
    .attr('transform', 'rotate(-90)')
    .attr('y', margin.padding)
    .attr('x', -(height / 2))
    .attr('dy', '1em')
    .attr('font-size', '14px')
    .style('text-anchor', 'middle')
    .text('Number of Routes Created')
  var g = svg
    .append('g')
    .attr('transform', 'translate(' + margin.left + ',' + 0 + ')')
  svg.append('g').call(xAxis)
  svg.append('g').call(yAxis)
  const line = d3
    .line()
    .y(d => {
      return y(d.value)
    })
    .x(d => {
      return x(new Date(d.key))
    })
    .curve(d3.curveMonotoneX)
  g.append('path')
    .attr('fill', 'none')
    .attr('stroke', 'steelblue')
    .attr('stroke-width', 1.5)
    .attr('d', line(data))
  svg
    .append('g')
    .selectAll('.dot')
    .data(data)
    .enter()
    .append('circle')
    .attr('class', 'dot')
    .attr('transform', 'translate(' + margin.left + ',' + 0 + ')')
    .attr('cx', d => {
      return x(new Date(d.key))
    })
    .attr('cy', d => {
      return y(d.value)
    })
    .attr('r', 5)
    .on('mouseout', () => {})
}

export { drawLine, drawTimeLine }
import * as d3 from 'd3'
import { selectColorFn, capitalizeFirstLetter } from '../chartUtils.js'

const pie = d3
  .pie()
  .sort((a, b) => (a.value > b.value ? -1 : a.value < b.value ? 1 : 0))
  .value(d => d.value)

const drawPie = (elementId, type, data, canvasSize) => {
  const arcs = pie(data)
  const radius = canvasSize.width < 900 ? canvasSize.width / 6 : 200
  const labelRadius = radius + 25
  const arc = d3
    .arc()
    .innerRadius(0)
    .outerRadius(radius - 1)
  const svg = d3.select(`#${elementId}`).style('font', '12px sans-serif')
  const g = svg.select('g')

  const color = selectColorFn(type, data)
  g.selectAll('path')
    .data(arcs)
    .enter()
    .append('path')
    .attr('fill', d => color(d.data.key))
    .attr('stroke', 'white')
    .attr('d', arc)
    .append('title')
    .text(d => `${d.data.key}: ${d.data.value.toLocaleString()}`)
  const lines = g
    .selectAll('line')
    .data(arcs)
    .enter()
    .append('line')
    .attr('x1', d => {
      return arc.centroid(d)[0]
    })
    .attr('y1', d => {
      return arc.centroid(d)[1]
    })
    .attr('x2', d => {
      const centroid = arc.centroid(d),
        midAngle = Math.atan2(centroid[1], centroid[0])
      return Math.cos(midAngle) * labelRadius
    })
    .attr('y2', d => {
      const centroid = arc.centroid(d),
        midAngle = Math.atan2(centroid[1], centroid[0])
      return Math.sin(midAngle) * labelRadius
    })
    .attr('class', 'label-line')
    .attr('stroke', d => {
      return color(d.data.key)
    })
  const text = g
    .selectAll('text')
    .data(arcs)
    .enter()
    .append('text')
    .attr('dy', '0.35em')
  text
    .attr('x', d => {
      const centroid = arc.centroid(d)
      const midAngle = Math.atan2(centroid[1], centroid[0])
      const x = Math.cos(midAngle) * labelRadius
      const sign = x > 0 ? 1 : -1
      return x + 5 * sign
    })
    .attr('y', d => {
      const centroid = arc.centroid(d)
      const midAngle = Math.atan2(centroid[1], centroid[0])
      return Math.sin(midAngle) * labelRadius
    })
    .attr('text-anchor', d => {
      const centroid = arc.centroid(d)
      const midAngle = Math.atan2(centroid[1], centroid[0])
      const x = Math.cos(midAngle) * labelRadius
      return x > 0 ? 'start' : 'end'
    })
    .style('font-weight', 'bold')
    .style('font-size', '12pt')
    .text(
      d =>
        `${capitalizeFirstLetter(
          d.data.key
        )} (${d.data.value.toLocaleString()})`
    )

  const alpha = 0.5
  const spacing = 15
  function relax() {
    let again = false
    text.each(function() {
      const a = this
      const da = d3.select(a)
      const y1 = da.attr('y')
      text.each(function() {
        const b = this
        if (a === b) {
          return
        }

        const db = d3.select(b)
        if (da.attr('text-anchor') !== db.attr('text-anchor')) {
          return
        }
        const y2 = db.attr('y')
        const deltaY = y1 - y2

        if (Math.abs(deltaY) > spacing) {
          return
        }

        again = true
        const sign = deltaY > 0 ? 1 : -1
        const adjust = sign * alpha
        da.attr('y', +y1 + adjust)
        db.attr('y', +y2 - adjust)
      })
    })
    if (again) {
      const labelElements = text.nodes()
      lines.attr('y2', function(d, i) {
        const labelForLine = d3.select(labelElements[i])
        return labelForLine.attr('y')
      })
      relax()
    }
  }
  relax()
}

export { pie, drawPie }
import * as d3 from 'd3'

const formatValue = d3.formatPrefix(',.0', 1e3)

const color = d3
  .scaleOrdinal()
  .domain(d3.range(4))
  .range(['#000000', '#FFDD89', '#957244', '#F26223'])

function groupTicks(d, step) {
  const k = (d.endAngle - d.startAngle) / d.value
  return d3.range(0, d.value, step).map(value => {
    return { value: value, angle: value * k + d.startAngle }
  })
}

const drawChord = (elementId, type, data, canvasSize) => {
  const outerRadius = Math.min(canvasSize.width, canvasSize.height) * 0.5 - 30
  const innerRadius = outerRadius - 20
  const arc = d3
    .arc()
    .innerRadius(innerRadius)
    .outerRadius(outerRadius)
  const ribbon = d3.ribbon().radius(innerRadius)

  const svg = d3
    .select(`#${elementId}`)
    .attr('viewBox', [
      -canvasSize.width / 2,
      -canvasSize.height / 2,
      canvasSize.width,
      canvasSize.height,
    ])
    .attr('font-size', 10)
    .attr('font-family', 'sans-serif')

  const chord = d3
    .chord()
    .padAngle(0.05)
    .sortSubgroups(d3.descending)
  const chords = chord(data)
  const group = svg
    .append('g')
    .selectAll('g')
    .data(chords.groups)
    .enter()
    .append('g')

  group
    .append('path')
    .attr('fill', d => color(d.index))
    .attr('stroke', d => d3.rgb(color(d.index)).darker())
    .attr('d', arc)

  const groupTick = group
    .append('g')
    .selectAll('g')
    .data(d => groupTicks(d, 1e3))
    .enter()
    .append('g')
    .attr(
      'transform',
      d =>
        `rotate(${(d.angle * 180) / Math.PI - 90}) translate(${outerRadius},0)`
    )

  groupTick
    .append('line')
    .attr('stroke', '#000')
    .attr('x2', 6)

  groupTick
    .filter(d => d.value % 5e3 === 0)
    .append('text')
    .attr('x', 8)
    .attr('dy', '.35em')
    .attr('transform', d =>
      d.angle > Math.PI ? 'rotate(180) translate(-16)' : null
    )
    .attr('text-anchor', d => (d.angle > Math.PI ? 'end' : null))
    .text(d => formatValue(d.value))

  svg
    .append('g')
    .attr('fill-opacity', 0.67)
    .selectAll('path')
    .data(chords)
    .enter()
    .append('path')
    .attr('d', ribbon)
    .attr('fill', d => color(d.target.index))
    .attr('stroke', d => d3.rgb(color(d.target.index)).darker())

  return svg.node()
}

export { drawChord }
import * as d3 from 'd3'

const partition = data => {
  const root = d3
    .hierarchy(data)
    .sum(d => d.value)
    .sort((a, b) => b.value - a.value)
  return d3.partition().size([2 * Math.PI, root.height + 1])(root)
}

const zoomSunburst = (elementId, type, data, canvasSize) => {
  var { width, height } = canvasSize
  const margin = { top: 60, right: 30, bottom: 30, left: 40 }
  const format = d3.format(',d')
  const radius = width < 500 ? width / 6 : 100
  const arc = d3
    .arc()
    .startAngle(d => d.x0)
    .endAngle(d => d.x1)
    .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
    .padRadius(radius * 1.5)
    .innerRadius(d => d.y0 * radius)
    .outerRadius(d => Math.max(d.y0 * radius, d.y1 * radius - 1))

  const color = d3.scaleOrdinal(
    d3.quantize(d3.interpolateRainbow, data.children.length + 1)
  )
  const root = partition(data)

  root.each(d => (d.current = d))

  const svg = d3
    .select(`#${elementId}`)
    .style('width', '100%')
    .style('height', 'auto')
    .style('font', '10px sans-serif')

  const g = svg
    .append('g')
    .attr('transform', `translate(${width / 2},${height / 2 + margin.top})`)

  const path = g
    .append('g')
    .selectAll('path')
    .data(root.descendants().slice(1))
    .enter()
    .append('path')
    .attr('fill', d => {
      while (d.depth > 1) d = d.parent
      return color(d.data.name)
    })
    .attr('fill-opacity', d =>
      arcVisible(d.current) ? (d.children ? 0.6 : 0.4) : 0
    )
    .attr('d', d => arc(d.current))

  path
    .filter(d => d.children)
    .style('cursor', 'pointer')
    .attr('fill', d => {
      while (d.depth > 1) d = d.parent
      return color(d.data.name)
    })
    .on('click', clicked)

  path.append('title').text(
    d =>
      `${d
        .ancestors()
        .map(d => d.data.name)
        .reverse()
        .join('/')}\n${format(d.value)}`
  )

  const label = g
    .append('g')
    .attr('pointer-events', 'none')
    .attr('text-anchor', 'middle')
    .style('user-select', 'none')
    .selectAll('text')
    .data(root.descendants().slice(1))
    .enter()
    .append('text')
    .attr('dy', '0.35em')
    .attr('fill-opacity', d => +labelVisible(d.current))
    .attr('transform', d => labelTransform(d.current))

    .text(d => d.data.name)

  const parent = g
    .append('circle')
    .datum(root)
    .attr('r', radius)
    .attr('fill', 'none')
    .attr('pointer-events', 'all')
    .on('click', clicked)

  function getAncestors(node) {
    var path = []
    var current = node
    while (current.parent) {
      path.unshift(current)
      current = current.parent
    }
    return path
  }
  function clicked(p) {
    parent.datum(p.parent || root)

    var sequenceArray = getAncestors(p)
    updateBreadcrumbs(sequenceArray)
    root.each(
      d =>
        (d.target = {
          x0:
            Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) *
            2 *
            Math.PI,
          x1:
            Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) *
            2 *
            Math.PI,
          y0: Math.max(0, d.y0 - p.depth),
          y1: Math.max(0, d.y1 - p.depth),
        })
    )

    const t = g.transition().duration(750)
    path
      .transition(t)
      .tween('data', d => {
        const i = d3.interpolate(d.current, d.target)
        return t => (d.current = i(t))
      })
      .filter(function(d) {
        return +this.getAttribute('fill-opacity') || arcVisible(d.target)
      })
      .attr('fill-opacity', d =>
        arcVisible(d.target) ? (d.children ? 0.6 : 0.4) : 0
      )
      .attrTween('d', d => () => arc(d.current))

    label
      .filter(function(d) {
        return +this.getAttribute('fill-opacity') || labelVisible(d.target)
      })
      .transition(t)
      .attr('fill-opacity', d => +labelVisible(d.target))
      .attrTween('transform', d => () => labelTransform(d.current))
  }

  function arcVisible(d) {
    return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0
  }

  function labelVisible(d) {
    return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03
  }

  function labelTransform(d) {
    const x = (((d.x0 + d.x1) / 2) * 180) / Math.PI
    const y = ((d.y0 + d.y1) / 2) * radius
    return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`
  }
  var b = {
    w: 75,
    h: 30,
    s: 3,
    t: 10,
  }

  initializeBreadcrumbTrail()
  function initializeBreadcrumbTrail() {
    d3.select(`#${elementId}`)
      .append('svg:svg')
      .attr('width', width)
      .attr('height', 50)
      .attr('id', 'trail')
  }
  function breadcrumbPoints(d, i) {
    var points = []
    points.push('0,0')
    points.push(b.w + ',0')
    points.push(b.w + b.t + ',' + b.h / 2)
    points.push(b.w + ',' + b.h)
    points.push('0,' + b.h)
    if (i > 0) {
      points.push(b.t + ',' + b.h / 2)
    }
    return points.join(' ')
  }
  function updateBreadcrumbs(nodeArray) {
    var trail = d3
      .select('#trail')
      .selectAll('g')
      .data(nodeArray, function(d) {
        return d.data.name + d.depth
      })
    trail.exit().remove()
    var entering = trail.enter().append('svg:g')

    entering
      .append('svg:polygon')
      .attr('points', breadcrumbPoints)
      .attr('fill', 'lightcoral')

    entering
      .append('svg:text')
      .attr('x', (b.w + b.t) / 2)
      .attr('y', b.h / 2)
      .attr('dy', '0.35em')
      .attr('text-anchor', 'middle')
      .text(function(d) {
        return d.data.name
      })
      .attr('font-weight', 700)
    entering.merge(trail).attr('transform', function(d, i) {
      return 'translate(' + i * (b.w + b.s) + ', 0)'
    })
    d3.select('#trail').style('visibility', '')
  }

  return svg.node()
}

export { zoomSunburst }
import * as d3 from 'd3'

const noDataChart = (id, width, height) => {
  d3.select(`#${id}`)
    .append('g')
    .append('text')
    .attr('font-size', '40px')
    .attr('text-anchor', 'middle')
    .attr('fill', 'black')
    .attr('transform', `translate(${width / 2}, ${height / 2})`)
    .text('No Data')
}

const drawStackedArea = (elementId, type, data, canvasSize) => {
  var { width, height } = canvasSize
  if (data != null) {
    var keys = Object.keys(data[0]).reduce((carry, item) => {
      if (item != 'key') {
        carry.push(item)
      }
      return carry
    }, [])
    var series = d3.stack().keys(keys)(data)
    const color = d3.scaleOrdinal(
      d3.quantize(d3.interpolatePlasma, series.length + 1)
    )
    var yMax = d3.max(series, d => d3.max(d, d => d[1]))
    const legendPadding = Math.ceil(yMax * (keys.length * 0.06))
    const margin = { top: 10, right: 10, bottom: 20, left: 30, add: 70 }

    var area = d3
      .area()
      .x(d => {
        return x(d.data.key)
      })
      .y0(d => y(d[0]))
      .y1(d => y(d[1]))
      .curve(d3.curveStep)

    const xAxis = g =>
      g
        .attr('transform', `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(x).tickSizeOuter(0))
    var x = d3
      .scaleTime()
      .domain(d3.extent(data, d => d.key))
      .range([margin.left, width - margin.right])

    const yAxis = g =>
      g
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(11))
        .call(g => g.select('.domain').remove())

    var y = d3
      .scaleLinear()
      .domain([0, d3.max(series, d => d3.max(d, d => d[1] + legendPadding))])
      .nice()
      .range([height - margin.bottom, margin.top])

    const svg = d3.select(`#${elementId}`).style('font', '12px sans-serif')
    svg
      .select('g')
      .attr('transform', 'translate(' + margin.left + ',' + 0 + ')')

    svg.append('g').call(xAxis)

    svg.append('g').call(yAxis)

    svg
      .append('g')
      .selectAll('path')
      .data(series)
      .enter()
      .append('path')
      .attr('fill', d => color(d.key))
      .attr('d', area)

    svg.append('g').call(xAxis)

    var legend = svg
      .selectAll('.legend')
      .data(color.domain())
      .enter()
      .append('g')
      .attr('class', 'legend')
      .attr('transform', `translate(${margin.left + 20},${margin.top})`)
    legend
      .append('rect')
      .attr('x', 0)
      .attr('y', function(d, i) {
        return 20 * i + 10
      })
      .attr('width', 10)
      .attr('height', 10)
      .style('fill', d => color(d))

    legend
      .append('text')
      .attr('x', 20)
      .attr('dy', '0.75em')
      .attr('y', function(d, i) {
        return 20 * i + 10
      })
      .text(function(d) {
        return d
      })

    legend
      .append('text')
      .attr('x', 0)
      .attr('y', 0)
      .text('Categories')
  } else {
    noDataChart(elementId, width, height)
  }
}

export { drawStackedArea }
import * as d3 from 'd3'
import { selectColorFn } from '../chartUtils.js'

const noDataChart = (id, width, height) => {
  d3.select(`#${id}`)
    .append('g')
    .append('text')
    .attr('font-size', '40px')
    .attr('text-anchor', 'middle')
    .attr('fill', 'black')
    .attr('transform', `translate(${width / 2}, ${height / 2})`)
    .text('No Data')
}

const drawHorizontalBarChart = (elementId, type, data, canvasSize) => {
  var { width, height } = canvasSize
  var backgroundOpacity = 0.2
  var barHeight = 7
  const margin = { top: 10, right: 20, bottom: 20, left: 30, add: 70 }
  const yAxis = g =>
    g
      .attr('transform', `translate(${margin.left},0)`)
      .call(g => g.select('.domain').remove())

  const xAxis = g =>
    g.attr('transform', `translate(0,${height - margin.bottom})`)
  if (data != null) {
    const y = d3
      .scaleBand()
      .domain(data.map(d => d.key))
      .range([margin.bottom, height - margin.top])
      .padding(0.1)
    const x = d3
      .scaleLinear()
      .domain([
        0,
        Math.max(
          d3.max(data, d => d.value),
          1
        ),
      ])
      .nice()
      .range([margin.left, width - (margin.right + 10)])
    const svg = d3.select(`#${elementId}`).style('font', '12px sans-serif')
    svg.select('g').attr('transform', null)
    svg
      .append('linearGradient')
      .attr('id', `gradient-${elementId}`)
      .attr('gradientUnits', 'userSpaceOnUse')
      .attr('x1', margin.left)
      .attr('y1', 0)
      .attr('x2', width - margin.right)
      .attr('y2', 0)
      .selectAll('stop')
      .data([
        { offset: '0%', color: '#steelblue' },
        { offset: '40%', color: 'gray' },
        { offset: '100%', color: 'red' },
      ])
      .enter()
      .append('stop')
      .attr('offset', d => d.offset)
      .attr('stop-color', d => d.color)

    svg
      .append('g')
      .attr('class', 'bar1')
      .selectAll('.bar')
      .data(data)
      .enter()
      .append('rect')
      .attr('y', d => y(d.key))
      .attr('x', () => x(0))
      .attr('width', d => x(d.value) - x(0))
      .attr('height', barHeight)
      .attr('fill', `url(#gradient-${elementId})`)
      .attr('stroke', '#000000')
      .attr('stroke-dasharray', d => {
        const height = y.bandwidth()
        const width = x(0) - x(d.value)
        return `${width + height},${width}`
      })
    svg
      .append('g')
      .attr('class', 'text1')
      .selectAll('text')
      .data(data)
      .enter()
      .append('text')
      .text(d => d.key)
      .attr('text-anchor', 'start')
      .attr('font-size', 14)
      .attr('transform', d => {
        const yTranslation = y(d.key) - y.bandwidth() / 6
        const xTranslation = x(0)
        return `translate(${xTranslation},${yTranslation})`
      })

    svg
      .append('g')
      .attr('class', 'bar2')
      .selectAll('.bar')
      .data(data)
      .enter()
      .append('rect')
      .attr('y', d => y(d.key))
      .attr('x', () => x(0))
      .attr('width', () => width - margin.right * 3)
      .attr('height', barHeight)
      .attr('fill', `url(#gradient-${elementId})`)
      .attr('opacity', backgroundOpacity)
      .attr('stroke', '#000000')
    svg
      .append('g')
      .attr('class', 'text2')
      .selectAll('text')
      .data(data)
      .enter()
      .append('text')
      .text(d => d.value)
      .attr('text-anchor', 'end')
      .attr('font-size', 14)
      .attr('transform', d => {
        const yTranslation = y(d.key) - y.bandwidth() / 6
        const xTranslation = width - margin.right * 2.3
        return `translate(${xTranslation},${yTranslation})`
      })
    svg.append('g').call(xAxis)

    svg.append('g').call(yAxis)
  } else {
    noDataChart(elementId, width, height)
  }
}

const drawBarChart = (elementId, type, data, canvasSize) => {
  const color = d3.scaleOrdinal(
    d3.quantize(d3.interpolateRainbow, data.length + 1)
  )
  const margin = { top: 40, right: 90, bottom: 30, left: 40, add: 70 }
  const yAxis = g =>
    g
      .attr('transform', `translate(${margin.left},0)`)
      .call(d3.axisLeft(y).ticks(d3.max(data, d => d.value)))
      .call(g => g.select('.domain').remove())

  const xAxis = g =>
    g
      .attr('transform', `translate(0,${canvasSize.height - margin.bottom})`)
      .call(d3.axisBottom(x).tickSizeOuter(0))
  const y = d3
    .scaleLinear()
    .domain([0, d3.max(data, d => d.value)])
    .nice()
    .range([canvasSize.height - margin.bottom, margin.top])
  const x = d3
    .scaleBand()
    .domain(data.map(d => d.key))
    .range([margin.left, canvasSize.width - margin.right])
    .padding(0.1)
  const svg = d3.select(`#${elementId}`).style('font', '12px sans-serif')
  const g = svg.select('g').attr('transform', null)
  svg.selectAll('g:not(:first-child)').remove()
  g.selectAll('*').remove()
  g.selectAll('rect')
    .data(data)
    .enter()
    .append('rect')
    .attr('x', d => x(d.key))
    .attr('y', d => y(d.value))
    .attr('height', d => y(0) - y(d.value))
    .attr('fill', d => color(d.key))
    .attr('stroke', '#000000')
    .attr('stroke-dasharray', d => {
      const width = x.bandwidth()
      const height = y(0) - y(d.value)
      return `${width + height},${width}`
    })
    .attr('width', x.bandwidth())
  g.selectAll('text')
    .data(data)
    .enter()
    .append('text')
    .text(d => d.value)
    .attr('text-anchor', 'middle')
    .attr('font-size', 14)
    .attr('transform', d => {
      const xTranslation = x(d.key) + x.bandwidth() / 2
      const yTranslation = y(d.value) - margin.top / 2
      return `translate(${xTranslation} ${yTranslation})`
    })

  svg.append('g').call(xAxis)

  svg.append('g').call(yAxis)
}

const drawGroupBarChart = (elementId, type, data, canvasSize) => {
  const svg = d3.select(`#${elementId}`),
    margin = { top: 20, right: 20, bottom: 30, left: 40 },
    width = canvasSize.width - margin.left - margin.right,
    height = canvasSize.height - margin.top - margin.bottom,
    g = svg
      .select('g')
      .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

  svg.selectAll('g:not(:first-child)').remove()
  g.selectAll('*').remove()
  const x0 = d3
    .scaleBand()
    .rangeRound([0, width])
    .paddingInner(0.1)

  const x1 = d3.scaleBand().padding(0.05)

  const y = d3.scaleLinear().rangeRound([height, 0])

  const z = selectColorFn(type, data)

  if (!data.length) {
    return
  }
  let keys = data.reduce((carry, d) => {
    return [
      ...carry,
      ...d.values.map(t => t.key).filter(key => carry.indexOf(key) < 0),
    ]
  }, [])

  if (type === 'color') {
    keys = [
      'blue',
      'pink',
      'purple',
      'green',
      'yellow',
      'orange',
      'red',
      'grey',
      'black',
      'white',
    ]
  }

  x0.domain(
    data.map(function(d) {
      return d.key
    })
  )

  x1.domain(keys.map((_, i) => i)).rangeRound([0, x0.bandwidth()])

  const maxY = d3.max(data, d => d3.max(d.values, t => t.value)) + 1
  y.domain([0, maxY])

  g.append('g')
    .selectAll('g')
    .data(data)
    .enter()
    .append('g')
    .attr('transform', function(d) {
      return 'translate(' + x0(d.key) + ',0)'
    })
    .selectAll('rect')
    .data(function(d) {
      return d.values.map(function(t) {
        return {
          parentKey: d.key,
          key: t.key,
          value: t.value,
          indexShift: Math.floor((keys.length - d.values.length) / 2),
        }
      })
    })
    .enter()
    .append('rect')
    .attr('x', function(item, i) {
      return x1(i) + (item.indexShift || 0) * x1.bandwidth()
    })
    .attr('y', function(d) {
      return y(d.value)
    })
    .attr('width', x1.bandwidth())
    .attr('height', function(d) {
      return height - y(d.value)
    })
    .attr('fill', function(d) {
      return z(d.key)
    })
    .attr('stroke', d => {
      if (d.key === 'white') {
        return '#000000'
      }
      return null
    })
    .attr('stroke-dasharray', d => {
      const width = x1.bandwidth()
      const height = y(0) - y(d.value)
      return `${width + height},${width}`
    })

  g.append('g')
    .selectAll('g')
    .data(data)
    .enter()
    .append('g')
    .attr('transform', function(d) {
      return 'translate(' + x0(d.key) + ',0)'
    })
    .selectAll('text')
    .data(function(d) {
      return d.values.map(function(t) {
        return {
          parentKey: d.key,
          key: t.key,
          value: t.value,
          indexShift: Math.floor((keys.length - d.values.length) / 2),
        }
      })
    })
    .enter()
    .append('text')
    .text(d => d.value)
    .attr('text-anchor', 'middle')
    .attr('font-size', 14)
    .attr('transform', (d, i) => {
      const xTranslation =
        x1(i) + (d.indexShift || 0) * x1.bandwidth() + x1.bandwidth() / 2
      const yTranslation = y(d.value) - margin.top / 2
      return `translate(${xTranslation} ${yTranslation})`
    })
  g.append('g')
    .attr('class', 'axis')
    .attr('transform', 'translate(0,' + height + ')')
    .call(d3.axisBottom(x0))
  g.append('g')
    .attr('class', 'axis')
    .call(d3.axisLeft(y).ticks(maxY))
    .call(g => g.select('.domain').remove())
    .append('text')
    .attr('x', 2)
    .attr('y', y(y.ticks().pop()) + 0.5)
    .attr('dy', '0.32em')
    .attr('fill', '#000')
    .attr('font-weight', 'bold')
    .attr('text-anchor', 'start')
    .text('Total')
  const legend = g
    .append('g')
    .attr('font-family', 'sans-serif')
    .attr('font-size', 10)
    .attr('text-anchor', 'end')
    .selectAll('g')
    .data(keys.slice().reverse())
    .enter()
    .append('g')
    .attr('transform', function(d, i) {
      return 'translate(0,' + i * 20 + ')'
    })
  legend
    .append('rect')
    .attr('x', width - 19)
    .attr('width', 19)
    .attr('height', 19)
    .attr('fill', z)
  legend
    .append('text')
    .attr('x', width - 24)
    .attr('y', 9.5)
    .attr('dy', '0.32em')
    .text(function(d) {
      return d
    })
}

const drawInteractiveBar = (id, data, canvasSize, nodes, params) => {
  var { width, height } = canvasSize
  const margin = { top: 40, right: 30, bottom: 30, left: 40, add: 70 }

  const color = d3.scaleOrdinal(
    d3.quantize(d3.interpolateViridis, data.length + 1)
  )
  const yAxis = g =>
    g
      .attr('transform', `translate(${margin.left},0)`)
      .call(d3.axisLeft(y).ticks(11))
      .call(g => g.select('.domain').remove())
  const y = d3
    .scaleLinear()
    .domain([
      0,
      d3.max(data, d => {
        if (params.fixedY == true) {
          return params.max
        } else {
          return d.value
        }
      }),
    ])
    .nice()
    .range([height - margin.bottom, margin.top])
  const xAxis = g =>
    g
      .attr('transform', `translate(0,${height - margin.bottom})`)
      .call(d3.axisBottom(x).tickSizeOuter(0))
  const x = d3
    .scaleBand()
    .domain(data.map(d => d[nodes.key]))
    .range([margin.left, width - margin.right])
    .padding(0.1)
  const svg = d3.select(`#${id}`).style('font', '12px sans-serif')
  const g = svg.select('g').attr('transform', null)
  svg
    .append('g')
    .selectAll('rect')
    .data(data)
    .enter()
    .append('rect')
    .attr('x', d => x(d[nodes.key]))
    .attr('y', d => y(d.value))
    .attr('height', d => y(0) - y(d.value))
    .attr('fill', d => color(d[nodes.key]))
    .attr('stroke', '#000000')
    .attr('stroke-dasharray', d => {
      const width = x.bandwidth()
      const height = y(0) - y(d.value)
      return `${width + height},${width}`
    })
    .attr('width', x.bandwidth())

  g.selectAll('text')
    .data(data)
    .enter()
    .append('text')
    .text(d => d.value)
    .attr('text-anchor', 'middle')
    .attr('font-size', 14)
    .attr('transform', d => {
      const xTranslation = x(d[nodes.key]) + x.bandwidth() / 2
      const yTranslation = y(d.value) - margin.top / 2
      return `translate(${xTranslation} ${yTranslation})`
    })
  svg
    .append('g')
    .call(xAxis)
    .selectAll('text')
    .attr('y', 10)
    .attr('x', -5)
    .attr('dy', '.35em')
    .attr('transform', 'rotate(-55)')
    .style('text-anchor', 'end')
  svg.append('g').call(yAxis)
}

const drawNegativeBar = (id, data, canvasSize, nodes, params) => {
  var { width, height } = canvasSize
  const margin = { top: 40, right: 30, bottom: 30, left: 40, add: 70 }
  const yAxis = g =>
    g
      .attr('transform', `translate(${margin.left},0)`)
      .call(d3.axisLeft(y).ticks(11))
      .call(g => g.select('.domain').remove())
  const y = d3
    .scaleLinear()
    .domain([
      d3.min(data, d => d.value - 1),
      d3.max(data, d => {
        if (params.fixedY == true) {
          return params.max
        } else {
          return d.value
        }
      }),
    ])
    .nice()
    .range([height - margin.bottom, margin.top])
  const xAxis = g =>
    g
      .attr('transform', `translate(0,${height - margin.bottom})`)
      .call(d3.axisBottom(x).tickSizeOuter(0))
  const x = d3
    .scaleBand()
    .domain(data.map(d => d[nodes.key]))
    .range([margin.left, width - margin.right])
    .padding(0.1)
  const svg = d3.select(`#${id}`).style('font', '12px sans-serif')
  const g = svg.select('g').attr('transform', null)
  svg
    .append('g')
    .selectAll('rect')
    .data(data)
    .enter()
    .append('rect')
    .attr('x', d => x(d[nodes.key]))
    .attr('y', d => {
      if (d.value > 0) {
        return y(d.value)
      } else {
        return y(0)
      }
    })
    .attr('height', d => Math.abs(y(d.value) - y(0)))
    .attr('fill', d => {
      if (d.value < 0) {
        return 'steelblue'
      } else {
        return 'darkred'
      }
    })
    .attr('stroke', '#000000')
    .attr('width', x.bandwidth())

  g.selectAll('text')
    .data(data)
    .enter()
    .append('text')
    .text(d => d.value)
    .attr('text-anchor', 'middle')
    .attr('font-size', 14)

    .attr('transform', d => {
      const xTranslation = x(d[nodes.key]) + x.bandwidth() / 2
      const yTranslation = y(d.value) - margin.top / 2
      return `translate(${xTranslation} ${yTranslation})`
    })
  svg
    .append('g')
    .call(xAxis)
    .selectAll('text')
    .attr('y', 10)
    .attr('x', -5)
    .attr('dy', '.35em')
    .attr('transform', 'rotate(-55)')
    .style('text-anchor', 'end')
  svg
    .append('g')
    .attr('class', 'y axis')
    .call(yAxis)
  svg
    .append('g')
    .attr('class', 'y axis')
    .append('text')
    .text('Style Frequency')
    .attr('transform', `translate(15, ${height / 1.7}), rotate(-90)`)
  svg
    .append('g')
    .attr('id', 'horizontal-line')
    .append('line')
    .attr('fill', 'none')
    .attr('stroke', '#000')
    .attr('shape-rendering', 'crispEdges')
    .attr('y1', y(0))
    .attr('y2', y(0))
    .attr('x1', margin.left)
    .attr('x2', width)
}

const drawDoubleBar = payload => {
  var {
    id,
    data,
    totalGymRoutes,
    canvasSize,
    nodes,
    params,
    disabled,
  } = payload
  const { updateFn } = payload
  var total = JSON.parse(JSON.stringify(totalGymRoutes))
  var { currentData } = data
  var goalData = JSON.parse(JSON.stringify(data.goalData))
  var combinedData = currentData.concat(goalData)
  var checkGoalSum = goalData.reduce((carry, item) => {
    carry += item.value
    return carry
  }, 0)
  var activeSum = currentData.reduce((carry, item) => {
    carry += item.value
    return carry
  }, 0)
  var { width, height } = canvasSize
  const margin = { top: 40, right: 30, bottom: 30, left: 40, add: 70 }
  const opacity = 0.65
  const backgroundOpacity = 0
  const backgroundColor = 'cyan'
  const foregroundColor = 'dodgerblue'
  width = width - (margin.left + margin.right)
  height = height - (margin.top + margin.bottom)
  var noData
  if (checkGoalSum > 0 || activeSum > 0) {
    noData = true
  } else {
    noData = false
  }
  if (noData == true) {
    var svgY = d3.select(`#${id}`).append('g')
    var yAxis = g =>
      g
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y).ticks(11))
        .call(g => g.select('.domain').remove())
    var y = d3
      .scaleLinear()
      .domain([params.yAxis.start, d3.max(combinedData, d => d.value) + 1])
      .range([height - margin.bottom, margin.top])
    var xAxis = g =>
      g
        .attr('transform', `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(x).tickSizeOuter(0))
    var x = d3
      .scaleBand()
      .domain(goalData.map(d => d[nodes.key]))
      .range([margin.left, width - margin.right])
      .padding(0.1)
    var xLabels = d3
      .scaleBand()
      .domain(goalData.map(d => d[nodes.key]))
      .range([margin.left, width - margin.right])
      .padding(0.1)

    svgY
      .append('g')
      .attr('class', 'bar1')
      .selectAll('.bar')
      .data(currentData)
      .enter()
      .append('rect')
      .attr('x', d => x(d[nodes.key]))
      .attr('y', d => y(d.value))
      .attr('height', d => y(0) - y(d.value))
      .attr('fill', () => backgroundColor)
      .attr('stroke', '#000000')
      .attr('stroke-dasharray', d => {
        const width = x.bandwidth()
        const height = y(0) - y(d.value)
        return `${width + height},${width}`
      })
      .attr('width', x.bandwidth())
      .on('touchstart.zoom', nozoom)
    svgY
      .append('g')
      .attr('class', 'xAxis')
      .call(xAxis)
      .selectAll('text')
      .attr('y', 10)
      .attr('x', 0)
      .attr('dy', '.35em')
      .style('text-anchor', 'middle')
      .call(wrap, x.bandwidth())
    svgY
      .append('g')
      .attr('class', 'yAxis')
      .call(yAxis)
    svgY
      .append('g')
      .attr('class', 'yText')
      .append('text')
      .text('Number of Occurances')
      .attr('transform', `translate(12, ${height / 1.7}), rotate(-90)`)
    if (checkGoalSum > 0) {
      svgY
        .append('g')
        .attr('class', 'bar2')
        .selectAll('.bar')
        .data(goalData)
        .enter()
        .append('rect')
        .attr('x', d => x(d[nodes.key]))
        .attr('y', d => y(d.value))
        .attr('height', d => y(0) - y(d.value))
        .attr('fill', () => foregroundColor)
        .attr('opacity', opacity)
        .attr('stroke', '#000000')
        .attr('stroke-dasharray', d => {
          const width = x.bandwidth()
          const height = y(0) - y(d.value)
          return `${width + height},${width}`
        })
        .attr('width', x.bandwidth())
        .on('touchstart.zoom', nozoom)
      svgY
        .append('g')
        .attr('class', 'bar3')
        .selectAll('.bar')
        .data(combinedData)
        .enter()
        .append('rect')
        .attr('x', d => x(d[nodes.key]))
        .attr('y', () => 0)
        .attr('height', () => y(0))
        .attr('fill', () => 'white')
        .attr('opacity', backgroundOpacity)
        .attr('stroke', '#000000')
        .attr('width', x.bandwidth())
        .on('mousedown', mouseDown)
        .on('touchstart.drag', dragstarted)
        .on('touchstart.zoom', nozoom)
      svgY
        .append('g')
        .attr('class', 'text2')
        .selectAll('.bar')
        .data(goalData)
        .enter()
        .append('text')
        .attr('text-anchor', 'middle')
        .attr('x', d => xLabels(d[nodes.key]) + x.bandwidth() / 2)
        .attr('y', d => y(d.value) - 10)
        .text(d => d.value.toFixed(1))
    }
  } else {
    noDataChart(id, width, height)
  }
  function dragstarted() {
    if (disabled) {
      return
    }
    d3.select(window)
      .on('touchmove', dragged)
      .on('touchend', dragended)
    function dragged() {
      let newY = d3.mouse(d3.event.target)[1]
      if (d3.event.target.outerHTML.indexOf('<rect') == 0) {
        var yDomain = y.domain()
        var yRange = y.range()
        var rangeValue = yRange[0] - yRange[1]
        var domainValue = yDomain[1]
        var newTargetValue = ((400 - newY) / rangeValue) * domainValue
        var diff = d3.event.target.__data__.value - newTargetValue
        if (d3.event.target.__data__.value - diff < 0) {
          d3.event.target.__data__.value = 0
        } else if (d3.event.target.__data__.value - diff > total) {
          d3.event.target.__data__.value = JSON.parse(JSON.stringify(total))
        } else {
          d3.event.target.__data__.value -= diff
        }
        var barName = d3.event.target.__data__[nodes.key]
        var checkSum = goalData.reduce((carry, element) => {
          carry += element.value
          return carry
        }, 0)
        if (checkSum - total != 0) {
          let totalDiff = total - checkSum
          let addAmount = totalDiff / goalData.length
          var remainder = checkSum - d3.event.target.__data__.value
          if (Math.round(remainder) == 0) {
            let leftover = 0
            let nonZero = 0
            goalData.forEach(element => {
              if (element[nodes.key] !== barName) {
                element.value += addAmount
              }
              if (element.value < 0) {
                leftover -= element.value
                element.value = 0
              } else if (element.value > 0) {
                nonZero += 1
              }
            })
            let finalAdditions = leftover / nonZero
            goalData.forEach(element => {
              if (element.value > 0) {
                element.value += finalAdditions
              }
            })
          } else {
            let leftover = 0
            let nonZero = 0
            goalData.forEach(element => {
              if (element[nodes.key] !== barName) {
                element.value += (element.value / remainder) * totalDiff
              }
              if (element.value < 0) {
                leftover -= element.value
                element.value = 0
              } else if (element.value > 0) {
                nonZero += 1
              }
            })
            let finalAdditions = leftover / nonZero
            goalData.forEach(element => {
              if (element.value > 0) {
                element.value += finalAdditions
              }
            })
          }
        }
        let payload = {
          value: goalData,
          goal: id,
        }
        updateFn(payload.value)
        //update graph
        touchUpdate()
      }
    }
    function touchUpdate() {
      var combinedData = currentData.concat(goalData)
      let prevMax = y.domain()[1]
      var max = d3.max(combinedData, d => d.value) + 1
      if (prevMax != max) {
        d3.selectAll(`#${id} > g > g.yAxis`).remove()
        y.domain([params.yAxis.start, max])
        svgY
          .append('g')
          .attr('class', 'yAxis')
          .call(yAxis)
        svgY
          .selectAll('.bar1 > rect')
          .data(currentData)
          .attr('x', d => x(d[nodes.key]))
          .attr('y', d => y(d.value))
          .attr('height', d => y(0) - y(d.value))
          .attr('fill', () => backgroundColor)
          .attr('stroke', '#000000')
          .attr('stroke-dasharray', d => {
            const width = x.bandwidth()
            const height = y(0) - y(d.value)
            return `${width + height},${width}`
          })
      }
      svgY
        .selectAll('.bar3 > rect')
        .data(combinedData)
        .attr('x', d => x(d[nodes.key]))
        .attr('y', () => 0)
        .attr('height', () => y(0))
        .attr('fill', () => 'white')
        .attr('opacity', backgroundOpacity)
        .attr('stroke', '#000000')
      svgY
        .selectAll('.bar2 > rect')
        .data(goalData)
        .attr('x', d => x(d[nodes.key]))
        .attr('y', d => y(d.value))
        .attr('height', d => y(0) - y(d.value))
        .attr('fill', () => foregroundColor)
        .attr('opacity', opacity)
        .attr('stroke', '#000000')
        .attr('stroke-dasharray', d => {
          const width = x.bandwidth()
          const height = y(0) - y(d.value)
          return `${width + height},${width}`
        })
      svgY
        .selectAll('.text2 > text')
        .data(goalData)
        .attr('x', d => xLabels(d[nodes.key]) + x.bandwidth() / 2)
        .attr('y', d => y(d.value) - 10)
        .text(d => d.value.toFixed(1))
    }
    function dragended() {}
  }
  function nozoom() {
    d3.event.preventDefault()
  }

  function mouseDown() {
    if (disabled) {
      return
    }
    var target = d3.select(this).classed('active', true)
    var w = d3
      .select(window)
      .on('mousemove', mouseMove)
      .on('mouseup', mouseUp)
    d3.event.preventDefault()
    function mouseMove() {
      let newY = d3.mouse(d3.event.target)[1]
      if (d3.event.target.outerHTML.indexOf('<rect') == 0) {
        var yDomain = y.domain()
        var yRange = y.range()
        var rangeValue = yRange[0] - yRange[1]
        var domainValue = yDomain[1]
        var targetValue = target._groups[0]['0'].__data__.value
        var newTargetValue = ((400 - newY) / rangeValue) * domainValue
        if (newTargetValue > total) {
          newTargetValue = JSON.parse(JSON.stringify(total))
        }
        var diff = targetValue - newTargetValue
        if (target._groups[0]['0'].__data__.value - diff < 0) {
          target._groups[0]['0'].__data__.value = 0
        } else if (target._groups[0]['0'].__data__.value - diff > total) {
          target._groups[0]['0'].__data__.value = JSON.parse(
            JSON.stringify(total)
          )
        } else {
          target._groups[0]['0'].__data__.value -= diff
        }
        var barName = target._groups[0]['0'].__data__[nodes.key]
        var checkSum = goalData.reduce((carry, element) => {
          carry += element.value
          return carry
        }, 0)
        if (checkSum - total != 0) {
          let totalDiff = total - checkSum
          let addAmount = totalDiff / goalData.length
          var remainder = checkSum - target._groups[0]['0'].__data__.value
          if (Math.round(remainder) == 0) {
            let leftover = 0
            let nonZero = 0
            goalData.forEach(element => {
              if (element[nodes.key] !== barName) {
                element.value += addAmount
              }
              if (element.value < 0) {
                leftover -= element.value
                element.value = 0
              } else if (element.value > 0) {
                nonZero += 1
              }
            })
            let finalAdditions = leftover / nonZero
            goalData.forEach(element => {
              if (element.value > 0) {
                element.value += finalAdditions
              }
            })
          } else {
            let leftover = 0
            let nonZero = 0
            goalData.forEach(element => {
              if (element[nodes.key] !== barName) {
                element.value += (element.value / remainder) * totalDiff
              }
              if (element.value < 0) {
                leftover -= element.value
                element.value = 0
              } else if (element.value > 0) {
                nonZero += 1
              }
            })
            let finalAdditions = leftover / nonZero
            goalData.forEach(element => {
              if (element.value > 0) {
                element.value += finalAdditions
              }
            })
          }
        }
        let payload = {
          value: goalData,
          goal: id,
        }
        updateFn(payload.value)
        //update graph
        update()
      }
    }
    function update() {
      var combinedData = currentData.concat(goalData)
      let prevMax = y.domain()[1]
      var max = d3.max(combinedData, d => d.value) + 1
      if (prevMax != max) {
        d3.selectAll(`#${id} > g > g.yAxis`).remove()
        y.domain([params.yAxis.start, max])
        svgY
          .append('g')
          .attr('class', 'yAxis')
          .call(yAxis)
        svgY
          .selectAll('.bar1 > rect')
          .data(currentData)
          .attr('x', d => x(d[nodes.key]))
          .attr('y', d => y(d.value))
          .attr('height', d => y(0) - y(d.value))
          .attr('fill', () => backgroundColor)
          .attr('stroke', '#000000')
          .attr('stroke-dasharray', d => {
            const width = x.bandwidth()
            const height = y(0) - y(d.value)
            return `${width + height},${width}`
          })
      }
      svgY
        .selectAll('.bar3 > rect')
        .data(combinedData)
        .attr('x', d => x(d[nodes.key]))
        .attr('y', () => 0)
        .attr('height', () => y(0))
        .attr('fill', () => 'white')
        .attr('opacity', backgroundOpacity)
        .attr('stroke', '#000000')
      svgY
        .selectAll('.bar2 > rect')
        .data(goalData)
        .attr('x', d => x(d[nodes.key]))
        .attr('y', d => y(d.value))
        .attr('height', d => y(0) - y(d.value))
        .attr('fill', () => foregroundColor)
        .attr('opacity', opacity)
        .attr('stroke', '#000000')
        .attr('stroke-dasharray', d => {
          const width = x.bandwidth()
          const height = y(0) - y(d.value)
          return `${width + height},${width}`
        })
      svgY
        .selectAll('.text2 > text')
        .data(goalData)
        .attr('x', d => xLabels(d[nodes.key]) + x.bandwidth() / 2)
        .attr('y', d => y(d.value) - 10)
        .text(d => d.value.toFixed(1))
    }
    function mouseUp() {
      target.classed('active', false)
      w.on('mousemove', null).on('mouseup', null)
    }
  }
}

function wrap(text, width) {
  text.each(function() {
    var text = d3.select(this),
      words = text
        .text()
        .split(/\s+/)
        .reverse(),
      word,
      line = [],
      lineNumber = 0,
      lineHeight = 1.1, // ems
      y = text.attr('y'),
      dy = parseFloat(text.attr('dy')),
      tspan = text
        .text(null)
        .append('tspan')
        .attr('x', 0)
        .attr('y', y)
        .attr('dy', dy + 'em')
    while ((word = words.pop())) {
      line.push(word)
      tspan.text(line.join(' '))
      if (tspan.node().getComputedTextLength() > width) {
        line.pop()
        tspan.text(line.join(' '))
        line = [word]
        tspan = text
          .append('tspan')
          .attr('x', 0)
          .attr('y', y)
          .attr('dy', ++lineNumber * lineHeight + dy + 'em')
          .text(word)
      }
    }
  })
}

export {
  drawBarChart,
  drawHorizontalBarChart,
  drawGroupBarChart,
  drawNegativeBar,
  drawInteractiveBar,
  drawDoubleBar,
}
import * as d3 from 'd3'

const color = d3
  .scaleLinear()
  .domain([0, 5])
  .range(['hsl(152,80%,80%)', 'hsl(228,30%,40%)'])
  .interpolate(d3.interpolateHcl)
const zoomBubbles = (elementId, type, data, canvasSize) => {
  const pack = data =>
    d3
      .pack()
      .size([canvasSize.width / 2, canvasSize.height / 2])
      .padding(3)(
      d3
        .hierarchy(data)
        .sum(d => d.value)
        .sort((a, b) => b.value - a.value)
    )
  const root = pack(data)
  let focus = root
  let view

  const svg = d3
    .select(`#${elementId}`)
    .attr(
      'viewBox',
      `-${canvasSize.width / 2} -${canvasSize.height / 2} ${canvasSize.width} ${
        canvasSize.height
      }`
    )
    .on('click', () => zoom(root))

  const node = svg
    .append('g')
    .selectAll('circle')
    .data(root.descendants().slice(1))
    .enter()
    .append('circle')
    .attr('fill', d => (d.children ? color(d.depth) : 'white'))
    .attr('pointer-events', d => (!d.children ? 'none' : null))
    .on('mouseover', function() {
      d3.select(this).attr('stroke', '#000')
    })
    .on('mouseout', function() {
      d3.select(this).attr('stroke', null)
    })
    .on('click', d => focus !== d && (zoom(d), d3.event.stopPropagation()))

  const label = svg
    .append('g')
    .style('font', '10px sans-serif')
    .attr('pointer-events', 'none')
    .attr('text-anchor', 'middle')
    .selectAll('text')
    .data(root.descendants())
    .enter()
    .append('text')
    .style('fill-opacity', d => (d.parent === root ? 1 : 0))
    .style('display', d => (d.parent === root ? 'inline' : 'none'))
    .text(d => d.data.name)

  zoomTo([root.x, root.y, root.r * 2])

  function zoomTo(v) {
    const k = canvasSize.height / v[2]
    view = v
    label.attr(
      'transform',
      d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`
    )
    node.attr(
      'transform',
      d => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`
    )
    node.attr('r', d => d.r * k)
  }

  function zoom(d) {
    focus = d

    const transition = svg
      .transition()
      .duration(d3.event.altKey ? 7500 : 750)
      .tween('zoom', () => {
        const i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2])
        return t => zoomTo(i(t))
      })

    label
      .filter(function(d) {
        return d.parent === focus || this.style.display === 'inline'
      })
      .transition(transition)
      .style('fill-opacity', d => (d.parent === focus ? 1 : 0))
      .on('start', function(d) {
        if (d.parent === focus) this.style.display = 'inline'
      })
      .on('end', function(d) {
        if (d.parent !== focus) this.style.display = 'none'
      })
  }

  return svg.node()
}

export { zoomBubbles }
import { nest } from 'd3'
import {
  returnSortByGrade,
  returnSortByCustom,
  returnSortByKey,
  returnSortByValue,
  getAverage,
  sumValue,
  dateDiffInDays,
  cleanRoutes,
  sliceRoutes,
} from './dataUtils'
import {
  returnRisk,
  returnLength,
  returnComplexity,
  returnIntensity,
  returnHeight,
  returnTechniques,
  returnGrades,
} from './dataRetrieval'

const convertToMinutes = timeData => {
  const keys = ['skeleton', 'setter forerun', 'group forerun', 'finished']
  for (let index = 0; index < timeData.length; index++) {
    const element = timeData[index]
    keys.forEach(key => {
      element[key] = Math.floor(element[key] / 60)
    })
  }
  return timeData
}

const formatFields = string => {
  if (/(?=[A-Z])/.test(string)) {
    let temp = string.split(/(?=[A-Z])/)
    return temp[0].charAt(0).toUpperCase() + temp[0].slice(1) + ' ' + temp[1]
  } else {
    return string.charAt(0).toUpperCase() + string.slice(1)
  }
}
// Replaces and obj key with another
const replaceKey = (arr, old_key, new_key) => {
  arr.forEach(field => {
    if (Object.keys(field)[0] !== new_key) {
      Object.defineProperty(
        field,
        new_key,
        Object.getOwnPropertyDescriptor(field, old_key)
      )
      delete field[old_key]
    }
  })
  return arr
}

// Used for filling time data (level 2 in node)
const fillMissingKeys = (arr, fields) => {
  arr.forEach(element => {
    fields.forEach(key => {
      for (let index = 0; index < element.values.length; index++) {
        if (element.values[index].key == key) {
          break
        } else if (index == element.values.length - 1) {
          element.values.push({ key: key, value: 0 })
        }
      }
    })
  })
  return arr
}

const missingKeys = (arr, fields) => {
  // check for fields that don't exist in defaultFields (old values that haven't been deleted)
  for (var j = 0; j < fields.length; j++) {
    for (var i = 0; i < arr.length; i++) {
      if (fields[j] == arr[i].key) {
        break
      } else if (i == arr.length - 1) {
        // field not present
        if (typeof fields[j] === 'number') {
          arr.push({ key: JSON.stringify(fields[j]), value: 0 })
        } else {
          arr.push({ key: fields[j], value: 0 })
        }
      }
    }
  }
  const final_arr = arr.filter(item => {
    if (item.key !== 'undefined' && item.key !== 'null') {
      return item
    }
  })
  return final_arr
}

const returnAverageGoals = (routeDetails, defaultFields) => {
  var fieldObj = returnDefaultFieldObject(defaultFields)
  Object.keys(routeDetails).forEach(field => {
    routeDetails[field].forEach(dataInstance => {
      fieldObj[field].forEach(objInstance => {
        if (dataInstance.name) {
          if (dataInstance.name == objInstance.name) {
            objInstance.value = dataInstance.value
          }
        } else {
          if (dataInstance.key == objInstance.key) {
            objInstance.value = dataInstance.value
          }
        }
      })
    })
  })

  Object.keys(fieldObj).forEach(type => {
    var total = fieldObj[type].reduce((carry, element) => {
      carry += element.value
      return carry
    }, 0)
    fieldObj[type].forEach(element => {
      element.value = total / fieldObj[type].length
    })
  })
  return fieldObj
}

const returnAverageRouteGoals = (routes, defaultFields) => {
  var risk = returnRisk(routes, defaultFields.risk)
  var length = returnLength(routes, defaultFields.length)
  var grade = returnGrades(routes, defaultFields.grade)
  var techniques = returnTechniques(routes, defaultFields.techniques)
  var height = returnHeight(routes, defaultFields.height)
  var intensity = returnIntensity(routes, defaultFields.intensity)
  var complexity = returnComplexity(routes, defaultFields.complexity)
  var data = {
    risk,
    length,
    grade,
    techniques,
    height,
    intensity,
    complexity,
  }
  var fieldObj = returnDefaultFieldObject(defaultFields)
  Object.keys(data).forEach(field => {
    data[field].forEach(dataInstance => {
      fieldObj[field].forEach(objInstance => {
        if (dataInstance.name) {
          if (dataInstance.name == objInstance.name) {
            objInstance.value = dataInstance.value
          }
        } else {
          if (dataInstance.key == objInstance.key) {
            objInstance.value = dataInstance.value
          }
        }
      })
    })
  })
  Object.keys(fieldObj).forEach(type => {
    let total = fieldObj[type].reduce((carry, element) => {
      carry += element.value
      return carry
    }, 0)
    fieldObj[type].forEach(element => {
      element.value = total / fieldObj[type].length
    })
  })
  return fieldObj
}

const returnDefaultFieldObject = defaultFields => {
  var fieldObj = {
    techniques: [],
    grade: [],
    length: [],
    risk: [],
    height: [],
    intensity: [],
    complexity: [],
  }
  const keys = [
    'techniques',
    'grade',
    'length',
    'risk',
    'height',
    'intensity',
    'complexity',
  ]
  keys.forEach(field => {
    defaultFields[field].forEach(instance => {
      if (Number.isInteger(instance)) {
        fieldObj[field].push({ key: JSON.stringify(instance), value: 0 })
      } else {
        fieldObj[field].push({ key: instance, value: 0 })
      }
    })
  })
  return fieldObj
}

const returnAverageByLocation = (activeRoutes, location, defaultFields) => {
  let routes = sliceRoutes(activeRoutes, location)
  return returnAverageRouteGoals(routes, defaultFields)
}
// For returning data in the form Parent Nodes -> Name,Children:Array -> leaf nodes Name,value
const nest2d = (routes, obj, params) => {
  routes.forEach(route => {
    let target = route[params.parent]
    // let parent = params.parent;
    obj.forEach(obj => {
      if (obj.name == target) {
        // params.child.forEach(value => {
        route[params.target].forEach(value => {
          let found = false
          if (obj.children.length != 0) {
            obj.children.forEach((child, index) => {
              // check for match
              if (child.name == value) {
                // match
                child.value++
                found = true
              } else if (index == obj.children.length - 1 && found == false) {
                // no match
                obj.children.push({ [params.leaf]: value, value: 1 })
              }
            })
          } else {
            // if no children
            obj.children.push({ [params.leaf]: value, value: 1 })
          }
        })
      }
    })
  })
  return
}

const returnMaxAge = routes => {
  let newRoutes = cleanRoutes(routes, 'date')
  let today = new Date()
  var maxAge = 0
  newRoutes.forEach(route => {
    let dayDiff = Number(dateDiffInDays(today, new Date(route.date)))
    if (dayDiff > maxAge) {
      maxAge = dayDiff
    }
  })
  return maxAge
}

const returnAverageAge = routes => {
  let newRoutes = cleanRoutes(routes, 'date')
  let today = new Date()
  let count = 0
  let averageAge = newRoutes.reduce((carry, route) => {
    count++
    let dayDiff = dateDiffInDays(today, new Date(route.date))
    carry += Number(dayDiff)
    return carry
  }, 0)
  averageAge = averageAge / count
  return averageAge
}

const returnOldDates = (locationObj, activeRoutes, params) => {
  let today = new Date()
  activeRoutes.forEach(element => {
    locationObj.forEach(location => {
      if (location[params.leaf] == element.location) {
        let dayDiff = dateDiffInDays(today, new Date(element.date))
        location.count += 1
        location.value += dayDiff
        location.routes.push(element)
      }
    })
  })
  locationObj.forEach(location => {
    if (location.count > 0) {
      location.value = location.value / location.count
    }
  })
  return locationObj
}

const returnAverages = (locationObj, activeRoutes, params) => {
  activeRoutes.forEach(element => {
    locationObj.forEach(location => {
      if (location[params.leaf] == element.location) {
        location.count += 1
        location.value += element[params.target]
        location.routes.push(element)
      }
    })
  })
  locationObj.forEach(location => {
    if (location.count > 0) {
      location.value = location.value / location.count
    }
  })
  return locationObj
}

// For counting instances of Style and Techniques (arrays). params.leaf dictats how the leaf value field is named
const trackOccurances = (routes, params) => {
  // Assert that field exists.
  if (routes[0][params.target]) {
    let occurances = []
    routes.forEach(route => {
      let target = route[params.target]
      target.forEach(value => {
        let found = false
        if (occurances.length != 0) {
          occurances.forEach((stored, idx) => {
            if (stored[params.leaf] == value) {
              stored.value++
              found = true
            } else if (idx == occurances.length - 1 && found == false) {
              occurances.push({ [params.leaf]: value, value: 1 })
            }
          })
        } else {
          occurances.push({ [params.leaf]: value, value: 1 })
        }
      })
    })
    return occurances
  } else {
    return {}
  }
}

const returnNest = (data, nodes, levels) => {
  let nestedData
  switch (levels) {
    case 1:
      nestedData = nest()
        .key(d => {
          return d[nodes.parent]
        })
        .rollup(leaves => {
          return leaves.length
        })
        .entries(data)
      break
    case 2:
      nestedData = nest()
        .key(d => {
          return d[nodes.parent]
        })
        .key(d => {
          return d[nodes.target]
        })
        .rollup(leaves => {
          return leaves.length
        })
        .entries(data)
      break
  }
  return nestedData
}

const returnOccurances = (data, params) => {
  let occurances = trackOccurances(data, params)
  occurances = returnSortByCustom(occurances, 'value')
  return occurances
}

const returnObjMap = (obj, data, params) => {
  let targetObj = obj.map(element => {
    return { [params.leaf]: element, children: [] }
  })
  nest2d(data, targetObj, {
    parent: params.parent,
    target: params.target,
    leaf: params.leaf,
  })
  return targetObj
}

// Function that grabs the requisite data for populating the chart
const getD3data = (routes, params) => {
  var { nodes, dataType, targetType, outputDimension } = params
  let data
  if (outputDimension == 1) {
    if (dataType == 'average' && nodes.target == 'intraDifficulty') {
      // 1d average of 2d structure.
      let temp = returnNest(routes, nodes, 2)
      data = temp.map(grade => {
        return { key: grade.key }
      })
      temp.forEach((route, index) => {
        var sum = sumValue(route)
        var average = getAverage(route)
        data[index].value = (average / sum).toFixed(2)
      })
      data = returnSortByGrade(data, { key: 'key' })
    } else if (targetType == 'array' && dataType == 'count') {
      // Pie chart data for techniques
      data = trackOccurances(routes, nodes)
      data = returnSortByValue(data)
    } else if (nodes.parent == 'date') {
      // Line data
      data = returnNest(routes, nodes, 1)
      // clean out undefined dates
      data = data.reduce((carry, route) => {
        if (route.key !== 'undefined') {
          carry.push(route)
        }
        return carry
      }, [])
      // sort by date
      data = returnSortByKey(data)
    } else {
      // Number of Grades by color
      data = returnNest(routes, nodes, 1)
      data = returnSortByGrade(data, { key: 'key' })
    }
  } else {
    if (targetType == 'number') {
      // GroupBar grades by setters
      let temp = returnNest(routes, nodes, 2)
      if (Array.isArray(params.setters)) {
        data = temp.reduce((carry, obj) => {
          params.setters.forEach(setter => {
            if (obj.key == setter) {
              // obj.values = returnSortByValue(obj.values);

              obj.values = returnSortByGrade(obj.values, { key: 'key' })
              carry.push(obj)
            }
          })
          return carry
        }, [])
      } else {
        temp.forEach(setter => {
          if (setter.key == params.setters) {
            // setter.values = returnSortByValue(setter.values);
            setter.values = returnSortByGrade(setter.values, { key: 'key' })
            data = [setter]
          }
        })
      }
    } else {
      // Sunburst, triple nested data for styles by allroutes,setter,grade
      let grades = returnGrades()
      const gradeChildren = grades.map(grade => {
        return { name: grade, children: [] }
      })
      const dataObj = { name: 'By Grade' }
      nest2d(routes, gradeChildren, {
        parent: 'grade',
        target: 'style',
        leaf: 'name',
      })
      dataObj.children = gradeChildren
      let byGrade = dataObj
      byGrade.children = returnSortByGrade(byGrade.children, { key: 'name' })
      const bySetter = params.setters.map(setter => {
        return { name: setter, children: [] }
      })
      nest2d(routes, bySetter, {
        parent: 'setter',
        target: 'style',
        leaf: 'name',
      })
      let allRoutes = trackOccurances(routes, {
        parent: 'grade',
        target: 'style',
        leaf: 'name',
      })
      data = {
        name: 'Styles',
        children: [
          { name: 'All Routes', children: allRoutes },
          byGrade,
          { name: 'By Setter', children: bySetter },
        ],
      }
    }
  }
  return data
}

export {
  getD3data,
  trackOccurances,
  nest2d,
  returnNest,
  returnSortByCustom,
  returnObjMap,
  returnOccurances,
  returnOldDates,
  returnAverages,
  returnAverageAge,
  returnAverageByLocation,
  returnAverageGoals,
  returnMaxAge,
  replaceKey,
  missingKeys,
  fillMissingKeys,
  formatFields,
  convertToMinutes,
}
import {
  interpolateSpectral,
  scaleOrdinal,
  quantize,
  selectAll,
  select,
  piecewise,
  interpolateHsl,
} from 'd3'

const differenceColors = [
  '#EFB605',
  '#E9A501',
  '#E48405',
  '#E34914',
  '#DE0D2B',
  '#CF003E',
]

const differenceFunc = color => {
  return piecewise(interpolateHsl, differenceColors)(color)
}

const capitalizeFirstLetter = str => {
  return `${str.charAt(0).toUpperCase()}${str.slice(1)}`
}

const elevationColors = {
  blue: '#3457a7',
  pink: '#ea0a8c',
  purple: '#91288d',
  green: '#8ec640',
  yellow: '#fcee21',
  orange: '#f79520',
  red: '#ec2027',
  grey: '#808285',
  black: '#231f20',
  white: '#ffffff',
}

const removeGraphs = () => {
  selectAll('g > *').remove()
}
const removeGraph = elementId => {
  // for removing previous bar charts
  selectAll(`#${elementId} > g > *`).remove()
  // selectAll(`#${elementId} > g:nth-child(1) > rect`).remove();
  selectAll(`#${elementId} > g:nth-child(2) > path`).remove()
  selectAll(`#${elementId} > g:nth-child(2) > tick`).remove()
  selectAll(`#${elementId} > g:nth-child(3) > tick`).remove()
  //In case of previous graph using viewbox
  select(`#${elementId}`).attr('viewBox', null)
  //For removing lines
  select(`#${elementId} > svg`).remove()
  selectAll(`#${elementId} > text`).remove()
  selectAll(`#${elementId} > styles > *`).remove()
  select(`#${elementId} > circle > *`).remove()
  selectAll(`#${elementId} > g > legend`).remove()
}

const removeGraphV2 = elementId => {
  selectAll(`#${elementId} > *`).remove()
}

const removeTicks = elementId => {
  // for removing bar tick marks
  select(`#${elementId} > g:nth-child(3)`).remove()
  select(`#${elementId} > g:nth-child(2)`).remove()
  // for removing previous pie charts
  selectAll(`#${elementId} > g:nth-child(1) > path`).remove()
  selectAll(`#${elementId} > g > text`).remove()
  selectAll(`#${elementId} > g > *`).remove()
  //In case of previous graph using viewbox
  select(`#${elementId}`).attr('viewBox', null)
  //For removing lines
  select(`#${elementId} > svg`).remove()
  selectAll(`#${elementId} > text`).remove()
  selectAll(`#${elementId} > styles > *`).remove()
  select(`#${elementId} > circle > *`).remove()
}

const selectColorFn = (type, data = []) => {
  let color = scaleOrdinal()
    .domain(data.map(d => d.key))
    .range(
      quantize(t => interpolateSpectral(t * 0.8 + 0.1), data.length).reverse()
    )

  if (type === 'color') {
    color = key => {
      return elevationColors[key]
    }
  }
  return color
}

// Create customized gradient
function createGradient(idName, endPerc, tag) {
  var coloursRainbow = [
    '#EFB605',
    '#E9A501',
    '#E48405',
    '#E34914',
    '#DE0D2B',
    '#CF003E',
    '#B90050',
    '#A30F65',
    '#8E297E',
    '#724097',
    '#4F54A8',
    '#296DA4',
    '#0C8B8C',
    '#0DA471',
    '#39B15E',
    '#7EB852',
  ]

  tag
    .append('linearGradient')
    .attr('id', idName)
    .attr('gradientUnits', 'userSpaceOnUse')
    .attr('x1', '0%')
    .attr('y1', '0%')
    .attr('x2', endPerc)
    .attr('y2', '0%')
    .selectAll('stop')
    .data(coloursRainbow)
    .enter()
    .append('stop')
    .attr('offset', function(d, i) {
      return i / (coloursRainbow.length - 1)
    })
    .attr('stop-color', function(d) {
      return d
    })
}

export {
  createGradient,
  selectColorFn,
  capitalizeFirstLetter,
  elevationColors,
  removeGraphs,
  removeGraph,
  removeTicks,
  removeGraphV2,
  differenceFunc,
}
const sunData = {
  name: 'flare',
  children: [
    {
      name: 'analytics',
      children: [
        {
          name: 'cluster',
          children: [
            { name: 'AgglomerativeCluster', value: 3938 },
            { name: 'CommunityStructure', value: 3812 },
            { name: 'HierarchicalCluster', value: 6714 },
            { name: 'MergeEdge', value: 743 }
          ]
        },
        {
          name: 'graph',
          children: [
            { name: 'BetweennessCentrality', value: 3534 },
            { name: 'LinkDistance', value: 5731 },
            { name: 'MaxFlowMinCut', value: 7840 },
            { name: 'ShortestPaths', value: 5914 },
            { name: 'SpanningTree', value: 3416 }
          ]
        },
        {
          name: 'optimization',
          children: [{ name: 'AspectRatioBanker', value: 7074 }]
        }
      ]
    },
    {
      name: 'animate',
      children: [
        { name: 'Easing', value: 17010 },
        { name: 'FunctionSequence', value: 5842 },
        {
          name: 'interpolate',
          children: [
            { name: 'ArrayInterpolator', value: 1983 },
            { name: 'ColorInterpolator', value: 2047 },
            { name: 'DateInterpolator', value: 1375 },
            { name: 'Interpolator', value: 8746 },
            { name: 'MatrixInterpolator', value: 2202 },
            { name: 'NumberInterpolator', value: 1382 },
            { name: 'ObjectInterpolator', value: 1629 },
            { name: 'PointInterpolator', value: 1675 },
            { name: 'RectangleInterpolator', value: 2042 }
          ]
        },
        { name: 'ISchedulable', value: 1041 },
        { name: 'Parallel', value: 5176 },
        { name: 'Pause', value: 449 },
        { name: 'Scheduler', value: 5593 },
        { name: 'Sequence', value: 5534 },
        { name: 'Transition', value: 9201 },
        { name: 'Transitioner', value: 19975 },
        { name: 'TransitionEvent', value: 1116 },
        { name: 'Tween', value: 6006 }
      ]
    },
    {
      name: 'data',
      children: [
        {
          name: 'converters',
          children: [
            { name: 'Converters', value: 721 },
            { name: 'DelimitedTextConverter', value: 4294 },
            { name: 'GraphMLConverter', value: 9800 },
            { name: 'IDataConverter', value: 1314 },
            { name: 'JSONConverter', value: 2220 }
          ]
        },
        { name: 'DataField', value: 1759 },
        { name: 'DataSchema', value: 2165 },
        { name: 'DataSet', value: 586 },
        { name: 'DataSource', value: 3331 },
        { name: 'DataTable', value: 772 },
        { name: 'DataUtil', value: 3322 }
      ]
    },
    {
      name: 'display',
      children: [
        { name: 'DirtySprite', value: 8833 },
        { name: 'LineSprite', value: 1732 },
        { name: 'RectSprite', value: 3623 },
        { name: 'TextSprite', value: 10066 }
      ]
    },
    {
      name: 'flex',
      children: [{ name: 'FlareVis', value: 4116 }]
    },
    {
      name: 'physics',
      children: [
        { name: 'DragForce', value: 1082 },
        { name: 'GravityForce', value: 1336 },
        { name: 'IForce', value: 319 },
        { name: 'NBodyForce', value: 10498 },
        { name: 'Particle', value: 2822 },
        { name: 'Simulation', value: 9983 },
        { name: 'Spring', value: 2213 },
        { name: 'SpringForce', value: 1681 }
      ]
    },
    {
      name: 'query',
      children: [
        { name: 'AggregateExpression', value: 1616 },
        { name: 'And', value: 1027 },
        { name: 'Arithmetic', value: 3891 },
        { name: 'Average', value: 891 },
        { name: 'BinaryExpression', value: 2893 },
        { name: 'Comparison', value: 5103 },
        { name: 'CompositeExpression', value: 3677 },
        { name: 'Count', value: 781 },
        { name: 'DateUtil', value: 4141 },
        { name: 'Distinct', value: 933 },
        { name: 'Expression', value: 5130 },
        { name: 'ExpressionIterator', value: 3617 },
        { name: 'Fn', value: 3240 },
        { name: 'If', value: 2732 },
        { name: 'IsA', value: 2039 },
        { name: 'Literal', value: 1214 },
        { name: 'Match', value: 3748 },
        { name: 'Maximum', value: 843 },
        {
          name: 'methods',
          children: [
            { name: 'add', value: 593 },
            { name: 'and', value: 330 },
            { name: 'average', value: 287 },
            { name: 'count', value: 277 },
            { name: 'distinct', value: 292 },
            { name: 'div', value: 595 },
            { name: 'eq', value: 594 },
            { name: 'fn', value: 460 },
            { name: 'gt', value: 603 },
            { name: 'gte', value: 625 },
            { name: 'iff', value: 748 },
            { name: 'isa', value: 461 },
            { name: 'lt', value: 597 },
            { name: 'lte', value: 619 },
            { name: 'max', value: 283 },
            { name: 'min', value: 283 },
            { name: 'mod', value: 591 },
            { name: 'mul', value: 603 },
            { name: 'neq', value: 599 },
            { name: 'not', value: 386 },
            { name: 'or', value: 323 },
            { name: 'orderby', value: 307 },
            { name: 'range', value: 772 },
            { name: 'select', value: 296 },
            { name: 'stddev', value: 363 },
            { name: 'sub', value: 600 },
            { name: 'sum', value: 280 },
            { name: 'update', value: 307 },
            { name: 'variance', value: 335 },
            { name: 'where', value: 299 },
            { name: 'xor', value: 354 },
            { name: '_', value: 264 }
          ]
        },
        { name: 'Minimum', value: 843 },
        { name: 'Not', value: 1554 },
        { name: 'Or', value: 970 },
        { name: 'Query', value: 13896 },
        { name: 'Range', value: 1594 },
        { name: 'StringUtil', value: 4130 },
        { name: 'Sum', value: 791 },
        { name: 'Variable', value: 1124 },
        { name: 'Variance', value: 1876 },
        { name: 'Xor', value: 1101 }
      ]
    },
    {
      name: 'scale',
      children: [
        { name: 'IScaleMap', value: 2105 },
        { name: 'LinearScale', value: 1316 },
        { name: 'LogScale', value: 3151 },
        { name: 'OrdinalScale', value: 3770 },
        { name: 'QuantileScale', value: 2435 },
        { name: 'QuantitativeScale', value: 4839 },
        { name: 'RootScale', value: 1756 },
        { name: 'Scale', value: 4268 },
        { name: 'ScaleType', value: 1821 },
        { name: 'TimeScale', value: 5833 }
      ]
    },
    {
      name: 'util',
      children: [
        { name: 'Arrays', value: 8258 },
        { name: 'Colors', value: 10001 },
        { name: 'Dates', value: 8217 },
        { name: 'Displays', value: 12555 },
        { name: 'Filter', value: 2324 },
        { name: 'Geometry', value: 10993 },
        {
          name: 'heap',
          children: [
            { name: 'FibonacciHeap', value: 9354 },
            { name: 'HeapNode', value: 1233 }
          ]
        },
        { name: 'IEvaluable', value: 335 },
        { name: 'IPredicate', value: 383 },
        { name: 'IValueProxy', value: 874 },
        {
          name: 'math',
          children: [
            { name: 'DenseMatrix', value: 3165 },
            { name: 'IMatrix', value: 2815 },
            { name: 'SparseMatrix', value: 3366 }
          ]
        },
        { name: 'Maths', value: 17705 },
        { name: 'Orientation', value: 1486 },
        {
          name: 'palette',
          children: [
            { name: 'ColorPalette', value: 6367 },
            { name: 'Palette', value: 1229 },
            { name: 'ShapePalette', value: 2059 },
            { name: 'SizePalette', value: 2291 }
          ]
        },
        { name: 'Property', value: 5559 },
        { name: 'Shapes', value: 19118 },
        { name: 'Sort', value: 6887 },
        { name: 'Stats', value: 6557 },
        { name: 'Strings', value: 22026 }
      ]
    },
    {
      name: 'vis',
      children: [
        {
          name: 'axis',
          children: [
            { name: 'Axes', value: 1302 },
            { name: 'Axis', value: 24593 },
            { name: 'AxisGridLine', value: 652 },
            { name: 'AxisLabel', value: 636 },
            { name: 'CartesianAxes', value: 6703 }
          ]
        },
        {
          name: 'controls',
          children: [
            { name: 'AnchorControl', value: 2138 },
            { name: 'ClickControl', value: 3824 },
            { name: 'Control', value: 1353 },
            { name: 'ControlList', value: 4665 },
            { name: 'DragControl', value: 2649 },
            { name: 'ExpandControl', value: 2832 },
            { name: 'HoverControl', value: 4896 },
            { name: 'IControl', value: 763 },
            { name: 'PanZoomControl', value: 5222 },
            { name: 'SelectionControl', value: 7862 },
            { name: 'TooltipControl', value: 8435 }
          ]
        },
        {
          name: 'data',
          children: [
            { name: 'Data', value: 20544 },
            { name: 'DataList', value: 19788 },
            { name: 'DataSprite', value: 10349 },
            { name: 'EdgeSprite', value: 3301 },
            { name: 'NodeSprite', value: 19382 },
            {
              name: 'render',
              children: [
                { name: 'ArrowType', value: 698 },
                { name: 'EdgeRenderer', value: 5569 },
                { name: 'IRenderer', value: 353 },
                { name: 'ShapeRenderer', value: 2247 }
              ]
            },
            { name: 'ScaleBinding', value: 11275 },
            { name: 'Tree', value: 7147 },
            { name: 'TreeBuilder', value: 9930 }
          ]
        },
        {
          name: 'events',
          children: [
            { name: 'DataEvent', value: 2313 },
            { name: 'SelectionEvent', value: 1880 },
            { name: 'TooltipEvent', value: 1701 },
            { name: 'VisualizationEvent', value: 1117 }
          ]
        },
        {
          name: 'legend',
          children: [
            { name: 'Legend', value: 20859 },
            { name: 'LegendItem', value: 4614 },
            { name: 'LegendRange', value: 10530 }
          ]
        },
        {
          name: 'operator',
          children: [
            {
              name: 'distortion',
              children: [
                { name: 'BifocalDistortion', value: 4461 },
                { name: 'Distortion', value: 6314 },
                { name: 'FisheyeDistortion', value: 3444 }
              ]
            },
            {
              name: 'encoder',
              children: [
                { name: 'ColorEncoder', value: 3179 },
                { name: 'Encoder', value: 4060 },
                { name: 'PropertyEncoder', value: 4138 },
                { name: 'ShapeEncoder', value: 1690 },
                { name: 'SizeEncoder', value: 1830 }
              ]
            },
            {
              name: 'filter',
              children: [
                { name: 'FisheyeTreeFilter', value: 5219 },
                { name: 'GraphDistanceFilter', value: 3165 },
                { name: 'VisibilityFilter', value: 3509 }
              ]
            },
            { name: 'IOperator', value: 1286 },
            {
              name: 'label',
              children: [
                { name: 'Labeler', value: 9956 },
                { name: 'RadialLabeler', value: 3899 },
                { name: 'StackedAreaLabeler', value: 3202 }
              ]
            },
            {
              name: 'layout',
              children: [
                { name: 'AxisLayout', value: 6725 },
                { name: 'BundledEdgeRouter', value: 3727 },
                { name: 'CircleLayout', value: 9317 },
                { name: 'CirclePackingLayout', value: 12003 },
                { name: 'DendrogramLayout', value: 4853 },
                { name: 'ForceDirectedLayout', value: 8411 },
                { name: 'IcicleTreeLayout', value: 4864 },
                { name: 'IndentedTreeLayout', value: 3174 },
                { name: 'Layout', value: 7881 },
                { name: 'NodeLinkTreeLayout', value: 12870 },
                { name: 'PieLayout', value: 2728 },
                { name: 'RadialTreeLayout', value: 12348 },
                { name: 'RandomLayout', value: 870 },
                { name: 'StackedAreaLayout', value: 9121 },
                { name: 'TreeMapLayout', value: 9191 }
              ]
            },
            { name: 'Operator', value: 2490 },
            { name: 'OperatorList', value: 5248 },
            { name: 'OperatorSequence', value: 4190 },
            { name: 'OperatorSwitch', value: 2581 },
            { name: 'SortOperator', value: 2023 }
          ]
        },
        { name: 'Visualization', value: 16540 }
      ]
    }
  ]
};

const chordData = [
  [11975, 5871, 8916, 2868],
  [1951, 10048, 2060, 6171],
  [8010, 16145, 8090, 8045],
  [1013, 990, 940, 6907]
];

export { sunData, chordData };
import { drawPie } from './Charts/pieChart'
import {
  drawBarChart,
  drawHorizontalBarChart,
  drawGroupBarChart,
  drawInteractiveBar,
  drawDoubleBar,
  drawNegativeBar,
} from './Charts/barChart'
import { zoomSunburst } from './Charts/zoomSunburst'
import { drawStackedArea } from './Charts/stackedAreaChart'
import { zoomBubbles } from './Charts/zoomBubbles'
import { drawChord } from './Charts/chord'
import { drawLine, drawTimeLine } from './Charts/line'

const draw = payload => {
  switch (payload.chartType) {
    case 'pie':
      drawPie(payload.id, payload.dataType, payload.data, {
        width: payload.width,
        height: payload.height,
      })
      break
    case 'bar':
      drawBarChart(payload.id, payload.dataType, payload.data, {
        width: payload.width,
        height: payload.height,
      })
      break
    case 'horizbar':
      drawHorizontalBarChart(payload.id, payload.dataType, payload.data, {
        width: payload.width,
        height: payload.height,
      })
      break
    case 'stackedarea':
      drawStackedArea(payload.id, payload.dataType, payload.data, {
        width: payload.width,
        height: payload.height,
      })
      break
    case 'groupBar':
      drawGroupBarChart(payload.id, payload.dataType, payload.data, {
        width: payload.width,
        height: payload.height,
      })
      break
    case 'sunburst':
      zoomSunburst(payload.id, payload.dataType, payload.data, {
        width: payload.width,
        height: payload.height,
      })
      break
    case 'bubbles':
      zoomBubbles(payload.id, payload.dataType, payload.data, {
        width: payload.width,
        height: payload.height,
      })
      break
    case 'chord':
      drawChord(payload.id, payload.dataType, payload.data, {
        width: payload.width,
        height: payload.height,
      })
      break
    case 'line':
      drawLine(payload.id, payload.dataType, payload.data, {
        width: payload.width,
        height: payload.height,
      })
      break
    case 'timeline':
      drawTimeLine(payload.id, payload.dataType, payload.data, {
        width: payload.width,
        height: payload.height,
      })
      break
    case 'interactiveBar':
      drawInteractiveBar(
        payload.id,
        payload.data,
        payload.canvasSize,
        payload.nodes,
        payload.params
      )
      break
    case 'doubleBar':
      drawDoubleBar(payload)
      break
    case 'negativeBar':
      drawNegativeBar(
        payload.id,
        payload.data,
        payload.canvasSize,
        payload.nodes,
        payload.params
      )
      break
    default:
      return `${payload.chartType} is not supported yet.`
  }
}

export { draw }
const convertDBgoals = dbgoals => {
  var totalRoutes = dbgoals.totalGymRoutes
  var localGoals = deepcopy(dbgoals)
  for (const key in dbgoals) {
    if (Array.isArray(dbgoals[key])) {
      for (var i = 0; i < dbgoals[key].length; i++) {
        if (dbgoals[key][i].value != 0) {
          localGoals[key][i].value = totalRoutes / dbgoals[key][i].value
        } else {
          localGoals[key][i].value = 0
        }
      }
    }
  }
  return localGoals
}

const convertLocalGoals = localGoals => {
  var totalRoutes = localGoals.totalGymRoutes
  var dbgoals = deepcopy(localGoals)
  for (const key in localGoals) {
    if (Array.isArray(localGoals[key])) {
      for (var i = 0; i < localGoals[key].length; i++) {
        if (localGoals[key][i].value != 0) {
          dbgoals[key][i].value = (
            totalRoutes / localGoals[key][i].value
          ).toFixed(3)
        } else {
          dbgoals[key][i].value = 0
        }
      }
    }
  }
  return dbgoals
}

const deepcopy = nested_obj => {
  var copy = {}
  for (const key in nested_obj) {
    if (!Array.isArray(nested_obj[key])) {
      copy[key] = nested_obj[key]
    } else {
      copy[key] = []
      for (var i = 0; i < nested_obj[key].length; i++) {
        copy[key].push({
          key: nested_obj[key][i].key,
          value: nested_obj[key][i].value,
        })
      }
    }
  }
  return copy
}

export { convertDBgoals, convertLocalGoals, deepcopy }
import axios from '../api'
import { deepcopy } from '../modules/D3/goalUtils'
import { emptyLocation } from '../variables'

const state = {
  headers: [
    { text: 'Name', value: 'name' },
    { text: 'Route Limit', value: 'routeLimit' },
    { text: 'Terrain Type', value: 'terrainType' },
    { text: 'Last Set', value: 'setDate' },
    { text: 'Action', value: 'action' },
  ],
  location: {
    ...deepcopy(emptyLocation),
  },
  locations: [],
  originalImageId: null,
  uploading: false,
}

const getters = {}

const actions = {
  async getLocations({ commit }) {
    try {
      const { data: locationsOrder } = await axios.get(
        '/api/customfields?name=location'
      )

      const { data: locations } = await axios.get(`/api/locations`)
      if (locationsOrder.length) {
        let keysArr = locationsOrder[0].values

        locations.sort(
          (a, b) => keysArr.indexOf(a.name) - keysArr.indexOf(b.name)
        )
      }
      commit('setLocations', locations)
    } catch (e) {
      return e.message
    }
  },
  async getLocation({ commit }, value) {
    try {
      const { data: location } = await axios.get(`/api/locations/${value._id}`)
      commit('setLocation', location)
    } catch (e) {
      return e.message
    }
  },
  updateCurrentLocationProp({ commit }, payload) {
    commit('updateCurrentLocationProp', payload)
  },
  async uploadImage({ commit, dispatch }) {
    const { location } = state
    const { image } = location
    const { originalImageId } = state
    try {
      if (image && !image._id) {
        if (originalImageId) {
          await dispatch('deleteImage', originalImageId)
        }
        const formData = new FormData()
        formData.append('gallery', image)
        const { data } = await axios.post('/api/images/upload', formData, {
          headers: { 'Content-Type': 'multipart/form-data' },
        })
        commit('updateCurrentLocationProp', { key: 'image', value: data })
        commit('toggleUploading')
        return data
      }
    } catch (e) {
      return e.response
    }
    return null
  },
  async deleteImage(_, imageId) {
    return axios.delete(`/api/images/${imageId}`)
  },
  async saveLocation({ dispatch, commit }) {
    try {
      let message
      await dispatch('uploadImage')
      if (state.location._id) {
        const { data: result } = await axios.put(
          `/api/locations/${state.location._id}`,
          state.location
        )
        commit('setLocation', result)
        message = `${result.name} updated`
        dispatch('messages/setMessage', message, { root: true })
      } else {
        const { data: result } = await axios.post(
          '/api/locations/create',
          state.location
        )
        commit('setLocation', result)
        message = `${result.name} saved`
        dispatch('messages/setMessage', message, {
          root: true,
        })
      }
      await dispatch('getLocations')
      const locationsNameArray = state.locations.map(l => l.name)

      dispatch(
        'fields/updateCustomField',
        { name: 'location', change: { values: locationsNameArray } },
        { root: true }
      )
    } catch (e) {
      return e.message
    }
  },
  async removeLocation({ dispatch }) {
    try {
      // if (object.image) {
      //   await dispatch('deleteImage', location.image._id)
      // }
      const { data: result } = await axios.delete(
        `/api/locations/${state.location._id}`
      )
      const message = `${result.name} deleted`
      dispatch('resetCurrentLocation')
      dispatch('messages/setMessage', message, {
        root: true,
      })
      await dispatch('getLocations')
      const locationsFieldArray = state.locations.map(l => l.name)
      dispatch(
        'fields/updateCustomField',
        { name: 'location', change: { values: locationsFieldArray } },
        { root: true }
      )
    } catch (e) {
      return e.message
    }
  },
  setLocations({ commit }, locations) {
    commit('setLocations', locations)
  },
  resetCurrentLocation({ commit }) {
    commit('resetCurrentLocation')
  },
  toggleUploading({ commit }) {
    commit('toggleUploading')
  },
  reorderLocations({ commit, dispatch }, locations) {
    commit('reorderLocations', locations)
    const locationsFieldArray = locations.map(l => l.name)
    dispatch(
      'fields/updateCustomField',
      { name: 'location', change: { values: locationsFieldArray } },
      { root: true }
    )
  },
}

const mutations = {
  setLocations(state, locations) {
    state.locations = locations
  },
  setLocation(state, location) {
    state.location = location
  },
  updateCurrentLocationProp(state, { key, value }) {
    state.location[key] = value
  },
  resetCurrentLocation(state) {
    state.location = { ...emptyLocation }
  },
  toggleUploading(state) {
    state.uploading = !state.uploading
  },
  reorderLocations(state, locations) {
    state.locations = locations
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import { emptyRoute } from '../variables'
import { deepcopy } from '../modules/D3/goalUtils'

const compareArrays = (arr1, arr2) => {
  var matches = arr1.filter(item => {
    return arr2.indexOf(item) > -1
  }).length
  return matches / arr2.length
}

const state = {
  route: { ...deepcopy(emptyRoute) },
  query: '',
  duplicates: [],
  exclusions: [
    'image',
    'stripped',
    'setScrewed',
    'date',
    'notes',
    '__v',
    '_id',
  ],
}

const getters = {}

const actions = {
  async saveRoute({ dispatch, commit }) {
    const { route } = state
    commit('updateRoute', {
      key: 'time',
      value: route.time.finished,
      subkey: 'finished',
    })
    return axios
      .post('/api/routes/create', route)
      .then(({ data: { message } }) => {
        dispatch('deleteDraft')
        dispatch('messages/setMessage', message, { root: true })
        if (route.planId) {
          dispatch('planSet/checkPlanCompletion', route.planId, { root: true })
        }
      })
      .catch(error => {
        return error
      })
  },
  saveDraft({ commit }) {
    const { route } = state
    return axios
      .post('/api/routes/draft/create', route)
      .then(({ data }) => {
        const { id } = data
        commit('updateRoute', { key: '_id', value: id })
      })
      .catch(error => {
        return error
      })
  },
  async updateDraft() {
    const { route } = state
    const { _id } = route
    return axios.put(`/api/routes/draft/${_id}`, route).catch(error => {
      return error
    })
  },
  deleteDraft() {
    const { route } = state
    const { _id } = route
    let url = 'api/routes/draft/' + _id
    return axios.delete(url).catch(error => {
      return error
    })
  },
  resetRoute({ commit }) {
    commit('resetRoute')
  },
  updateRoute({ commit, dispatch }, payload) {
    commit('updateRoute', payload)
    dispatch('getQuery')
    const { _id } = state.route
    if (!_id) {
      dispatch('saveDraft')
    } else {
      dispatch('updateDraft')
    }
  },
  replaceTime({ commit, dispatch }, payload) {
    commit('replaceTime', payload)
    dispatch('getQuery')
    const { _id } = state.route
    if (!_id) {
      dispatch('saveDraft')
    } else {
      dispatch('updateDraft')
    }
  },
  async updateImage({ dispatch }, image) {
    const formData = new FormData()
    formData.append('gallery', image)
    const {
      route: { image: oldImage },
    } = state
    if (oldImage) {
      axios.delete(`/api/image/${oldImage._id}`)
    }
    return axios
      .post('/api/image/upload', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      })
      .then(({ data }) => {
        dispatch('updateRoute', { key: 'image', value: data })
      })
      .catch(err => err)
  },
  setRouteToDraft({ commit }, payload) {
    commit('setRouteToDraft', payload)
  },
  getQuery({ commit, dispatch }) {
    const { location, grade, setter } = state.route
    const params = { location, grade, setter }
    const query = Object.keys(params)
      .reduce((carry, key) => {
        if (params[key]) {
          carry.push(key + '=' + params[key])
        }
        return carry
      }, [])
      .join('&')
    commit('setQuery', query)
    dispatch('getDuplicates')
  },
  getDuplicates({ commit, dispatch }) {
    let url = '/api/routes?stripped=false&' + state.query
    return axios
      .get(url)
      .then(({ data: duplicates }) => {
        commit('setDuplicates', duplicates)
        dispatch('getPossibilities')
      })
      .catch(error => {
        return error.message
      })
  },
  resetDuplicates({ commit }) {
    commit('resetDuplicates')
  },
  getPossibilities({ commit }) {
    const { route, duplicates, exclusions } = state
    duplicates.map((duplicate, index) => {
      var keys = Object.keys(route)
      var count = 0
      keys.unshift(count)
      const num = keys.reduce((total, key) => {
        if (exclusions.indexOf(key) < 0) {
          if (Array.isArray(route[key])) {
            total += compareArrays(route[key], duplicate[key])
          } else {
            route[key] === duplicate[key] ? (total += 1) : total, 0
          }
        }
        return total
      })
      let length = Object.keys(route).length
      let percentage = Math.round((num / length) * 100)
      let payload = { index: index, percentage: percentage }
      commit('setPossibility', payload)
    })
  },
}

const mutations = {
  updateRoute(state, params) {
    if (params['key'] == 'time') {
      state.route.time.stage = params['subkey']
      state.route.time[params['subkey']] = params['value']
    } else if (params['key'] == 'techniques') {
      const index = state.route[params['key']].indexOf(params['value'])
      if (index > -1) {
        state.route[params['key']].splice(index, 1)
      } else {
        state.route[params['key']].push(params['value'])
      }
    } else {
      state.route[params['key']] = params['value']
    }
  },
  replaceTime(state, payload) {
    for (const [key, value] of Object.entries(payload)) {
      if (key != 'stage') {
        state.route.time[key] += value
      } else {
        state.route.time[key] = value
      }
    }
  },
  resetRoute(state) {
    state.route = {
      ...emptyRoute,
    }
    state.route.techniques = []
    state.route.time.skeleton = 0
    state.route.time['setter forerun'] = 0
    state.route.time['group forerun'] = 0
    state.route.time.finished = 0
  },
  setRouteToDraft(state, route) {
    Object.keys(route).map(key => {
      state.route[key] = route[key]
    })
  },
  setQuery(state, query) {
    state.query = query
  },
  setDuplicates(state, duplicates) {
    state.duplicates = duplicates
  },
  resetDuplicates(state) {
    state.duplicates = []
  },
  setPossibility(state, { index, percentage }) {
    state.duplicates[index].percentage = percentage
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import { deepcopy } from '../modules/D3/goalUtils'
import { emptyGym, emptyLocation, emptySettings } from '../variables'
import { returnDefaultGoals } from '../../mixins/settingDefaults'
import { dateMixin } from '../../mixins/date'
import { Roles } from '../../store/tokens'

const state = {
  error: null,
  _id: null,
  currentStep: null,
  setterId: null,
  settings: { ...emptySettings },
  gym: { ...emptyGym },
  grades: [],
  locations: [],
  techniques: [],
  location: {
    ...deepcopy(emptyLocation),
  },
}
const getters = {}
const actions = {
  async saveSetup({ _ }, obj) {
    return await axios.put(`/api/gymSetup/${state._id}`, obj)
  },
  async incrementStep({ commit, dispatch }, step) {
    commit('incrementStep', step)
    return dispatch('saveSetup', { currentStep: state.currentStep })
  },
  async decrementStep({ commit, dispatch }, step) {
    commit('decrementStep', step)
    return dispatch('saveSetup', { currentStep: state.currentStep })
  },
  async initializeSetup({ commit, dispatch }, { currentStep, setterId }) {
    var result
    try {
      result = await axios.get('/api/gymSetup/')
      if (!result.data.length) {
        const newSetup = {
          currentStep: currentStep,
          setterId: setterId,
          gym: state.gym,
          settings: state.settings,
          grades: state.grades,
          locations: state.locations,
        }
        result = await dispatch('createSetup', newSetup)
      } else {
        result = result.data[0]
      }
      commit('setGymSetup', result)
    } catch (e) {
      return e.message
    }
  },
  async createSetup({ _ }, payload) {
    const { data: setup } = await axios.post('/api/gymSetup/create', payload)
    return setup
  },
  async getTechniques({ commit }) {
    try {
      // const {
      //   data: { currentUser, currentGym },
      // } = await axios.get('/api/currentUser')
      const { data: techniqueField } = await axios.get('/api/fields/techniques')
      commit('setField', { key: 'techniques', value: techniqueField.values })
    } catch (e) {
      return e.message
    }
  },
  async setGym({ _ }) {
    try {
      await axios.post('/api/gym/set', { gym: state.gym })
    } catch (e) {
      return e
    }
  },
  async setSetupStep({ dispatch }, { currentStep }) {
    return dispatch('saveSetup', { currentStep })
  },
  async saveGym({ commit, dispatch }) {
    try {
      const { gym } = state
      const { data } = await axios.put(`/api/gymSetup/${state._id}`, {
        gym,
      })
      commit('setField', { key: 'gym', value: data.gym })
      return { message: 'Gym updated' }
    } catch (e) {
      return e
    }
  },
  updateCurrentGymProp({ commit }, payload) {
    commit('updateCurrentGymProp', payload)
    commit('updateGymKey')
  },
  updateSettingsProp({ commit }, payload) {
    commit('updateSettingsProp', payload)
  },
  updateCustomScale({ commit, dispatch }, grades) {
    commit('setField', { key: 'grades', value: grades })
    return dispatch('saveSetup', { grades })
  },
  async updateLocations({ commit, dispatch }, locations) {
    commit('setField', { key: 'locations', value: locations })
    return dispatch('saveSetup', { locations })
  },
  async saveSettings({ commit, dispatch }) {
    commit('setField', { key: 'settings', value: state.settings })
    return dispatch('saveSetup', { settings: state.settings })
  },
  async setGrade({ commit, dispatch }, grades) {
    commit('setField', { key: 'grades', value: grades })
    return dispatch('saveSetup', { grades })
  },
  async saveCustomScale({ dispatch }) {
    return dispatch('saveSetup', { grades: state.grades })
  },
  async getLocation({ commit }, value) {
    try {
      commit('setField', { key: 'location', value })
    } catch (e) {
      return e.message
    }
  },
  resetCurrentLocation({ commit, dispatch }) {
    commit('setField', { key: 'location', value: { ...emptyLocation } })
    return dispatch('saveSetup', { location: { ...emptyLocation } })
  },
  updateCurrentLocationProp({ commit, dispatch }, payload) {
    commit('updateCurrentLocationProp', payload)
    return dispatch('saveSetup', { location: state.location })
  },
  async saveLocation({ dispatch, commit }) {
    try {
      commit('saveLocation')
      let message = `${state.location.name} updated`
      dispatch('messages/setMessage', message, { root: true })
      commit('setField', { key: 'location', value: { ...emptyLocation } })
      return dispatch('saveSetup', { locations: state.locations })
    } catch (e) {
      return e.message
    }
  },
  async removeLocation({ commit, dispatch }) {
    try {
      const message = `${state.location.name} deleted`
      commit('removeLocation', state.location.name)
      commit('setField', { key: 'location', value: { ...emptyLocation } })
      dispatch('messages/setMessage', message, {
        root: true,
      })
      return dispatch('saveSetup', { locations: state.locations })
    } catch (e) {
      return e.message
    }
  },
  reorderLocations({ commit, dispatch }, locations) {
    commit('setField', { key: 'locations', value: locations })
    return dispatch('saveSetup', { locations: state.locations })
  },
  async createGoals() {
    let numRoutes = state.locations.reduce((carry, item) => {
      carry += Number(item.routeLimit)
      return carry
    }, 0)
    let goal = returnDefaultGoals(state.grades, numRoutes, state.gym._id)
    return await axios.post('api/goals/create', goal)
  },
  async saveCustomField({ _ }, { values, name, label }) {
    let customField = { name, label, values, type: 'select', enabled: true }
    await axios.post('/api/customFields/create', customField)
  },
  async finishSetup({ commit, dispatch }, { currentUser }) {
    try {
      // save gym, save custom fields, save settings, save user, delete gymsetup
      const { data } = await axios.post(`/api/gym/create`, {
        gym: state.gym,
      })
      commit('setField', { key: 'gym', value: data.gym })
      await dispatch(
        'users/updateUser',
        {
          currentUser,
          role: Roles.HEAD_SETTER,
          activeGradeValues: state.grades,
          gymId: state.gym._id,
        },
        {
          root: true,
        }
      )
      // Stripe trail setup
      let trial_start = Math.floor(+new Date() / 1000)
      let trial_end = Math.floor(+new Date() / 1000) + 86400 * 30 // 30 days free
      await axios.post('/api/account/create', {
        gymId: state.gym._id,
        trial_start,
        trial_end,
      })
      await dispatch('setGym', {
        root: true,
      })
      await dispatch('createGoals', {
        root: true,
      })
      // throw 'error'
      await dispatch('saveCustomField', {
        name: 'grade',
        label: 'Grade',
        values: state.grades,
      })
      let locationNames = state.locations.reduce((carry, location) => {
        carry.push(location.name)
        return carry
      }, [])
      await dispatch('saveCustomField', {
        name: 'location',
        label: 'Location',
        values: locationNames,
      })
      await axios.post(`/api/locations/bulkInsert`, state.locations)
      await axios.post('/api/settings/create', state.settings)
      // let cus = await axios.post('/api/billing/create-customer', {
      //   address: {
      //     city: state.gym.city,
      //     country: state.gym.country,
      //     line1: state.gym.address,
      //     postal_code: state.gym.ZIPCode,
      //     state: state.gym.state,
      //   },
      //   email: currentUser.email,
      //   name: state.gym.name,
      // })
      // let customerId = cus.data.customer.id
      // let prices = await axios.get('/api/billing/prices')
      // await axios.post('/api/billing/create-trial-session', {
      //   customerId,
      //   priceId: prices.data.data[0].id, // hardcoded priceId for now
      //   trial_end,
      // })
      return await axios.delete(`/api/gymSetup/${state._id}`)
    } catch (e) {
      return e
    }
  },
}
const mutations = {
  incrementStep(state, step) {
    state.currentStep += step
  },
  decrementStep(state, step) {
    state.currentStep -= step
  },
  setField(state, { key, value }) {
    state[key] = value
  },
  updateGymKey(state) {
    state.gym.key =
      state.gym.name +
      state.gym.address +
      state.gym.city +
      state.gym.state +
      state.gym.ZIPCode +
      state.gym.country
  },
  saveLocation(state) {
    let index = state.locations.find(item => item.name == state.location.name)
    if (index) {
      state.locations[index] = state.location
    } else {
      state.locations = [...state.locations, state.location]
    }
  },
  removeLocation(state, name) {
    state.locations = state.locations.filter(item => item.name !== name)
  },
  updateCurrentLocationProp(state, { key, value }) {
    state.location[key] = value
  },
  setGymSetup(state, gymSetup) {
    for (const [key, value] of Object.entries(gymSetup)) {
      state[key] = value
    }
  },
  setError(state, message) {
    state.error = message
  },
  resetError(state) {
    state.error = null
  },
  updateCurrentGymProp(state, { key, value }) {
    state.gym[key] = value
  },
  updateCurrentProfileProp(state, { key, value }) {
    state.profile[key] = value
  },
  updateSettingsProp(state, { key, value }) {
    state.settings[key] = value
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import { convertDBgoals, deepcopy } from './D3/goalUtils'
import { globalStringFields, globalDefaultFields } from '../variables'

const state = {
  // goals: {},
  locations: [],
  activeRoutes: [],
  defaultFields: { ...deepcopy(globalDefaultFields) },
  historicalRoutes: [],
  allSetters: [],
  activeSetters: [],
  inactiveSetters: [],
  setterNames: [],
}

const getters = {}
const actions = {
  async getAll({ commit, dispatch }) {
    const { data: locations } = await axios.get('/api/locations')
    const { data: fields } = await axios.get(
      `/api/fields?names=${globalStringFields}`
    )
    const { data: grades } = await axios.get('/api/customFields/grade')
    const { data: routes } = await axios.get('api/routes?stripped=false')
    const { data: histRoutes } = await axios.get('api/routes?stripped=true')
    const { data: setters } = await axios.get('/api/setters')
    commit('loadLocations', locations)
    commit('loadFields', fields.concat(grades))
    commit('loadActiveRoutes', routes)
    commit('loadHistoricalRoutes', histRoutes)
    commit('loadAllSetters', setters)
  },
  updateWidth({ commit }, payload) {
    commit('updateWidth', payload)
  },
  updateDashboard({ commit }, payload) {
    commit('updateDashboard', payload)
  },
}

const mutations = {
  loadLocations(state, locations) {
    state.locations = locations
  },
  loadGoals(state, goals) {
    state.goals = convertDBgoals(goals)
  },
  loadFields(state, fields) {
    fields.forEach(field => {
      state.defaultFields[field.name] = field.values
    })
  },
  loadActiveRoutes(state, routes) {
    state.activeRoutes = routes
  },
  loadHistoricalRoutes(state, routes) {
    state.historicalRoutes = routes
  },
  loadAllSetters(state, setters) {
    state.allSetters = setters
    state.activeSetters = state.allSetters.reduce((carry, setter) => {
      if (setter.active == true) {
        carry.push(setter)
      }
      return carry
    }, [])
    state.inactiveSetters = state.allSetters.reduce((carry, setter) => {
      if (setter.active == false) {
        carry.push(setter)
      }
      return carry
    }, [])
    state.setterNames = state.activeSetters.reduce((carry, setter) => {
      carry.push(`${setter.firstName} ${setter.lastName}`)
      return carry
    }, [])
  },
  updateWidth(state, { width, index }) {
    state.dashboards[index].width = width
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import { emptyRoute } from '../variables'
import { deepcopy } from '../modules/D3/goalUtils'

const state = {
  route: { ...deepcopy(emptyRoute) },
  allRows: [],
  activeRows: [],
  currentRoute: {},
}

const getters = {}

const actions = {
  getAllRows({ commit }) {
    axios
      .get('/api/routes')
      .then(({ data: routes }) => {
        commit('setAllRows', routes)
      })
      .catch(error => {
        return error.message
      })
  },
  getActiveRows({ commit }) {
    axios
      .get('/api/routes?stripped=false')
      .then(({ data: routes }) => {
        commit('setActiveRows', routes)
      })
      .catch(error => {
        return error.message
      })
  },
  copyRoute({ commit }, payload) {
    commit('setRouteToStore', payload)
  },
  updateRoute({ commit }, payload) {
    commit('updateRoute', payload)
  },
  async saveRoute({ state }) {
    const { route } = state
    let url = '/api/routes/' + route._id
    return axios
      .put(url, route)
      .then(({ data: { message } }) => {
        return message
      })
      .catch(error => {
        return error
      })
  },
  async updateImage(_, image) {
    const formData = new FormData()
    formData.append('gallery', image)
    return axios.post('/api/image/upload', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    })
  },

  async deleteImage(_, oldImage) {
    return axios.delete(`/api/image/${oldImage._id}`)
  },
  bulkEdit({ dispatch }, obj) {
    let url = '/api/routes/bulk/edit'
    return axios
      .put(url, obj)
      .then(({ data: { message } }) => {
        dispatch('getAllRows')
        dispatch('getActiveRows')
        return message
      })
      .catch(error => {
        return error.message
      })
  },
  bulkDelete({ dispatch }, obj) {
    let url = '/api/routes/bulk/delete'
    return axios
      .delete(url, { data: obj })
      .then(({ data: { message } }) => {
        dispatch('getAllRows')
        dispatch('getActiveRows')
        return message
      })
      .catch(error => {
        return error.message
      })
  },
  reloadDefaults({ commit }) {
    commit('resetStates')
  },
}

const mutations = {
  setRouteToStore(state, route) {
    Object.keys(route).map(key => {
      state.route[key] = route[key]
    })
  },
  updateRoute(state, params) {
    if (params['key'] == 'time') {
      state.route.time[params['subkey']] = params['value']
    } else if (params['key'] == 'techniques') {
      const index = state.route[params['key']].indexOf(params['value'])
      if (index > -1) {
        state.route[params['key']].splice(index, 1)
      } else {
        state.route[params['key']].push(params['value'])
      }
    } else {
      state.route[params['key']] = params['value']
    }
  },
  setAllRows(state, routes) {
    state.allRows = routes
  },
  setActiveRows(state, routes) {
    state.activeRows = routes
  },
  setRoute(state, route) {
    state.currentRoute = route
  },
  resetStates(state) {
    state.currentRoute = {}
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
const state = {
  message: null,
}

const getters = {}

const actions = {
  setMessage({ commit }, message) {
    commit('setMessage', message)
  },
  resetMessage({ commit }) {
    commit('resetMessage')
  },
}

const mutations = {
  setMessage(state, message) {
    state.message = message
  },
  resetMessage(state) {
    state.message = null
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import { emptySettings } from '../variables'

const state = {
  settings: {
    ...emptySettings,
  },
  techniques: [],
  showAdvanced: false,
}

const getters = {}

const actions = {
  async getSettings({ commit, dispatch }) {
    try {
      const { data: settings } = await axios.get('/api/settings')
      commit('setSettings', settings)
      dispatch('getTechniques')
    } catch (e) {
      return e
    }
  },
  async updateSetting({ commit, dispatch, state }, payload) {
    const { fieldSet, change, module, returnMessage } = payload
    const { key, value } = change
    try {
      let {
        data: { message },
      } = await axios.put(`/api/settings/${state.settings._id}`, {
        [key]: value,
      })
      if (returnMessage) {
        message = returnMessage
      }
      commit('updateSetting', change)
      await dispatch('messages/setMessage', message, { root: true })
      await dispatch('getSettings')
      if (fieldSet) {
        let action = `${module}/setField`
        await dispatch(action, value, { root: true })
      }
    } catch (e) {
      return e
    }
  },
  toggleAdvanced({ commit }, boolean) {
    commit('toggleAdvanced', boolean)
  },
  getTechniques({ commit }) {
    axios
      .get('/api/fields/techniques')
      .then(({ data: techniques }) => {
        commit('setTechniques', techniques.values)
      })
      .catch(error => {
        return error.message
      })
  },
}

const mutations = {
  setSettings(state, settings) {
    state.settings = settings
  },
  updateSetting(state, { key, value }) {
    state.settings[key] = value
  },
  toggleAdvanced(state, boolean) {
    state.showAdvanced = boolean
  },
  setTechniques(state, techniques) {
    state.techniques = techniques
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import router from '../../router'

const state = {
  drafts: [],
  draft: {},
}

const getters = {}

const actions = {
  getDrafts({ commit }) {
    return axios
      .get('/api/routes/drafts')
      .then(({ data: drafts }) => {
        commit('setDrafts', drafts)
      })
      .catch(error => {
        return error.message
      })
  },
  getDraft({ commit }, draft) {
    const { _id } = draft
    return axios
      .get(`/api/routes/draft/${_id}`)
      .then(({ data: draft }) => {
        commit('setDraft', draft)
        router.push({ path: '/add-route' })
      })
      .catch(error => {
        return error.message
      })
  },
  bulkDelete({ dispatch }, obj) {
    let url = '/api/routes/drafts/bulk/delete'
    return axios
      .delete(url, { data: obj })
      .then(({ data: { message } }) => {
        dispatch('getDrafts')
        dispatch('resetDraft')
        return message
      })
      .catch(error => {
        return error.message
      })
  },
  resetDraft({ commit }) {
    commit('resetDraft')
  },
}

const mutations = {
  setDrafts(state, drafts) {
    state.drafts = drafts
  },
  setDraft(state, draft) {
    state.draft = draft
  },
  resetDraft(state) {
    state.draft = {}
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
import axios from '../api'
import { returnFields } from '../modules/D3/dataRetrieval'
import { globalStringFields, globalDefaultFields } from '../variables'
import { convertDBgoals, deepcopy } from '../modules/D3/goalUtils'
import { emptySetter } from '../variables'

const state = {
  defaultFields: { ...deepcopy(globalDefaultFields) },
  setterRoutes: [],
  assignments: [],
  currentAssignment: {},
  profile: {
    ...emptySetter,
  },
  originalAvatarId: null,
  activeRoutes: [],
  goals: null,
  fieldDistance: null,
  goalDiffNames: null,
  subFieldDistance: null,
}

const getters = {}

const actions = {
  loadGoalDiff({ commit }) {
    commit('loadGoalDiff')
  },
  loadDiffNames({ commit }) {
    commit('loadDiffNames')
  },
  async instantiateData({ commit, dispatch }, id) {
    const { data: globalFields } = await axios.get(
      `/api/fields?names=${globalStringFields}`
    )
    const { data: grades } = await axios.get('/api/customFields/grade')
    const fields = globalFields.concat(grades)
    fields.forEach(field =>
      commit('updateFields', { name: field.name, values: field.values })
    )
    await dispatch('getActiveRoutes', id)
    const { data: goals } = await axios.get('/api/goals?active=true')
    const { data: activeRoutes } = await axios.get('api/routes?stripped=false')
    commit('updateState', { key: 'goals', value: convertDBgoals(goals[0]) })
    commit('updateState', { key: 'activeRoutes', value: activeRoutes })
    commit('loadGoalDiff')
    commit('loadDiffNames')
  },
  async loadFields({ commit }) {
    const { data: globalFields } = await axios.get(
      `/api/fields?names=${globalStringFields}`
    )
    const { data: grades } = await axios.get('/api/customFields/grade')
    const fields = globalFields.concat(grades)
    fields.forEach(field =>
      commit('updateFields', { name: field.name, value: field.values })
    )
  },
  async getActiveRoutes({ commit }, name) {
    try {
      const { data: routes } = await axios.get(
        `api/routes?stripped=false&setter=${name}`
      )
      commit('loadActiveRoutes', routes)
    } catch (e) {
      return e.message
    }
  },
  async getAssignments({ commit }) {
    await axios
      .get(`/api/routes/drafts?setter=${state.profile._id}`)
      .then(({ data: drafts }) => {
        drafts.sort(function(a, b) {
          if (a.location < b.location) {
            return -1
          }
          if (a.location > b.location) {
            return 1
          }
          return 0
        })
        commit('setAssignments', drafts)
      })
      .catch(error => {
        return error.message
      })
  },
  getCurrentAssignment({ commit }, assignment) {
    commit('setCurrentAssignment', assignment)
  },
  async getProfile({ commit }, id) {
    try {
      const { data: setter } = await axios.get(`/api/setters?_id=${id}`)
      commit('setProfile', setter[0])
    } catch (e) {
      return e.message
    }
  },
  async updateCurrentProfileProp({ commit, dispatch }, payload) {
    const { key, value } = payload
    if (key === 'avatar' && !value.url) {
      dispatch('uploadAvatar', value)
    } else {
      try {
        const {
          data: { message },
        } = await axios.put(`/api/setters/${state.profile._id}`, {
          [key]: value,
        })
        dispatch('mainToolbar/getCurrentUser', {}, { root: true })
        dispatch('messages/setMessage', message, {
          root: true,
        })
        commit('updateCurrentProfileProp', payload)
      } catch (e) {
        return e.message
      }
    }
  },
  checkForOriginalAvatar({ commit }) {
    const { profile } = state
    const { avatar } = profile
    if (avatar) {
      if (avatar._id) {
        commit('setOriginalAvatarId', avatar._id)
      }
    }
  },
  async uploadAvatar({ commit, dispatch }, avatar) {
    const { originalAvatarId } = state
    try {
      if (originalAvatarId) {
        await dispatch('deleteAvatar', originalAvatarId)
      }
      const formData = new FormData()
      formData.append('gallery', avatar)
      const { data } = await axios.post('/api/images/upload', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      })
      await axios.put(`/api/setters/${state.profile._id}`, { avatar: data })
      await dispatch('mainToolbar/getCurrentUser', {}, { root: true })
      await dispatch('messages/setMessage', 'Your profile has been updated', {
        root: true,
      })
      commit('setOriginalAvatarId', data._id)
      commit('updateCurrentProfileProp', { key: 'avatar', value: data })
    } catch (e) {
      return e
    }
  },
  async deleteAvatar(_, imageId) {
    return axios.delete(`/api/images/${imageId}`)
  },
  resetProfile({ commit }) {
    commit('resetProfile')
  },
}

const mutations = {
  loadDiffNames(state) {
    var temp = []
    Object.keys(state.subFieldDistance).forEach(element => {
      temp.push(element.replace(/\s/g, ''))
    })
    state.goalDiffNames = temp
  },
  loadGoalDiff(state) {
    let allSubFields = [],
      subFieldDistance = {},
      allFields = {},
      fieldKeys = {}
    if (
      state.activeRoutes.length > 1 &&
      state.defaultFields.techniques != null
    ) {
      const data = returnFields(state.activeRoutes, state.defaultFields)
      if (data != undefined) {
        const totalRoutes = state.goals.totalGymRoutes
        let subCount = 0
        for (const [key, arr] of Object.entries(data)) {
          let subFields = {}
          let fieldDiff = 0
          for (let index = 0; index < arr.length; index++) {
            fieldKeys[subCount] = key
            subCount++
            let subKey = arr[index].key
            let currentValue = arr[index].value
            let goal = state.goals[key].filter(
              element => element.key == subKey
            )[0]
            let goalPerc = Number(
              (1 - Math.abs(goal.value - currentValue) / totalRoutes).toFixed(2)
            )
            subFields[subKey] = goalPerc
            allSubFields.push({ [subKey]: goalPerc })
            fieldDiff += goalPerc
          }
          // let fieldName = formatFields(key).toLowerCase()
          allFields[key] = (fieldDiff / arr.length).toFixed(2)
          subFieldDistance[key] = subFields
        }
      }
      state.fieldDistance = allFields
      state.subFieldDistance = subFieldDistance
    } else {
      state.fieldDistance = {}
      state.subFieldDistance = {}
    }
  },
  updateState(state, { key, value }) {
    state[key] = value
  },
  updateFields(state, field) {
    state.defaultFields[field.name] = field.values
  },
  loadActiveRoutes(state, routes) {
    state.setterRoutes = routes
  },
  setAssignments(state, assignments) {
    state.assignments = assignments
  },
  setCurrentAssignment(state, assignment) {
    state.currentAssignment = assignment
  },
  setProfile(state, setter) {
    state.profile = setter
  },
  updateCurrentProfileProp(state, { key, value }) {
    state.profile[key] = value
  },
  setOriginalAvatarId(state, id) {
    state.originalAvatarId = id
  },
  resetProfile(state) {
    state.profile = { ...emptySetter }
    state.originalAvatarId = null
  },
}

export default {
  namespaced: true,
  state,
  getters,
  actions,
  mutations,
}
const config = require('../app/config');
const mongoose = require('mongoose');

async function connectToTestDB() {
  try {
    return await mongoose.connect(config.testDB, {
      useUnifiedTopology: true,
      useNewUrlParser: true,
      useCreateIndex: true,
      useFindAndModify: false
    });
  } catch (e) {
    return e;
  }
}

module.exports = {
  connectToTestDB
};
const jwt = require('jsonwebtoken')
const faker = require('faker')
const config = require('../app/config')
const Gym = require('../app/models/gym')
const Location = require('../app/models/location')
const Setter = require('../app/models/setter')

async function createFakeDocs(role) {
  let gym = new Gym({
    name: 'The Best Gym',
    address: '123 Best St.',
    city: 'Best',
    state: 'Oregon',
    country: 'US',
    key: 'blahblahblahlbah',
    website: 'blahblahblahlbah.com',
  })
  gym = await gym.save()
  let location = new Location({
    gymId: gym._id,
    name: 'Precipice',
    routeLimit: 11,
    discipline: 'Bouldering',
    terrainType: ['Overhung'],
  })
  location = await location.save()
  let setter = new Setter({
    gyms: { [gym._id]: { role: 'Head Setter', maxBSettingAbility: 8 } },
    email: faker.internet.email(),
    superUser: false,
    active: true,
  })
  setter = await setter.save()
  return { gym, location, setter }
}

async function createFakeSession(role) {
  const { gym, location, setter } = await createFakeDocs(role)
  const token = jwt.sign(
    { userId: setter._id, userRole: role, gymId: gym._id },
    config.jwtSecret
  )
  return { gym, location, setter, token }
}

module.exports = {
  createFakeSession,
}
const app = require('../../app');
const faker = require('faker');
const request = require('supertest');
const { createFakeSession } = require('../fakeSession');
const { connectToTestDB } = require('../testUtils');

describe('Plans API Testing', () => {
  let mongo;
  let cookie;
  let planId;
  let fakeSetter;
  let fakeLocation;
  beforeAll(async () => {
    mongo = await connectToTestDB();
    const { token, location, setter } = await createFakeSession('Head Setter');
    cookie = `routemuse_session=${token}`;
    fakeSetter = setter;
    fakeLocation = location;
  });
  afterAll(async () => {
    await mongo.connection.db.dropDatabase();
    await mongo.connection.close();
  });
  test('plan creation', async () => {
    let { body } = await request(app)
      .post('/api/plans/create')
      .send({
        name: faker.lorem.words()
      })
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
    planId = body.plan._id;
    expect(body.message).toEqual('Plan created');
  });
  test('get plan details', async () => {
    let { body } = await request(app)
      .get(`/api/plans/${planId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
    expect(body._id).toEqual(planId);
  });
  test('get all plans', async () => {
    let { body } = await request(app)
      .get('/api/plans/')
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
    expect(body.length).toBeGreaterThan(0);
  });
  test('update a plan', async () => {
    let { body } = await request(app)
      .put(`/api/plans/${planId}`)
      .send({
        setters: [fakeSetter],
        locations: [fakeLocation]
      })
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
    expect(body.locations.length).toBeGreaterThan(0);
    expect(body.setters.length).toBeGreaterThan(0);
  });
  test('delete a plan', async () => {
    let { text } = await request(app)
      .delete(`/api/plans/${planId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect(200);
    expect(JSON.parse(text).message).toEqual('Plan deleted');
  });
});
const app = require('../../app')
const faker = require('faker')
const request = require('supertest')
const { createFakeSession } = require('../fakeSession')
const { connectToTestDB } = require('../testUtils')

describe('Gym API Testing', () => {
  let mongo
  let cookie
  let gymId
  beforeAll(async () => {
    mongo = await connectToTestDB()
    const { token, gym } = await createFakeSession('Head Setter')
    cookie = `routemuse_session=${token}`
    gymId = gym._id.toString()
  })
  afterAll(async () => {
    await mongo.connection.db.dropDatabase()
    await mongo.connection.close()
  })
  test('gym creation with existing user', async () => {
    let { text } = await request(app)
      .post('/api/gym/create')
      .send({
        email: 'testthebest@gmail.com',
        gym: {
          name: 'Best',
          address: faker.address.streetAddress(),
          city: faker.address.city(),
          state: faker.address.state(),
          ZIPCode: faker.address.zipCode(),
          country: 'US',
          key: 'wefwoeffew',
          website: faker.internet.url(),
        },
      })
      .set('Cookie', cookie)
      .set('Referer', '/create-gym')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Gym created')
  })
  test('gym creation with non-existing user', async () => {
    let { text } = await request(app)
      .post('/api/gym/create')
      .send({
        email: faker.internet.email(),
        gym: {
          name: faker.lorem.word(),
          address: faker.address.streetAddress(),
          city: faker.address.city(),
          state: faker.address.state(),
          ZIPCode: faker.address.zipCode(),
          country: 'US',
          key: 'wefwoeffewefw',
          website: faker.internet.url(),
        },
      })
      .set('Cookie', cookie)
      .set('Referer', '/create-gym')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Gym created')
  })
  test('get gym details', async () => {
    let { body } = await request(app)
      .get(`/api/gym/${gymId}`)
      .set('Cookie', cookie)
      .set('Referer', '/create-gym')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(body._id).toEqual(gymId)
  })
  test('get all gyms', async () => {
    let { body } = await request(app)
      .get('/api/gym/')
      .set('Cookie', cookie)
      .set('Referer', '/create-gym')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(body.length).toBeGreaterThan(0)
  })
  test('update a gym', async () => {
    let res = await request(app)
      .put(`/api/gym/${gymId}`)
      .send({
        city: 'Oakland',
      })
      .set('Cookie', cookie)
      .set('Referer', '/create-gym')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(res.body.city).toEqual('Oakland')
  })
  test('delete a gym', async () => {
    let { text } = await request(app)
      .delete(`/api/gym/${gymId}`)
      .set('Cookie', cookie)
      .set('Referer', '/create-gym')
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Gym deleted')
  })
})
const app = require('../../app')
const faker = require('faker')
const request = require('supertest')
const { createFakeSession } = require('../fakeSession')
const { connectToTestDB } = require('../testUtils')

let setterId
let setterTemplate = {
  gyms: {},
  firstName: 'Bob',
  lastName: null,
  email: faker.internet.email(),
  active: true,
  avatar: null,
  ricBias: null,
  superUser: false,
}

describe('testing /api/setter', () => {
  let mongo
  let cookie
  let fakeSetter
  let fakeLocation
  let fakeGym
  beforeAll(async () => {
    mongo = await connectToTestDB()
    const { gym, token, location, setter } = await createFakeSession(
      'Head Setter'
    )
    cookie = `routemuse_session=${token}`
    fakeSetter = setter
    fakeLocation = location
    fakeGym = gym
    setterTemplate.gyms = {
      [fakeGym._id]: { role: 'Head Setter', maxBSettingAbility: 8 },
    }
  })
  afterAll(() => {
    mongo.connection.db.dropDatabase()
    mongo.connection.close()
  })
  test('setter creation', async () => {
    let { text } = await request(app)
      .post('/api/setters/create')
      .send({ ...setterTemplate, gym: fakeGym })
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    let parsed = JSON.parse(text)
    setterId = parsed.setter._id
    expect(parsed.message).toEqual('Setter created')
  })
  // test('setter get', async () => {
  //   let { body } = await request(app)
  //     .get(`/api/setters/${setterId}`)
  //     .set('Cookie', cookie)
  //     .set('Referer', '/')
  //     .expect('Content-Type', /json/)
  //     .expect(200)
  //   expect(body.firstName).toEqual('Bob')
  // })
  test('setter update', async () => {
    let { text } = await request(app)
      .put(`/api/setters/${setterId}`)
      .send({ lastName: 'Billy' })
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(JSON.parse(text).message).toEqual("Bob's profile has been updated")
  })
  // test('setter assert change', async () => {
  //   let { body } = await request(app)
  //     .get(`/api/setters/${setterId}`)
  //     .set('Cookie', cookie)
  //     .set('Referer', '/')
  //     .expect('Content-Type', /json/)
  //     .expect(200)
  //   expect(body.lastName).toEqual('Billy')
  // })
  test('setter delete', async () => {
    let { text } = await request(app)
      .delete(`/api/setters/${setterId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Setter deleted')
  })
  test('setter get all', async () => {
    let { body } = await request(app)
      .get(`/api/setters/`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect(200)
    expect(body.length).toEqual(1)
  })
})
const app = require('../../app');
const request = require('supertest');
const { createFakeSession } = require('../fakeSession');
const { connectToTestDB } = require('../testUtils');

let goalTemplate = {
  gymId: null,
  name: 'Test Goals',
  date: new Date(),
  active: true,
  totalGymRoutes: 185,
  routesPerWeek: 0,
  maximumRouteAge: 0,
  techniques: [
    { key: 'Crossing', value: '14.000' },
    { key: 'Flagging', value: '14.000' },
    { key: 'Bumping', value: '14.000' },
    { key: 'Gaston', value: '14.000' },
    { key: 'Lock off', value: '14.000' },
    { key: 'High Step', value: '14.000' },
    { key: 'Layback', value: '14.000' },
    { key: 'Heel Hooking', value: '14.000' },
    { key: 'Toe Hooking', value: '14.000' },
    { key: 'Campusing', value: '14.000' },
    { key: 'Stemming', value: '14.000' },
    { key: 'Twisting', value: '14.000' },
    { key: 'Mantle', value: '14.000' },
    { key: 'Dyno', value: '14.000' }
  ],
  grade: [
    { key: 'blue', value: '10.000' },
    { key: 'pink', value: '10.000' },
    { key: 'purple', value: '10.000' },
    { key: 'green', value: '10.000' },
    { key: 'yellow', value: '10.000' },
    { key: 'orange', value: '10.000' },
    { key: 'red', value: '10.000' },
    { key: 'grey', value: '10.000' },
    { key: 'black', value: '10.000' },
    { key: 'white', value: '10.000' }
  ],
  length: [
    { key: 'Short', value: '2.487' },
    { key: 'Medium', value: '2.487' },
    { key: 'Long', value: '5.108' }
  ],
  risk: [
    { key: 1, value: '11.782' },
    { key: 2, value: '5.873' },
    { key: 3, value: '2.804' },
    { key: 4, value: '3.829' },
    { key: 5, value: '7.868' }
  ],
  intensity: [
    { key: 1, value: '8.083' },
    { key: 2, value: '3.619' },
    { key: 3, value: '2.788' },
    { key: 4, value: '6.034' },
    { key: 5, value: '13.240' }
  ],
  complexity: [
    { key: 1, value: '15.451' },
    { key: 2, value: '5.020' },
    { key: 3, value: '2.748' },
    { key: 4, value: '3.730' },
    { key: 5, value: '9.610' }
  ],
  heightFriendly: [
    { key: 'Average', value: '1.821' },
    { key: 'Short', value: '2.955' },
    { key: 'Tall', value: '8.904' }
  ],
  holdType: [
    { key: 'Crimp', value: 5 },
    { key: 'Pocket', value: 5 },
    { key: 'Jug', value: 5 },
    { key: 'Pinch', value: 5 },
    { key: 'Sloper', value: 5 }
  ]
};

describe('Goals API Testing', () => {
  let mongo;
  let cookie;
  let goalId;
  let fakeSetter;
  let fakeLocation;
  let fakeGym;
  beforeAll(async () => {
    mongo = await connectToTestDB();
    const { gym, token, location, setter } = await createFakeSession(
      'Head Setter'
    );
    cookie = `routemuse_session=${token}`;
    fakeSetter = setter;
    fakeLocation = location;
    fakeGym = gym;
    goalTemplate.gymId = fakeGym._id;
  });
  afterAll(async () => {
    await mongo.connection.db.dropDatabase();
    await mongo.connection.close();
  });
  test('goal creation', async () => {
    let { body } = await request(app)
      .post('/api/goals/create')
      .send(goalTemplate)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
    goalId = body.goal._id;
    expect(body.message).toEqual('Goal saved');
    expect(body.goal.name).toEqual('Test Goals');
  });
  test('get all goals', async () => {
    let { body } = await request(app)
      .get('/api/goals/')
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
    expect(body.length).toBeGreaterThan(0);
  });
  test('update a goal', async () => {
    let { text } = await request(app)
      .put(`/api/goals/${goalId}`)
      .send({ totalGymRoutes: 10 })
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect(200);
    expect(JSON.parse(text).message).toEqual('Goals updated');
  });
  test('get goal details', async () => {
    let { body } = await request(app)
      .get(`/api/goals/${goalId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
    expect(body.goal._id).toEqual(goalId);
    expect(body.goal.totalGymRoutes).toEqual(10);
    expect(body.goal.routesPerWeek).toEqual(0);
  });
  test('delete a goal', async () => {
    let { text } = await request(app)
      .delete(`/api/goals/${goalId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect(200);
    expect(JSON.parse(text).message).toEqual('Goals deleted');
  });
});
const app = require('../../app')
const request = require('supertest')
const { createFakeSession } = require('../fakeSession')
const { connectToTestDB } = require('../testUtils')

let draftTemplate = {
  gymId: null,
  discipline: 'Bouldering',
  location: null,
  length: null,
  grade: 'purple',
  setter: null,
  startLocation: 'Right-middle',
  finishLocation: 'Right-middle',
  techniques: ['Flagging'],
  heightFriendly: 'Tall',
  intraDifficulty: 5,
  risk: 5,
  intensity: 5,
  complexity: 5,
  setScrewed: false,
  stripped: false,
  date: new Date().toISOString(),
  emotion: 'Ballin',
  holdType: 'Jug',
  time: {
    skeleton: 0,
    'setter forerun': 0,
    'group forerun': 0,
    finished: 0,
    stage: 'skeleton',
  },
}

let routeTemplate = {
  gymId: null,
  discipline: 'Bouldering',
  location: null,
  length: 'Short',
  grade: 'purple',
  setter: null,
  startLocation: 'Right-middle',
  finishLocation: 'Right-middle',
  techniques: ['Flagging'],
  heightFriendly: 'Tall',
  intraDifficulty: 5,
  risk: 5,
  intensity: 5,
  complexity: 5,
  setScrewed: false,
  stripped: false,
  date: new Date().toISOString(),
  emotion: 'Ballin',
  holdType: 'Jug',
  time: {
    skeleton: 0,
    'setter forerun': 0,
    'group forerun': 0,
    finished: 0,
    stage: 'skeleton',
  },
}

describe('Routes API Testing', () => {
  let mongo
  let cookie
  let routeId
  let draftId
  let fakeSetter
  let fakeLocation
  let fakeGym
  beforeAll(async () => {
    mongo = await connectToTestDB()
    const { gym, token, location, setter } = await createFakeSession(
      'Head Setter'
    )
    cookie = `routemuse_session=${token}`
    fakeSetter = setter
    fakeLocation = location
    fakeGym = gym
    routeTemplate.gymId = fakeGym._id
    routeTemplate.location = fakeLocation.name
    routeTemplate.setter = fakeSetter.email
  })
  afterAll(async () => {
    await mongo.connection.db.dropDatabase()
    await mongo.connection.close()
  })
  test('route creation', async () => {
    let { text } = await request(app)
      .post('/api/routes/create')
      .send(routeTemplate)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Route created')
  })
  test('get all routes', async () => {
    let { body } = await request(app)
      .get('/api/routes/')
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(body.length).toBeGreaterThan(0)
    expect(body[0].length).toEqual('Short')
    expect(body[0].risk).toEqual(5)
    routeId = body[0]._id
  })
  test('update a route', async () => {
    let { text } = await request(app)
      .put(`/api/routes/${routeId}`)
      .send({ risk: 3 })
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Route updated')
  })
  test('get route details', async () => {
    let { body } = await request(app)
      .get(`/api/routes/${routeId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(body._id).toEqual(routeId)
    expect(body.risk).toEqual(3)
  })
  test('delete a route', async () => {
    let { text } = await request(app)
      .delete(`/api/routes/${routeId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Route deleted')
  })
  test('route creation with missing field', async () => {
    await request(app)
      .post('/api/routes/create')
      .send(draftTemplate)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', 'text/html; charset=utf-8')
      .expect(500)
  })
  test('draft creation', async () => {
    let { body } = await request(app)
      .post('/api/routes/draft/create')
      .send(draftTemplate)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    draftId = body.id
    expect(body.message).toEqual('Draft saved')
  })
  test('get all drafts', async () => {
    let { body } = await request(app)
      .get('/api/routes/drafts')
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(body.length).toBeGreaterThan(0)
    expect(body[0].grade).toEqual('purple')
    expect(body[0].risk).toEqual(5)
    draftId = body[0]._id
  })
  test('draft update', async () => {
    let { text } = await request(app)
      .put(`/api/routes/draft/${draftId}`)
      .send({ risk: 0 })
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Draft updated')
  })
  test('get draft details', async () => {
    let { body } = await request(app)
      .get(`/api/routes/draft/${draftId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(body.risk).toEqual(0)
  })
  test('draft delete', async () => {
    let { text } = await request(app)
      .delete(`/api/routes/draft/${draftId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Draft deleted')
  })
})
const app = require('../../app')
const request = require('supertest')
const { createFakeSession } = require('../fakeSession')
const { connectToTestDB } = require('../testUtils')

let settingsTemplate = {
  boulderingEnabled: true,
  boulderingSystem: 'Vermin',
  ropedClimbingEnabled: false,
  ropedClimbingSystem: null,
  defaultBoulderingGrades: [],
  defaultRopedClimbingGrades: [],
  distMethod: 'Time & Grade',
  noveltyType: 'Active',
  noveltyField: 'Grade',
  noveltyWeights: [0, 0, 0, 0, 0, 0],
  gradeMask: {},
  terrainMask: {
    Slab: [],
    Vertical: [],
    Overhung: [],
    Roof: [],
  },
}

describe('Settings API Testing', () => {
  let mongo
  let cookie
  let settingsId
  let fakeSetter
  let fakeLocation
  let fakeGym
  beforeAll(async () => {
    mongo = await connectToTestDB()
    const { gym, token, location, setter } = await createFakeSession(
      'Head Setter'
    )
    cookie = `routemuse_session=${token}`
    fakeSetter = setter
    fakeLocation = location
    fakeGym = gym
    //   settingsTemplate.gymId = fakeGym._id
    settingsTemplate.gymName = fakeGym.name
  })
  afterAll(async () => {
    await mongo.connection.db.dropDatabase()
    await mongo.connection.close()
  })
  test('settings creation', async () => {
    let { text } = await request(app)
      .post('/api/settings/create')
      .send(settingsTemplate)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Settings saved')
  })
  test('settings get', async () => {
    let { body } = await request(app)
      .get('/api/settings')
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    settingsId = body._id
  })
  test('settings update', async () => {
    let { text } = await request(app)
      .put(`/api/settings/${settingsId}`)
      .send({ noveltyWeights: [1, 1, 1, 1, 1] })
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Settings updated')
  })
  test('settings assert change', async () => {
    let { body } = await request(app)
      .get('/api/settings')
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
  })
  test('settings delete', async () => {
    let { text } = await request(app)
      .delete(`/api/settings/${settingsId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200)
    expect(JSON.parse(text).message).toEqual('Settings deleted')
  })
  test('settings get', async () => {
    let { body } = await request(app)
      .get('/api/settings')
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect(200)
    expect(body).toEqual({})
  })
})
const app = require('../../app');
const request = require('supertest');
const { createFakeSession } = require('../fakeSession');
const { connectToTestDB } = require('../testUtils');

let locationTemplate = {
  gymId: null,
  name: 'Precipice',
  routeLimit: 11,
  discipline: 'Bouldering',
  terrainType: ['Overhung']
};

describe('Location API Testing', () => {
  let mongo;
  let cookie;
  let locationId;
  let fakeSetter;
  let fakeLocation;
  let fakeGym;
  beforeAll(async () => {
    mongo = await connectToTestDB();
    const { gym, token, location, setter } = await createFakeSession(
      'Head Setter'
    );
    cookie = `routemuse_session=${token}`;
    fakeSetter = setter;
    fakeLocation = location;
    fakeGym = gym;
    locationTemplate.gymId = fakeGym._id;
  });
  afterAll(async () => {
    await mongo.connection.db.dropDatabase();
    await mongo.connection.close();
  });
  test('location creation', async () => {
    let { body } = await request(app)
      .post('/api/locations/create')
      .send(locationTemplate)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
    locationId = body._id;
    expect(body.name).toEqual('Precipice');
    expect(body.routeLimit).toEqual(11);
  });
  test('location update', async () => {
    await request(app)
      .put(`/api/locations/${locationId}`)
      .send({ routeLimit: 5 })
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
  });
  test('location get by id', async () => {
    let { body } = await request(app)
      .get(`/api/locations/${locationId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
    expect(body.routeLimit).toEqual(5);
  });
  test('location get all', async () => {
    let { body } = await request(app)
      .get(`/api/locations`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
    expect(body.length).toBeGreaterThan(0);
  });
  test('location delete', async () => {
    let { body } = await request(app)
      .delete(`/api/locations/${locationId}`)
      .set('Cookie', cookie)
      .set('Referer', '/')
      .expect('Content-Type', /json/)
      .expect(200);
  });
});
const app = require('./app');
const mongoose = require('mongoose');
const config = require('./app/config.js');
mongoose.set('useFindAndModify', false);

let mongodb = process.env.MONGODB_URI || config.db;
mongoose.connect(
  mongodb,
  {
    useUnifiedTopology: true,
    useNewUrlParser: true,
    useCreateIndex: true,
    useFindAndModify: false
  },
  function(err) {
    if (err) {
      console.log(err);
    }
  }
);

var port = config.port || 80;

app.use(function(req, res, next) {
  res.setHeader(
    'Access-Control-Allow-Methods',
    'GET, POST, OPTIONS, PUT, PATCH, DELETE'
  );
  res.setHeader(
    'Access-Control-Allow-Headers',
    'X-Requested-With,content-type'
  );
  next();
});

app.listen(port, () => {
  console.log('Server is up and running on port number ' + port);
});
const path = require('path')
const mongoose = require('mongoose')
const config = require('./app/config')
const Gym = require('./app/models/gym')
const Setter = require('./app/models/setter')
const Settings = require('./app/models/settings')
const Route = require('./app/models/route')
const Location = require('./app/models/location')
const Draft = require('./app/models/draft')
const Plan = require('./app/models/plan')
const CustomField = require('./app/models/customField')
const Image = require('./app/models/image')
const Account = require('./app/models/account')
const Target = require('./app/models/target')
const Session = require('./app/models/session')
// mongodb+srv://test:<password>@kerfuffle-atlas.8bomt.mongodb.net/?retryWrites=true&w=majority
const altasDB =
  'mongodb+srv://test:test@kerfuffle-atlas.8bomt.mongodb.net/setting?retryWrites=true&w=majority'
const localDB = `mongodb://127.0.0.1:27017/setting`

async function deleteGym(gymId) {
  // delete gym, settings,locations,customfields,undo setter roles,goals
  const gym = await Gym.findOne({ _id: mongoose.Types.ObjectId(gymId) })
  console.log(gym)
  const setters = await Setter.find()
  // console.log(gym.name, gymId)
  await Gym.deleteMany({
    _id: gym._id,
  })
  for (setter of setters) {
    if (gym._id in setter.gyms) {
      await Setter.updateOne(
        { _id: setter._id },
        { $unset: { gym: { [gym._id]: '' } } }
      )
    }
  }
  await Settings.deleteMany({ gymId: gym._id })
  await CustomField.deleteMany({
    gymId: gym._id,
  })
  await Location.deleteMany({ gymId: gym._id })
  await Image.deleteMany({ gymId: gym._id })
  await Target.deleteMany({ gymId: gym._id })
  await Route.deleteMany({ gymId: gym._id })
  await Draft.deleteMany({ gymId: gym._id })
  await Plan.deleteMany({ gymId: gym._id })
  await Account.deleteMany({ gymId: gym._id })
  await Session.deleteMany({ gymId: gym._id })
}

async function init(gymId) {
  let db
  let mongodb = altasDB // change this to local or atlas to delete gyms from that platform.
  try {
    db = await mongoose.connect(
      mongodb,
      { useUnifiedTopology: true, useNewUrlParser: true },
      function(err) {
        if (err) {
          console.log(err)
        }
      }
    )
    await deleteGym(gymId)
  } catch (error) {
    console.log(error)
  } finally {
    mongoose.connection.close()
  }
}

let gymIds = ['635f10f50a7cd50012dbffbd']
for (gymId of gymIds) {
  init(gymId) // change this for each gym you need to update. This is the one we have for Elevation.
}
const path = require('path')
const mongoose = require('mongoose')
const config = require('./app/config')
const Gym = require('./app/models/gym')
const Setter = require('./app/models/setter')
const Settings = require('./app/models/settings')
const Grade = require('./app/models/grade')
const Route = require('./app/models/route')
const Draft = require('./app/models/draft')
const Plan = require('./app/models/plan')
const Field = require('./app/models/field')
const CustomField = require('./app/models/customField')
const Image = require('./app/models/image')

const altasDB =
  'mongodb+srv://test:test@kerfuffle-atlas.8bomt.mongodb.net/setting?retryWrites=true&w=majority'
const localDB = `mongodb://127.0.0.1:27017/setting`

async function createSetterHashmap() {
  const setters = await Setter.find()
  var setter_hashmap = {}
  for (let setter of setters) {
    setter_hashmap[setter.toObject().nickname] = setter._id
  }
  return setter_hashmap
}

async function updateDrafts() {
  setter_hashmap = await createSetterHashmap()
  const routes = await Draft.find()
  for (let route of routes) {
    try {
      let route_setter = setter_hashmap[route.setter]
      console.log('route_setter', route_setter)
      await Draft.updateOne(
        { _id: route._id },
        { $set: { setter: route_setter } }
      )
    } catch (e) {
      console.log('error', e)
    }
  }
}

async function updateRoutes() {
  setter_hashmap = await createSetterHashmap()
  const routes = await Route.find()
  for (let route of routes) {
    try {
      let route_setter = setter_hashmap[route.setter]
      await Route.updateOne(
        { _id: route._id },
        { $set: { setter: route_setter } }
      )
    } catch (e) {
      console.log('error', e)
    }
  }
}

async function updateSettings() {
  const settings = await Settings.find()
  for (let setting of settings) {
    try {
      settingObj = setting.toObject()
      await Settings.updateOne(
        { _id: setting._id },
        { $unset: { gymName: 1, gymLogo: 1 } }
      )
    } catch (e) {
      console.log('error', e)
    }
  }
}

async function updateGyms() {
  const gyms = await Gym.find()
  for (let gym of gyms) {
    try {
      await Gym.updateOne(
        { _id: gym._id },
        {
          $set: {
            logo: mongoose.Types.ObjectId('5d51f0c48f8ae202b44a917b'),
            key:
              gym.name +
              gym.address +
              gym.city +
              gym.state +
              gym.ZIPCode +
              gym.country,
          },
        }
      )
    } catch (e) {
      console.log('error', e)
    }
  }
}

async function removeSetterAttrs() {
  // const setters = await Setter.find()
  // for (let setter of setters) {
  //   for (let gymId of Object.keys(setter.gyms)) {
  //     setterObj = setter.toObject()
  //     console.log('setterObj', setterObj)
  //     await Setter.updateOne(
  //       { _id: setterObj._id },
  //       {
  //         $set: {
  //           gyms: {
  //             [gymId]: {
  //               role: setterObj.role,
  //               maxBSettingAbility: setterObj.maxBSettingAbility || '',
  //               assignments: setterObj.assignments || 0,
  //               totalRoutes: setterObj.totalRoutes || 0,
  //               ricBias: setterObj.ricBias || '',
  //             },
  //           },
  //         },
  //       }
  //     )
  // }
  await Setter.updateMany(
    {
      $unset: {
        role: 1,
        maxBSettingAbility: 1,
        assignments: 1,
        totalRoutes: 1,
        ricBias: 1,
        holdPreference: 1,
        terrainPreference: 1,
        maxRCSettingAbility: 1,
        bComfortZone: 1,
        rcComfortZone: 1,
      },
    },
    { overwrite: true }
  )
}
async function init(gymId) {
  let db
  let mongodb = altasDB
  try {
    db = await mongoose.connect(
      mongodb,
      { useUnifiedTopology: true, useNewUrlParser: true },
      function(err) {
        if (err) {
          console.log(err)
        }
      }
    )
    // let gyms = await Gym.find()
    // console.log('gyms', gyms)
    // await updateDrafts()
    // await updateRoutes()
    // await updateSettings()
    // await updateGyms()
    // await removeSetterAttrs()
    // updates casing for terrainPreference and holdPreference
    // finds fields that should be custom fields, saves them as custom fields and removes them as global fields.

    // creates customgrade doc, removes values from corresponding custom doc in grades.
    // const grades = await Grade.find()
    // for (let grade of grades) {
    //   if (
    //     grade.name === 'Custom' &&
    //     grade.discipline === 'Bouldering' &&
    //     grade.values.length > 0
    //   ) {
    //     const change = grade.toObject()
    //     delete change._id
    //     delete change.name
    //     delete change.description
    //     change.gymId = gymId
    //     const customGrade = new CustomGrade(change)
    //     await customGrade.save()
    //     await Grade.updateOne({ _id: grade._id }, { $set: { values: [] } })
    //   }
    // }
  } catch (error) {
    console.log(error)
  } finally {
    mongoose.connection.close()
  }
}

let gymId = '5e4c762d98350305dfa6622e'
init(gymId) // change this for each gym you need to update. This is the one we have for Elevation.
module.exports = {
  tabWidth: 2,
  spaces: 2,
  singleQuote: true,
};
module.exports = {
  env: {
    node: true,
  },
  extends: 'eslint:recommended',
  parserOptions: {
    ecmaVersion: 2015,
    parser: 'babel-eslint',
  },
  rules: {
    'no-console': 'off',
    'no-unreachable': 'on',
    'no-unexpected-multiline': 'on',
    indent: ['error', 2],
    'linebreak-style': ['error', 'unix'],
    quotes: ['error', 'single'],
    semi: ['error', 'never'],
  },
  parserOptions: {
    sourceType: 'module',
  },
}
const Field = require('./app/models/field')
const CustomField = require('./app/models/customField')
const Settings = require('./app/models/settings')

async function setup(gym) {
  try {
    const techniqueField = await Field.findOne({ name: 'techniques' })
    const gradeMask = techniqueField.values.reduce((carry, technique) => {
      carry[technique] = null
      return carry
    }, {})
    const newSettings = new Settings({
      gymId: gym._id,
      boulderingEnabled: true,
      boulderingSystem: null,
      ropedClimbingEnabled: false,
      ropedClimbingSystem: null,
      defaultBoulderingGrades: [],
      defaultRopedClimbingGrades: [],
      distMethod: 'Time & Grade',
      noveltyType: 'Active',
      noveltyField: 'Grade',
      noveltyWeights: [0, 0, 0, 0, 0, 0],
      gradeMask,
      terrainMask: {
        Slab: [],
        Vertical: [],
        Overhung: [],
        Roof: [],
      },
      displayedHeaders: ['Date', 'Setter', 'Grade', 'Location', 'Stripped'],
      displayedDraftHeaders: ['Date', 'Setter', 'Grade', 'Location', 'Notes'],
    })
    const customFields = [
      {
        name: 'location',
        label: 'Location',
        values: [],
        type: 'select',
        enabled: true,
        gymId,
      },
      {
        name: 'grade',
        label: 'Grade',
        values: [],
        type: 'select',
        enabled: true,
        gymId,
      },
    ]
    await CustomField.insertMany(customFields)
    return await newSettings.save()
  } catch (e) {
    return e
  }
}

module.exports = {
  setup,
}
